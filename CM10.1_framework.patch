diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/Android.mk pang/frameworks/base/Android.mk
--- /media/ROM-Speicher/CM10.1/frameworks/base/Android.mk	2013-05-03 11:50:59.413852707 +0545
+++ pang/frameworks/base/Android.mk	2013-05-03 22:01:20.073753620 +0545
@@ -55,6 +55,7 @@ LOCAL_SRC_FILES := $(filter-out \
 ## across process boundaries.
 ##
 ## READ ME: ########################################################
+# BEGIN privacy-added: IPrivacySettingsManager.aidl
 LOCAL_SRC_FILES += \
 	core/java/android/accessibilityservice/IAccessibilityServiceConnection.aidl \
 	core/java/android/accessibilityservice/IAccessibilityServiceClient.aidl \
@@ -213,6 +214,7 @@ LOCAL_SRC_FILES += \
 	media/java/android/media/IRemoteControlDisplay.aidl \
 	media/java/android/media/IRemoteVolumeObserver.aidl \
 	media/java/android/media/IRingtonePlayer.aidl \
+	privacy/java/android/privacy/IPrivacySettingsManager.aidl \
 	telephony/java/com/android/internal/telephony/IPhoneStateListener.aidl \
 	telephony/java/com/android/internal/telephony/IPhoneSubInfo.aidl \
 	telephony/java/com/android/internal/telephony/ITelephony.aidl \
@@ -238,6 +240,7 @@ LOCAL_SRC_FILES += \
 	fmradio/java/com/stericsson/hardware/fm/IOnExtraCommandListener.aidl \
 	fmradio/java/com/stericsson/hardware/fm/IOnAutomaticSwitchListener.aidl
 #
+# END privacy-added: IPrivacySettingsManager.aidl
 
 
 # FRAMEWORKS_BASE_JAVA_SRC_DIRS comes from build/core/pathmap.mk
@@ -277,6 +280,7 @@ framework_built := $(call java-lib-deps,
 # AIDL files to be preprocessed and included in the SDK,
 # relative to the root of the build tree.
 # ============================================================
+# BEGIN privacy-added: PrivacySettings.aidl
 aidl_files := \
 	frameworks/base/core/java/android/accounts/IAccountManager.aidl \
 	frameworks/base/core/java/android/accounts/IAccountManagerResponse.aidl \
@@ -325,6 +329,7 @@ aidl_files := \
 	frameworks/base/location/java/android/location/Criteria.aidl \
 	frameworks/base/location/java/android/location/Geofence.aidl \
 	frameworks/base/location/java/android/location/Location.aidl \
+	frameworks/base/privacy/java/android/privacy/PrivacySettings.aidl \
 	frameworks/base/location/java/android/location/LocationRequest.aidl \
 	frameworks/base/location/java/com/android/internal/location/ProviderProperties.aidl \
 	frameworks/base/location/java/com/android/internal/location/ProviderRequest.aidl \
@@ -333,6 +338,8 @@ aidl_files := \
 	frameworks/base/telephony/java/com/android/internal/telephony/ITelephony.aidl \
 
 gen := $(TARGET_OUT_COMMON_INTERMEDIATES)/framework.aidl
+# END privacy-added: PrivacySettings.aidl
+
 $(gen): PRIVATE_SRC_FILES := $(aidl_files)
 ALL_SDK_FILES += $(gen)
 $(gen): $(aidl_files) | $(AIDL)
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/core/java/android/app/ActivityManagerNative.java pang/frameworks/base/core/java/android/app/ActivityManagerNative.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/core/java/android/app/ActivityManagerNative.java	2013-04-02 21:48:00.353501856 +0545
+++ pang/frameworks/base/core/java/android/app/ActivityManagerNative.java	2013-05-03 21:34:13.395969959 +0545
@@ -47,6 +47,11 @@ import android.util.Singleton;
 import java.util.ArrayList;
 import java.util.List;
 
+///////////////////////////////////////////////
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageManager;
+///////////////////////////////////////////////
+
 /** {@hide} */
 public abstract class ActivityManagerNative extends Binder implements IActivityManager
 {
@@ -3087,6 +3092,12 @@ class ActivityManagerProxy implements IA
     }
     public int checkPermission(String permission, int pid, int uid)
             throws RemoteException {
+		if (permission.equals("android.privacy.WRITE_PRIVACY_SETTINGS")) {
+			IPackageManager mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+	        String[] package_names = mPm.getPackagesForUid(uid);
+			for(String packageName : package_names)
+				if(!packageName.equals("com.android.privacy.pdroid20")) return PackageManager.PERMISSION_DENIED;
+		}
         Parcel data = Parcel.obtain();
         Parcel reply = Parcel.obtain();
         data.writeInterfaceToken(IActivityManager.descriptor);
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/core/java/android/app/ContextImpl.java pang/frameworks/base/core/java/android/app/ContextImpl.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/core/java/android/app/ContextImpl.java	2013-04-02 21:48:00.385501449 +0545
+++ pang/frameworks/base/core/java/android/app/ContextImpl.java	2013-05-03 21:34:52.431950963 +0545
@@ -65,7 +65,7 @@ import android.location.ILocationManager
 import android.location.LocationManager;
 import android.media.AudioManager;
 import android.media.MediaRouter;
-import android.net.ConnectivityManager;
+//import android.net.ConnectivityManager;
 import android.net.IConnectivityManager;
 import android.net.INetworkPolicyManager;
 import android.net.NetworkPolicyManager;
@@ -117,6 +117,16 @@ import android.accounts.IAccountManager;
 import android.app.admin.DevicePolicyManager;
 import com.android.internal.os.IDropBoxManagerService;
 
+// BEGIN privacy-added
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.surrogate.PrivacyAccountManager;
+import android.privacy.surrogate.PrivacyLocationManager;
+import android.privacy.surrogate.PrivacyTelephonyManager;
+import android.privacy.surrogate.PrivacyWifiManager;
+import android.privacy.surrogate.PrivacyConnectivityManager;
+// END privacy-added
+
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
@@ -192,6 +202,9 @@ class ContextImpl extends Context {
     private Resources mResources;
     /*package*/ ActivityThread mMainThread;
     private Context mOuterContext;
+    // BEGIN privacy-added
+    private static Context sOuterContext;
+    // END privacy-added
     private IBinder mActivityToken = null;
     private ApplicationContentResolver mContentResolver;
     private int mThemeResource = 0;
@@ -307,7 +320,10 @@ class ContextImpl extends Context {
                 public Object createService(ContextImpl ctx) {
                     IBinder b = ServiceManager.getService(ACCOUNT_SERVICE);
                     IAccountManager service = IAccountManager.Stub.asInterface(b);
-                    return new AccountManager(ctx, service);
+                    //return new AccountManager(ctx, service);
+                    // BEGIN privacy-modified
+                    return new PrivacyAccountManager(ctx, service);
+                    // END privacy-modified
                 }});
 
         registerService(ACTIVITY_SERVICE, new ServiceFetcher() {
@@ -346,7 +362,11 @@ class ContextImpl extends Context {
         registerService(CONNECTIVITY_SERVICE, new StaticServiceFetcher() {
                 public Object createStaticService() {
                     IBinder b = ServiceManager.getService(CONNECTIVITY_SERVICE);
-                    return new ConnectivityManager(IConnectivityManager.Stub.asInterface(b));
+                    //BEGIN PRIVACY ADDED
+                    //return new ConnectivityManager(IConnectivityManager.Stub.asInterface(b));
+                    IConnectivityManager service = IConnectivityManager.Stub.asInterface(b);
+                    return new PrivacyConnectivityManager(service, getStaticOuterContext());
+                    //END PRIVACY ADDED
                 }});
 
         registerService(COUNTRY_DETECTOR, new StaticServiceFetcher() {
@@ -412,8 +432,15 @@ class ContextImpl extends Context {
 
         registerService(LOCATION_SERVICE, new ServiceFetcher() {
                 public Object createService(ContextImpl ctx) {
-                    IBinder b = ServiceManager.getService(LOCATION_SERVICE);
-                    return new LocationManager(ctx, ILocationManager.Stub.asInterface(b));
+                    
+	            IBinder b = ServiceManager.getService(LOCATION_SERVICE);
+
+	            //return new LocationManager(ctx, ILocationManager.Stub.asInterface(b));
+		    
+	            // BEGIN privacy-modified
+	            return new PrivacyLocationManager(ILocationManager.Stub.asInterface(b), getStaticOuterContext());
+	            // END privacy-modified
+                    
                 }});
 
         registerService(NETWORK_POLICY_SERVICE, new ServiceFetcher() {
@@ -484,7 +511,10 @@ class ContextImpl extends Context {
 
         registerService(TELEPHONY_SERVICE, new ServiceFetcher() {
                 public Object createService(ContextImpl ctx) {
-                    return new TelephonyManager(ctx.getOuterContext());
+                    //return new TelephonyManager(ctx.getOuterContext());
+                    // BEGIN privacy-modified
+                    return new PrivacyTelephonyManager(ctx.getOuterContext());
+                    // END privacy-modified
                 }});
 
         registerService(THROTTLE_SERVICE, new StaticServiceFetcher() {
@@ -521,7 +551,10 @@ class ContextImpl extends Context {
                 public Object createService(ContextImpl ctx) {
                     IBinder b = ServiceManager.getService(WIFI_SERVICE);
                     IWifiManager service = IWifiManager.Stub.asInterface(b);
-                    return new WifiManager(ctx.getOuterContext(), service);
+                    // BEGIN privacy
+                    //return new WifiManager(ctx.getOuterContext(), service);
+                    return new PrivacyWifiManager(service, ctx);
+                    // END privacy
                 }});
 
         registerService(WIFI_P2P_SERVICE, new ServiceFetcher() {
@@ -573,6 +606,14 @@ class ContextImpl extends Context {
                     IFmTransmitter service = IFmTransmitter.Stub.asInterface(b);
                     return new FmTransmitterImpl(service);
                 }});
+        		// BEGIN privacy-added
+        		registerService("privacy", new StaticServiceFetcher() {
+                public Object createStaticService() {
+                    IBinder b = ServiceManager.getService("privacy");
+                    IPrivacySettingsManager service = IPrivacySettingsManager.Stub.asInterface(b);
+                    return new PrivacySettingsManager(getStaticOuterContext(),service);
+                }});
+        		// END privacy-added
     }
 
     static ContextImpl getImpl(Context context) {
@@ -1081,7 +1122,8 @@ class ContextImpl extends Context {
 
     @Override
     public void sendBroadcast(Intent intent) {
-        warnIfCallingFromSystemProcess();
+    	if(!isPrivacyBroadCast(intent))
+    		warnIfCallingFromSystemProcess();
         String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
         try {
             intent.setAllowFds(false);
@@ -1095,7 +1137,8 @@ class ContextImpl extends Context {
 
     @Override
     public void sendBroadcast(Intent intent, String receiverPermission) {
-        warnIfCallingFromSystemProcess();
+    	if(!isPrivacyBroadCast(intent))
+    		warnIfCallingFromSystemProcess();
         String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
         try {
             intent.setAllowFds(false);
@@ -1110,7 +1153,8 @@ class ContextImpl extends Context {
     @Override
     public void sendOrderedBroadcast(Intent intent,
             String receiverPermission) {
-        warnIfCallingFromSystemProcess();
+    	if(!isPrivacyBroadCast(intent))
+    		warnIfCallingFromSystemProcess();
         String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
         try {
             intent.setAllowFds(false);
@@ -1764,6 +1808,18 @@ class ContextImpl extends Context {
                       message);
     }
 
+    /**
+     * checks if current intent is a privacy related intent
+     * @param intent current intent
+     * @return true if intent contains privacy notifications, false otherwise
+     */
+    private boolean isPrivacyBroadCast(Intent intent) {
+    	if(intent != null && intent.getAction() != null && intent.getAction().equals(PrivacySettingsManager.ACTION_PRIVACY_NOTIFICATION))
+    		return true;
+    	else
+    		return false;
+    }
+    
     private void warnIfCallingFromSystemProcess() {
         if (Process.myUid() == Process.SYSTEM_UID) {
             Slog.w(TAG, "Calling a method in the system process without a qualified user: "
@@ -1886,7 +1942,7 @@ class ContextImpl extends Context {
     }
 
     ContextImpl() {
-        mOuterContext = this;
+        sOuterContext = mOuterContext = this;
     }
 
     /**
@@ -1903,7 +1959,7 @@ class ContextImpl extends Context {
         mContentResolver = context.mContentResolver;
         mUser = context.mUser;
         mDisplay = context.mDisplay;
-        mOuterContext = this;
+        sOuterContext = mOuterContext = this;
     }
 
     final void init(LoadedApk packageInfo, IBinder activityToken, ActivityThread mainThread) {
@@ -1959,13 +2015,17 @@ class ContextImpl extends Context {
     }
 
     final void setOuterContext(Context context) {
-        mOuterContext = context;
+        sOuterContext = mOuterContext = context;
     }
 
     final Context getOuterContext() {
         return mOuterContext;
     }
 
+    final static Context getStaticOuterContext() {
+        return sOuterContext;
+    }
+
     final IBinder getActivityToken() {
         return mActivityToken;
     }
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/core/java/android/app/Instrumentation.java pang/frameworks/base/core/java/android/app/Instrumentation.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/core/java/android/app/Instrumentation.java	2013-04-02 21:48:00.389501400 +0545
+++ pang/frameworks/base/core/java/android/app/Instrumentation.java	2013-02-02 17:17:26.142024946 +0545
@@ -48,6 +48,14 @@ import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
 
+///////////////////////////////////////////////////
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+import android.telephony.TelephonyManager;
+///////////////////////////////////////////////////
+
 
 /**
  * Base class for implementing application instrumentation code.  When running
@@ -88,6 +96,10 @@ public class Instrumentation {
     private boolean mAutomaticPerformanceSnapshots = false;
     private PerformanceCollector mPerformanceCollector;
     private Bundle mPerfMetrics = new Bundle();
+    
+    //---------------------------------------------------------------------------------------------------------------------------------------------------------
+    private PrivacySettingsManager pSetMan;
+    //---------------------------------------------------------------------------------------------------------------------------------------------------------
 
     public Instrumentation() {
     }
@@ -1391,6 +1403,62 @@ public class Instrumentation {
             Context who, IBinder contextThread, IBinder token, Activity target,
             Intent intent, int requestCode, Bundle options) {
         IApplicationThread whoThread = (IApplicationThread) contextThread;
+        //we first do not intercept open activity, because we're looking forward if it works fine!
+        //--------------------------------------------------------------------------------------------------------------------------------------------------------
+        boolean isAllowed = true;
+        try{
+        	PrivacyDebugger.i("PrivacyContext","now we are in execStartActivity() from package: " + who.getPackageName());
+        	 if(intent != null && intent.getAction() != null && (intent.getAction().equals(Intent.ACTION_CALL) || intent.getAction().equals(Intent.ACTION_DIAL))) {
+            	PrivacyDebugger.i("PrivacyContext","package: " + who.getPackageName() + " tries to take a phone call");
+        		if(pSetMan == null) pSetMan = new PrivacySettingsManager(who, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+        		PrivacySettings settings = pSetMan.getSettings(who.getPackageName(), -1);
+        		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){ //is not allowed
+        			//test if broadcasting works!
+            		final Context tmp = who;
+            		isAllowed = false;
+            		new Thread(new Runnable() {
+            		    public void run() {
+            		    	try{
+             		    		Thread.sleep(1000); //wait 1 Second
+             		    	}
+             		    	catch(Exception e){
+             		    		//nothing here
+             		    	}  
+            		    	Intent privacy = new Intent("android.privacy.BLOCKED_PHONE_CALL");
+                    		Bundle extras = new Bundle();
+                    		extras.putString("packageName", tmp.getPackageName());
+                    		extras.putInt("phoneState", TelephonyManager.CALL_STATE_IDLE);
+                    		privacy.putExtras(extras);
+                    		tmp.sendBroadcast(privacy);
+                    		PrivacyDebugger.i("PrivacyContext","sent privacy intent");
+            		    }
+            		}).start();
+            		
+            		if(settings.isDefaultDenyObject())
+            			pSetMan.notification(who.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, settings);
+            		else
+            			pSetMan.notification(who.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, settings);
+        		}
+        		else{ //is allowed
+        			isAllowed = true;
+        			if(settings != null && settings.isDefaultDenyObject())
+        				pSetMan.notification(who.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, settings);
+        			else
+        				pSetMan.notification(who.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, settings);
+        		}
+        		
+            }
+        }
+        catch(Exception e){
+        	 //e.printStackTrace();
+        	 if(who != null)
+        	 	 PrivacyDebugger.i("PrivacyContext","got exception while trying to resolve intents for package: " + who.getPackageName(), e);
+        	 else
+        	 	 PrivacyDebugger.i("PrivacyContext","got exception while trying to resolve intents for unknown package", e);
+        	 
+        }
+    	
+        //--------------------------------------------------------------------------------------------------------------------------------------------------------
         if (mActivityMonitors != null) {
             synchronized (mSync) {
                 final int N = mActivityMonitors.size();
@@ -1406,6 +1474,15 @@ public class Instrumentation {
                 }
             }
         }
+        //now fake state
+        try{
+        	if(!isAllowed) return new ActivityResult(requestCode, intent);
+        }
+        catch(Exception e){
+        	//e.printStackTrace();
+		//nothing here
+        }
+    	//end testing
         try {
             intent.setAllowFds(false);
             intent.migrateExtraStreamToClipData();
@@ -1446,6 +1523,72 @@ public class Instrumentation {
             IBinder token, Activity target, Intent[] intents, Bundle options,
             int userId) {
         IApplicationThread whoThread = (IApplicationThread) contextThread;
+        //--------------------------------------------------------------------------------------------------------------------------------------------------------
+        boolean isAllowed = true;
+        try{
+        	PrivacyDebugger.i("PrivacyContext","now we are in execStartActivities() from package: " + who.getPackageName());
+        	List<Intent> tmp = new ArrayList<Intent>();
+        	boolean call_detected = false;
+        	for(int i=0;i<intents.length;i++){
+        		if(intents[i].getAction() != null && (intents[i].getAction().equals(Intent.ACTION_CALL) || intents[i].getAction().equals(Intent.ACTION_DIAL))) { 
+        			call_detected = true;
+        			continue;
+        		}
+        		tmp.add(intents[i]);
+        	}
+        	if(call_detected){
+        		PrivacyDebugger.i("PrivacyContext","package: " + who.getPackageName() + " tries to take a phone call");
+        		if(pSetMan == null) pSetMan = new PrivacySettingsManager(who, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+        		PrivacySettings settings = pSetMan.getSettings(who.getPackageName(), -1);
+        		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){ //is not allowed
+        			final Context ctx = who;
+            		//now replace intents
+            		intents = (Intent[]) tmp.toArray();
+            		tmp = null;
+            		System.gc();
+            		new Thread(new Runnable() {
+            		    public void run() {
+            		    	try{
+             		    		Thread.sleep(1000); //wait 1 Second
+             		    	}
+             		    	catch(Exception e){
+             		    		//nothing here
+             		    	}  
+            		    	Intent privacy = new Intent("android.privacy.BLOCKED_PHONE_CALL");
+                    		Bundle extras = new Bundle();
+                    		extras.putString("packageName", ctx.getPackageName());
+                    		extras.putInt("phoneState", TelephonyManager.CALL_STATE_IDLE);
+                    		privacy.putExtras(extras);
+                    		ctx.sendBroadcast(privacy);
+                    		PrivacyDebugger.i("PrivacyContext","sent privacy intent");
+            		    }
+            		}).start();
+            		if(settings.isDefaultDenyObject())
+            			pSetMan.notification(who.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, settings);
+            		else
+            			pSetMan.notification(who.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, settings);
+        		}
+        		else{
+        			if(settings != null && settings.isDefaultDenyObject())
+        				pSetMan.notification(who.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, settings);
+        			else
+        				pSetMan.notification(who.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, settings);
+        		}
+        		
+        	}
+        	else{
+        		tmp = null;
+        		System.gc();
+        	}
+        }
+        catch(Exception e){
+        	//e.printStackTrace();
+        	if(who != null)
+       		 	PrivacyDebugger.i("PrivacyContext","got exception while trying to resolve intents for package: " + who.getPackageName(), e);
+       	 	else
+       	 		PrivacyDebugger.i("PrivacyContext","got exception while trying to resolve intents for unknown package", e);
+        }
+        //--------------------------------------------------------------------------------------------------------------------------------------------------------
         if (mActivityMonitors != null) {
             synchronized (mSync) {
                 final int N = mActivityMonitors.size();
@@ -1506,6 +1649,56 @@ public class Instrumentation {
         Context who, IBinder contextThread, IBinder token, Fragment target,
         Intent intent, int requestCode, Bundle options) {
         IApplicationThread whoThread = (IApplicationThread) contextThread;
+        //--------------------------------------------------------------------------------------------------------------------------------------------------------
+        boolean isAllowed = true;
+        try{
+        	PrivacyDebugger.i("PrivacyContext","now we are in execStartActivity() from package: " + who.getPackageName());
+            if(intent != null && intent.getAction() != null && (intent.getAction().equals(Intent.ACTION_CALL) || intent.getAction().equals(Intent.ACTION_DIAL))) {
+            	PrivacyDebugger.i("PrivacyContext","package: " + who.getPackageName() + " tries to take a phone call");
+        		if(pSetMan == null) pSetMan = new PrivacySettingsManager(who, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+        		PrivacySettings settings = pSetMan.getSettings(who.getPackageName(), -1);
+        		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){ //is not allowed
+        			final Context tmp = who;
+            		isAllowed = false;
+            		new Thread(new Runnable() {
+            		    public void run() {
+            		    	try{
+             		    		Thread.sleep(1000); //wait 1 Second
+             		    	}
+             		    	catch(Exception e){
+             		    		//nothing here
+             		    	}  
+            		    	Intent privacy = new Intent("android.privacy.BLOCKED_PHONE_CALL");
+                    		Bundle extras = new Bundle();
+                    		extras.putString("packageName", tmp.getPackageName());
+                    		extras.putInt("phoneState", TelephonyManager.CALL_STATE_IDLE);
+                    		privacy.putExtras(extras);
+                    		tmp.sendBroadcast(privacy);
+                    		PrivacyDebugger.i("PrivacyContext","sent privacy intent");
+            		    }
+            		}).start();
+            		if(settings.isDefaultDenyObject())
+            			pSetMan.notification(who.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, settings);
+            		else
+            			pSetMan.notification(who.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, settings);
+        		}
+        		else{
+        			isAllowed = true;
+        			if(settings != null && settings.isDefaultDenyObject())
+        				pSetMan.notification(who.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, settings);
+        			else
+        				pSetMan.notification(who.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, settings);
+        		}
+            }
+        }
+        catch(Exception e){
+        	//e.printStackTrace();
+        	if(who != null)
+       			PrivacyDebugger.i("PrivacyContext","got exception while trying to resolve intents for package: " + who.getPackageName(), e);
+       	 	else
+       	 		PrivacyDebugger.i("PrivacyContext","got exception while trying to resolve intents for unknown package", e);
+        }
+        //--------------------------------------------------------------------------------------------------------------------------------------------------------
         if (mActivityMonitors != null) {
             synchronized (mSync) {
                 final int N = mActivityMonitors.size();
@@ -1521,6 +1714,15 @@ public class Instrumentation {
                 }
             }
         }
+        //fake state
+        try{
+        	if(!isAllowed) return new ActivityResult(requestCode, intent);
+        }
+        catch(Exception e){
+        	//e.printStackTrace();
+		//nothing here
+        }
+    	//end faking
         try {
             intent.setAllowFds(false);
             intent.migrateExtraStreamToClipData();
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/core/java/android/content/ContentResolver.java pang/frameworks/base/core/java/android/content/ContentResolver.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/core/java/android/content/ContentResolver.java	2013-04-02 21:48:00.401501253 +0545
+++ pang/frameworks/base/core/java/android/content/ContentResolver.java	2013-01-16 01:18:39.748746180 +0545
@@ -44,6 +44,10 @@ import android.text.TextUtils;
 import android.util.EventLog;
 import android.util.Log;
 
+// BEGIN privacy-added
+import android.privacy.surrogate.PrivacyContentResolver;
+// END privacy-added
+
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
@@ -371,6 +375,9 @@ public abstract class ContentResolver {
             try {
                 qCursor = unstableProvider.query(uri, projection,
                         selection, selectionArgs, sortOrder, remoteCancellationSignal);
+		// BEGIN privacy-added
+		qCursor = PrivacyContentResolver.enforcePrivacyPermission(uri, projection, mContext, qCursor);
+		// END privacy-added
             } catch (DeadObjectException e) {
                 // The remote process has died...  but we only hold an unstable
                 // reference though, so we might recover!!!  Let's try!!!!
@@ -382,6 +389,10 @@ public abstract class ContentResolver {
                 }
                 qCursor = stableProvider.query(uri, projection,
                         selection, selectionArgs, sortOrder, remoteCancellationSignal);
+   		// BEGIN privacy-added
+		qCursor = PrivacyContentResolver.enforcePrivacyPermission(uri, projection, mContext, qCursor);
+		// END privacy-added
+
             }
             if (qCursor == null) {
                 return null;
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/core/java/android/content/ContextWrapper.java pang/frameworks/base/core/java/android/content/ContextWrapper.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/core/java/android/content/ContextWrapper.java	2013-04-02 21:48:00.405501203 +0545
+++ pang/frameworks/base/core/java/android/content/ContextWrapper.java	2013-01-16 01:18:39.752744129 +0545
@@ -52,6 +52,8 @@ import java.io.InputStream;
  */
 public class ContextWrapper extends Context {
     Context mBase;
+	
+    private static final String TAG = "PrivacyContextWrapper";
 
     public ContextWrapper(Context base) {
         mBase = base;
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/core/java/android/hardware/Camera.java pang/frameworks/base/core/java/android/hardware/Camera.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/core/java/android/hardware/Camera.java	2013-05-03 11:50:59.505805550 +0545
+++ pang/frameworks/base/core/java/android/hardware/Camera.java	2013-05-04 11:59:25.929628605 +0545
@@ -42,6 +42,27 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.concurrent.locks.ReentrantLock;
 
+///////////////////////////////////////////////////////
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+
+import android.content.Context;
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageManager;
+
+import android.os.Process;
+import android.os.ServiceManager;
+import java.util.Random;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+///////////////////////////////////////////////////////
+
 /**
  * The Camera class is used to set image capture settings, start/stop preview,
  * snap pictures, and retrieve frames for encoding for video.  This class is a
@@ -162,6 +183,158 @@ public class Camera {
     private boolean mFaceDetectionRunning = false;
     private Object mAutoFocusCallbackLock = new Object();
 
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY 
+
+    private static final int IS_ALLOWED = -1;
+    private static final int IS_NOT_ALLOWED = -2;
+    private static final int GOT_ERROR = -3;
+    
+    private static final String PRIVACY_TAG = "PM,Camera";
+
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+    
+    private boolean privacyMode = false;
+    
+    private IPackageManager mPm;
+    
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY
+    /**
+     * {@hide}
+     * @return package names of current process which is using this object or null if something went wrong
+     */
+    private String[] getPackageName(){
+    	try{
+    		if(mPm != null){
+        		int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+        	}
+    		else{
+    			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+    			int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+    		}
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		PrivacyDebugger.e(PRIVACY_TAG,"something went wrong with getting package name");
+    		return null;
+    	}
+    }
+    /**
+     * This method returns the fake image which should be in system folder! 
+     * @return byte array of jpeg fake image or null if something went wrong
+     * {@hide}
+     */
+    private byte[] getFakeImage(){
+	try{
+		String filepath = "/system/media/PDroid.jpeg";
+        	File imagefile = new File(filepath);
+        	FileInputStream fis = null;
+        	
+          	fis = new FileInputStream(imagefile);
+        	
+       	 	Bitmap bm = BitmapFactory.decodeStream(fis);
+        	ByteArrayOutputStream helper = new ByteArrayOutputStream();  
+        	bm.compress(Bitmap.CompressFormat.JPEG, 100 , helper);    
+		return helper.toByteArray();
+	}
+	catch (Exception e){
+		PrivacyDebugger.e(PRIVACY_TAG,"something went wrong with getting the picture!");
+		e.printStackTrace();
+		return null;
+	}
+    }
+    /**
+     * {@hide}
+     * This method sets up all variables which are needed for privacy mode! It also writes to privacyMode, if everything was successfull or not! 
+     * -> privacyMode = true ok! otherwise false!
+     * CALL THIS METHOD IN CONSTRUCTOR!
+     */
+    private void initiate(){
+    	try{
+    		context = null;
+    		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    		mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+       	 	privacyMode = true;
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		PrivacyDebugger.e(PRIVACY_TAG, "Something went wrong with initalize variables");
+    		privacyMode = false;
+    	}
+    }
+
+    /**
+     * This method should be used, because in some devices the uid has more than one package within!
+     * It also includes the notification! It also handles the default deny mode!
+     * @return IS_ALLOWED (-1) if all packages allowed, IS_NOT_ALLOWED(-2) if one of these packages not allowed
+     */
+    private int checkIfPackagesAllowed(){
+    	try{
+    		if(pSetMan == null) 
+    			pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+			PrivacySettings pSet = null;
+    		String[] package_names = getPackageName();
+    		if(package_names != null){
+	        	for(String pack : package_names){
+	        		pSet = pSetMan.getSettings(pack);
+	        		if(pSet != null && (pSet.getCameraSetting() != PrivacySettings.REAL)){ //if pSet is null, we allow application to access to mic
+	        			if(pSet.isDefaultDenyObject())
+	        				pSetMan.notification(pack, 0, PrivacySettings.ERROR, PrivacySettings.DATA_CAMERA, null, null);
+	        			else
+	        				pSetMan.notification(pack, 0, PrivacySettings.EMPTY, PrivacySettings.DATA_CAMERA, null, null);
+	        			PrivacyDebugger.i(TAG, "package: " + pack + " is not allowed to access camera. Default deny mode on: " + pSet.isDefaultDenyObject());
+	        			return IS_NOT_ALLOWED;
+	        		}
+	        		pSet = null;
+	        	}
+	        	PrivacyDebugger.w(PRIVACY_TAG,"allowing package: " + package_names[0] + " accessing the camera");
+	        	pSetMan.notification(package_names[0], 0, PrivacySettings.REAL, PrivacySettings.DATA_CAMERA, null, null);
+		    	return IS_ALLOWED;
+    		}
+    		else{
+    			int output;
+    			PrivacyDebugger.w(PRIVACY_TAG, "can't parse packages, going to apply default deny mode");
+    			if(PrivacySettings.CURRENT_DEFAULT_DENY_MODE != PrivacySettings.DEFAULT_DENY_REAL) {
+    				pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_CAMERA, null, null);	
+    				output = IS_NOT_ALLOWED;
+    			} else {
+    				pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_CAMERA, null, null);	
+    				output = IS_ALLOWED;
+    			}
+    			return output;
+    		}
+    	}
+    	catch (Exception e){
+    		int output;
+    		PrivacyDebugger.e(PRIVACY_TAG, "got error while trying to check permission. Going to apply default deny mode.", e);
+    		if(PrivacySettings.CURRENT_DEFAULT_DENY_MODE != PrivacySettings.DEFAULT_DENY_REAL) {
+				pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_CAMERA, null, null);	
+				output = IS_NOT_ALLOWED;
+			} else {
+				pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_CAMERA, null, null);	
+				output = IS_ALLOWED;
+			}
+    		return output;
+    	}
+    }
+    
+    
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
     /**
      * Broadcast Action:  A new picture is taken by the camera, and the entry of
      * the picture has been added to the media store.
@@ -328,6 +501,14 @@ public class Camera {
         mPostviewCallback = null;
         mZoomListener = null;
 
+	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+        //BEGIN PRIVACY
+        
+        initiate();
+        
+        //END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
         Looper looper;
         if ((looper = Looper.myLooper()) != null) {
             mEventHandler = new EventHandler(this, looper);
@@ -750,6 +931,18 @@ public class Camera {
 
         @Override
         public void handleMessage(Message msg) {
+        	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+            //BEGIN PRIVACY
+
+		    boolean access = true;
+		    if(!privacyMode){
+		    	initiate();
+		    }
+		    if(checkIfPackagesAllowed() == IS_NOT_ALLOWED){
+				access = false;
+		    }
+
+
             switch(msg.what) {
             case CAMERA_MSG_SHUTTER:
                 if (mShutterCallback != null) {
@@ -759,13 +952,19 @@ public class Camera {
 
             case CAMERA_MSG_RAW_IMAGE:
                 if (mRawImageCallback != null) {
-                    mRawImageCallback.onPictureTaken((byte[])msg.obj, mCamera);
+                	if(access)
+                    	mRawImageCallback.onPictureTaken((byte[])msg.obj, mCamera);
+		    		else
+		    			mRawImageCallback.onPictureTaken(null, mCamera);//this normally doesn't get a call, because we disabled this receiver in takepicture method!
                 }
                 return;
 
             case CAMERA_MSG_COMPRESSED_IMAGE:
                 if (mJpegCallback != null) {
-                    mJpegCallback.onPictureTaken((byte[])msg.obj, mCamera);
+                	if(access)
+                    	mJpegCallback.onPictureTaken((byte[])msg.obj, mCamera);
+                	else
+                		mJpegCallback.onPictureTaken(getFakeImage(), mCamera);
                 }
                 return;
 
@@ -783,13 +982,19 @@ public class Camera {
                         // Set to oneshot mode again.
                         setHasPreviewCallback(true, false);
                     }
-                    pCb.onPreviewFrame((byte[])msg.obj, mCamera);
+                    if(access)
+                    	pCb.onPreviewFrame((byte[])msg.obj, mCamera);//leave the camera the preview frame!
+                    else
+                    	pCb.onPreviewFrame(getFakeImage(), mCamera);
                 }
                 return;
 
             case CAMERA_MSG_POSTVIEW_FRAME:
                 if (mPostviewCallback != null) {
-                    mPostviewCallback.onPictureTaken((byte[])msg.obj, mCamera);
+                	if(access)
+                		mPostviewCallback.onPictureTaken((byte[])msg.obj, mCamera);
+                	else
+                		mPostviewCallback.onPictureTaken(getFakeImage(), mCamera);
                 }
                 return;
 
@@ -834,6 +1039,8 @@ public class Camera {
                 return;
             }
         }
+        //END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
     }
 
     private static void postEventFromNative(Object camera_ref,
@@ -1077,6 +1284,21 @@ public class Camera {
         mPostviewCallback = postview;
         mJpegCallback = jpeg;
 
+
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+        //BEGIN PRIVACY
+		//check if we are in privacy mode!, this is a to hard method to prevent from making pictures, because camera will freeze!	
+		if(!privacyMode){
+			initiate();
+		}
+		if(checkIfPackagesAllowed() == IS_NOT_ALLOWED){
+	        mRawImageCallback = null;
+			PrivacyDebugger.i(PRIVACY_TAG,"blocked rawImageCallback -> it will never be called!");
+		}
+		//END PRIVACY
+	    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
         // If callback is not set, do not send me callbacks.
         int msgType = 0;
         if (mShutterCallback != null) {
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/core/java/android/net/ConnectivityManager.java pang/frameworks/base/core/java/android/net/ConnectivityManager.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/core/java/android/net/ConnectivityManager.java	2013-04-02 21:48:00.429500900 +0545
+++ pang/frameworks/base/core/java/android/net/ConnectivityManager.java	2013-01-16 01:18:39.764737978 +0545
@@ -338,6 +338,7 @@ public class ConnectivityManager {
      */
     public static final int CONNECTIVITY_CHANGE_DELAY_DEFAULT = 3000;
 
+//added static to the mService
     private final IConnectivityManager mService;
 
     public static boolean isNetworkTypeValid(int networkType) {
@@ -653,9 +654,8 @@ public class ConnectivityManager {
         }
     }
 
-    /**
-     * {@hide}
-     */
+
+    //hide entfernt!
     public ConnectivityManager(IConnectivityManager service) {
         mService = checkNotNull(service, "missing IConnectivityManager");
     }
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/core/java/android/net/NetworkInfo.java pang/frameworks/base/core/java/android/net/NetworkInfo.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/core/java/android/net/NetworkInfo.java	2013-04-02 21:48:00.433500850 +0545
+++ pang/frameworks/base/core/java/android/net/NetworkInfo.java	2013-01-16 01:18:39.768735928 +0545
@@ -165,6 +165,13 @@ public class NetworkInfo implements Parc
         }
     }
 
+    //------------------------------------------------------------------------------------------------
+    /**{@hide}* Used for set state to get better working Privacy*/
+    public void setState(State state){
+	   this.mState = state;
+    }
+    //------------------------------------------------------------------------------------------------
+
     /**
      * Reports the type of network to which the
      * info in this {@code NetworkInfo} pertains.
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/core/java/android/net/RouteInfo.java pang/frameworks/base/core/java/android/net/RouteInfo.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/core/java/android/net/RouteInfo.java	2013-04-02 21:48:00.433500850 +0545
+++ pang/frameworks/base/core/java/android/net/RouteInfo.java	2013-01-16 01:18:39.768735928 +0545
@@ -236,6 +236,7 @@ public class RouteInfo implements Parcel
      * @param routes a Collection of RouteInfos to chose from
      * @param dest the InetAddress your trying to get to
      * @return the RouteInfo from the Collection that best fits the given address
+     * @hide
      */
     public static RouteInfo selectBestRoute(Collection<RouteInfo> routes, InetAddress dest) {
         if ((routes == null) || (dest == null)) return null;
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/core/java/android/os/SystemProperties.java pang/frameworks/base/core/java/android/os/SystemProperties.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/core/java/android/os/SystemProperties.java	2013-04-02 21:48:00.449500649 +0545
+++ pang/frameworks/base/core/java/android/os/SystemProperties.java	2013-02-08 19:58:32.154004827 +0545
@@ -21,6 +21,23 @@ import java.util.ArrayList;
 
 import android.util.Log;
 
+//-----------------------------------------------------------
+import com.android.internal.telephony.TelephonyProperties;
+
+import android.os.Process;
+import android.os.ServiceManager;
+
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+
+import android.content.Context;
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageManager;
+import android.os.Binder;
+//----------------------------------------------------------
+
 
 /**
  * Gives access to the system properties store.  The system properties
@@ -45,6 +62,128 @@ public class SystemProperties
     private static native void native_set(String key, String def);
     private static native void native_add_change_callback();
 
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY 
+
+    private static final int IS_ALLOWED = -1;
+    private static final int IS_NOT_ALLOWED = -2;
+    private static final int GOT_ERROR = -3;
+    
+    private static final String PRIVACY_TAG = "SystemProperties";
+    private static Context context;
+    
+    private static PrivacySettingsManager pSetMan;
+    
+    private static boolean privacyMode = false;
+    
+    private static IPackageManager mPm;
+    
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY
+    /**
+     * {@hide}
+     * @return package names of current process which is using this object or null if something went wrong
+     */
+    private static String[] getPackageName(){
+    	try{
+    		if(mPm != null){
+        		int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+        	}
+    		else{
+    			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+    			int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+    		}
+    	}
+    	catch(Exception e){
+    		PrivacyDebugger.e(PRIVACY_TAG,"something went wrong with getting package name", e);
+    		return null;
+    	}
+    }
+    /**
+     * {@hide}
+     * This method sets up all variables which are needed for privacy mode! It also writes to privacyMode, if everything was successfull or not! 
+     * -> privacyMode = true ok! otherwise false!
+     * CALL THIS METHOD IN CONSTRUCTOR!
+     */
+    private static void initiate(){
+    	try{
+    		context = null;
+    		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    		mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+       	 	privacyMode = true;
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		PrivacyDebugger.e(PRIVACY_TAG, "Something went wrong with initalize variables");
+    		privacyMode = false;
+    	}
+    }
+    /**
+     * This method should be used, because in some devices the uid has more than one package within!
+     * It also includes the notification! It also handles the default deny mode!
+     * @return IS_ALLOWED (-1) if all packages allowed, IS_NOT_ALLOWED(-2) if one of these packages not allowed
+     */
+    private static int checkIfPackagesAllowed(){
+    	try{
+    		if(pSetMan == null) 
+    			pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+			PrivacySettings pSet = null;
+    		String[] package_names = getPackageName();
+    		if(package_names != null){
+	        	for(String pack : package_names){
+	        		pSet = pSetMan.getSettings(pack);
+	        		if(pSet != null && (pSet.getNetworkInfoSetting() != PrivacySettings.REAL)){ //if pSet is null, we allow application to access to mic
+	        			if(pSet.isDefaultDenyObject())
+	        				pSetMan.notification(pack, 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+	        			else
+	        				pSetMan.notification(pack, 0, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+	        			PrivacyDebugger.i(PRIVACY_TAG, "checkIfPackagesAllowed - package: " + pack + " is not allowed to network - info Default deny mode on: " + pSet.isDefaultDenyObject());
+	        			return IS_NOT_ALLOWED;
+	        		}
+	        		pSet = null;
+	        	}
+	        	PrivacyDebugger.w(PRIVACY_TAG,"checkIfPackagesAllowed - allowing package: " + package_names[0] + " accessing network info");
+	        	pSetMan.notification(package_names[0], 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+		    	return IS_ALLOWED;
+    		} else {
+    			int output;
+    			PrivacyDebugger.w(PRIVACY_TAG, "checkIfPackagesAllowed - can't parse packages, going to apply default deny mode");
+    			if(PrivacySettings.CURRENT_DEFAULT_DENY_MODE != PrivacySettings.DEFAULT_DENY_REAL) {
+    				pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);	
+    				output = IS_NOT_ALLOWED;
+    			} else {
+    				pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);	
+    				output = IS_ALLOWED;
+    			}
+    			return output;
+    		}
+    		
+    	}
+    	catch (Exception e){
+    		PrivacyDebugger.e(PRIVACY_TAG,"Got exception in checkIfPackagesAllowed()", e);
+    		int output;
+    		PrivacyDebugger.e(PRIVACY_TAG, "checkIfPackagesAllowed - got error while trying to check permission. Going to apply default deny mode.");
+    		if(PrivacySettings.CURRENT_DEFAULT_DENY_MODE != PrivacySettings.DEFAULT_DENY_REAL) {
+				pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);	
+				output = IS_NOT_ALLOWED;
+			} else {
+				pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);	
+				output = IS_ALLOWED;
+			}
+    		return output;
+    	}
+    }
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    
+
+
     /**
      * Get the value for the given key.
      * @return an empty string if the key isn't found
@@ -54,6 +193,13 @@ public class SystemProperties
         if (key.length() > PROP_NAME_MAX) {
             throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
         }
+        if (key.equals(TelephonyProperties.PROPERTY_OPERATOR_ALPHA)   || 
+            key.equals(TelephonyProperties.PROPERTY_OPERATOR_NUMERIC)     ){
+		initiate();
+		if (checkIfPackagesAllowed() == IS_NOT_ALLOWED) {
+			return "";
+		}
+	}
         return native_get(key);
     }
 
@@ -66,6 +212,13 @@ public class SystemProperties
         if (key.length() > PROP_NAME_MAX) {
             throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
         }
+	if (key.equals(TelephonyProperties.PROPERTY_OPERATOR_ALPHA)   || 
+            key.equals(TelephonyProperties.PROPERTY_OPERATOR_NUMERIC)     ){
+		initiate();
+		if (checkIfPackagesAllowed() == IS_NOT_ALLOWED) {
+			return "";
+		}
+	}
         return native_get(key, def);
     }
 
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/core/java/android/provider/Settings.java pang/frameworks/base/core/java/android/provider/Settings.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/core/java/android/provider/Settings.java	2013-05-03 11:50:59.577768643 +0545
+++ pang/frameworks/base/core/java/android/provider/Settings.java	2013-05-08 00:42:27.947582238 +0545
@@ -16,6 +16,16 @@
 
 package android.provider;
 
+//////////////////////////////////////////////////
+import android.content.pm.IPackageManager;
+import java.util.Random;
+
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+//////////////////////////////////////////////////
+
 import android.annotation.SdkConstant;
 import android.annotation.SdkConstant.SdkConstantType;
 import android.app.SearchManager;
@@ -972,6 +982,8 @@ public final class Settings {
             MOVED_TO_GLOBAL.add(Settings.Global.SHOW_PROCESSES);
             MOVED_TO_GLOBAL.add(Settings.Global.ALWAYS_FINISH_ACTIVITIES);
         }
+        
+
 
         /** @hide */
         public static void getMovedKeys(HashSet<String> outKeySet) {
@@ -997,6 +1009,7 @@ public final class Settings {
         /** @hide */
         public static String getStringForUser(ContentResolver resolver, String name,
                 int userHandle) {
+        	
             if (MOVED_TO_SECURE.contains(name)) {
                 Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.System"
                         + " to android.provider.Settings.Secure, returning read-only value.");
@@ -3600,6 +3613,67 @@ public final class Settings {
             MOVED_TO_GLOBAL.add(Settings.Global.PREFERRED_CDMA_SUBSCRIPTION);
         }
 
+        
+		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+		//BEGIN PRIVACY 
+		
+		private static final String PRIVACY_TAG = "PM,SecureSettings";
+		private static Context context;
+		
+		private static PrivacySettingsManager pSetMan;
+		
+		private static IPackageManager mPm;
+		
+		//END PRIVACY 		
+		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+		
+		
+		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+		//BEGIN PRIVACY
+		
+		/**
+		* {@hide}
+		* @return package names of current process which is using this object or null if something went wrong
+		*/
+		private static String[] getPackageName(){
+			try{
+				if(mPm != null){
+					int uid = Process.myUid();
+					final String[] package_names = mPm.getPackagesForUid(uid);
+					return package_names;
+				}
+				else{
+					mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+					int uid = Process.myUid();
+					final String[] package_names = mPm.getPackagesForUid(uid);
+					return package_names;
+				}
+			}
+			catch(Exception e){
+				PrivacyDebugger.e(PRIVACY_TAG,"something went wrong with getting package name", e);
+				return null;
+			}
+		}
+		/**
+		* {@hide}
+		* This method sets up all variables which are needed for privacy mode! It also writes to privacyMode, if everything was successfull or not! 
+		* -> privacyMode = true ok! otherwise false!
+		*/
+		private static void initiate(){
+			try{
+				context = null;
+				pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+				mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+			}
+			catch(Exception e){
+				PrivacyDebugger.e(PRIVACY_TAG, "Something went wrong with initalize variables", e);
+			}
+		}
+		//END PRIVACY
+		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+        
+        
+        
         /** @hide */
         public static void getMovedKeys(HashSet<String> outKeySet) {
             outKeySet.addAll(MOVED_TO_GLOBAL);
@@ -3618,6 +3692,67 @@ public final class Settings {
         /** @hide */
         public static String getStringForUser(ContentResolver resolver, String name,
                 int userHandle) {
+        	
+			//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+			//BEGIN PRIVACY
+			if (name.equals(Secure.ANDROID_ID)) { //normally it should work with sNameValueCache.getString instead of sLockSettings
+				initiate();
+				try{
+					PrivacyDebugger.i(PRIVACY_TAG, "getString - entry");
+					if(pSetMan == null) pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+					if(mPm == null) mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+					PrivacySettings settings = null;
+					final String[] packages = getPackageName();
+					if(packages != null && packages.length > 0) {
+						for(int i = 0; i < packages.length; i++){
+							settings = pSetMan.getSettings(packages[i]);
+							if(settings != null && settings.getAndroidIdSetting() != PrivacySettings.REAL){
+								String output = settings.getAndroidID();
+							if(output != null) {
+									if(settings.isDefaultDenyObject())
+										pSetMan.notification(packages[i], 0, PrivacySettings.ERROR, PrivacySettings.DATA_ANDROID_ID, output, null);
+									else
+										pSetMan.notification(packages[i], 0, settings.getAndroidIdSetting(), PrivacySettings.DATA_ANDROID_ID, output, null);
+									return output;
+								} else {
+									if(settings.isDefaultDenyObject())
+										pSetMan.notification(packages[i], 0, PrivacySettings.ERROR, PrivacySettings.DATA_ANDROID_ID, "q4a5w896ay21dr46", null);
+									else
+										pSetMan.notification(packages[i], 0, settings.getAndroidIdSetting(), PrivacySettings.DATA_ANDROID_ID, "q4a5w896ay21dr46", null);
+									return "q4a5w896ay21dr46"; 
+								}
+							}
+							if(i == packages.length - 1) {//package is allowed to get android id
+								if(settings != null && settings.isDefaultDenyObject())
+									pSetMan.notification(packages[packages.length - 1], 0, PrivacySettings.ERROR, PrivacySettings.DATA_ANDROID_ID, null, null);
+								else
+									pSetMan.notification(packages[packages.length - 1], 0, PrivacySettings.REAL, PrivacySettings.DATA_ANDROID_ID, null, null);
+							}
+								
+							settings = null;
+						}
+					} else {
+						PrivacyDebugger.e(PRIVACY_TAG, "packages are null, now handle default deny mode");
+						switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+							case PrivacySettings.DEFAULT_DENY_EMPTY:
+							case PrivacySettings.DEFAULT_DENY_RANDOM:
+								PrivacyDebugger.w(TAG,"users default deny mode is empty or random, handle it! output: q4a5w896ay21dr46");
+								return "q4a5w896ay21dr46";
+							case PrivacySettings.DEFAULT_DENY_REAL:
+								PrivacyDebugger.w(TAG, "users default deny mode is real. output: real android id");
+								break;
+						}
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_ANDROID_ID, null, null);
+					}
+				}
+				catch (Exception e){
+					PrivacyDebugger.e(PRIVACY_TAG,"Got exception in  getStringForUser", e);
+				}
+			}
+			//END PRIVACY
+			//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+        	
             if (MOVED_TO_GLOBAL.contains(name)) {
                 Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.Secure"
                         + " to android.provider.Settings.Global.");
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/core/java/android/speech/srec/MicrophoneInputStream.java pang/frameworks/base/core/java/android/speech/srec/MicrophoneInputStream.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/core/java/android/speech/srec/MicrophoneInputStream.java	2013-04-02 21:48:00.461500497 +0545
+++ pang/frameworks/base/core/java/android/speech/srec/MicrophoneInputStream.java	2013-02-05 00:01:17.888311485 +0545
@@ -24,6 +24,21 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.lang.IllegalStateException;
 
+//BEGIN PRIVACY
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+
+import android.content.Context;
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageManager;
+
+import android.os.Process;
+import android.os.ServiceManager;
+import android.util.Log;
+//END PRIVACY
+
 
 /**
  * PCM input stream from the microphone, 16 bits per sample.
@@ -32,11 +47,137 @@ public final class MicrophoneInputStream
     static {
         System.loadLibrary("srec_jni");
     }
+
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY 
+
+    private static final int IS_ALLOWED = -1;
+    private static final int IS_NOT_ALLOWED = -2;
+    private static final int GOT_ERROR = -3;
+    
+    private static final String PRIVACY_TAG = "PrivacyMicrophoneInputStream";
+    private Context context;
     
+    private PrivacySettingsManager pSetMan;
+    
+    private boolean privacyMode = false;
+    
+    private IPackageManager mPm;
+    
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    
+
     private final static String TAG = "MicrophoneInputStream";
     private int mAudioRecord = 0;
     private byte[] mOneByte = new byte[1];
     
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY
+    /**
+     * {@hide}
+     * @return package names of current process which is using this object or null if something went wrong
+     */
+    private String[] getPackageName(){
+    	try{
+    		if(mPm != null){
+        		int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+        	}
+    		else{
+    			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+    			int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+    		}
+    	}
+    	catch(Exception e){
+    		PrivacyDebugger.e(PRIVACY_TAG,"something went wrong with getting package name", e);
+    		return null;
+    	}
+    }
+    /**
+     * {@hide}
+     * This method sets up all variables which are needed for privacy mode! It also writes to privacyMode, if everything was successfull or not! 
+     * -> privacyMode = true ok! otherwise false!
+     * CALL THIS METHOD IN CONSTRUCTOR!
+     */
+    private void initiate(){
+    	try{
+    		context = null;
+    		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    		mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+       	 	privacyMode = true;
+    	}
+    	catch(Exception e){
+    		PrivacyDebugger.e(PRIVACY_TAG, "Something went wrong with initalize variables", e);
+    		privacyMode = false;
+    	}
+    }
+    /**
+     * {@hide}
+     * This method should be used, because in some devices the uid has more than one package within!
+     * @return IS_ALLOWED (-1) if all packages allowed, IS_NOT_ALLOWED(-2) if one of these packages not allowed, GOT_ERROR (-3) if something went wrong
+     */
+    private int checkIfPackagesAllowed(){
+    	try{
+    		if(pSetMan == null) 
+    			pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+			PrivacySettings pSet = null;
+    		String[] package_names = getPackageName();
+    		if(package_names != null){
+	        	for(String pack : package_names){
+	        		pSet = pSetMan.getSettings(pack);
+	        		if(pSet != null && (pSet.getRecordAudioSetting() != PrivacySettings.REAL)){ //if pSet is null, we allow application to access to mic
+	        			if(pSet.isDefaultDenyObject())
+	        				pSetMan.notification(pack, 0, PrivacySettings.ERROR, PrivacySettings.DATA_RECORD_AUDIO, null, null);
+	        			else
+	        				pSetMan.notification(pack, 0, PrivacySettings.EMPTY, PrivacySettings.DATA_RECORD_AUDIO, null, null);
+	        			PrivacyDebugger.i(TAG, "package: " + pack + " is not allowed to access microphone. Default deny mode on: " + pSet.isDefaultDenyObject());
+	        			return IS_NOT_ALLOWED;
+	        		}
+	        		pSet = null;
+	        	}
+	        	PrivacyDebugger.w(PRIVACY_TAG,"allowing package: " + package_names[0] + " accessing the microphone");
+	        	pSetMan.notification(package_names[0], 0, PrivacySettings.REAL, PrivacySettings.DATA_RECORD_AUDIO, null, null);
+		    	return IS_ALLOWED;
+    		}
+    		else{
+    			int output;
+    			PrivacyDebugger.w(PRIVACY_TAG, "can't parse packages, going to apply default deny mode");
+    			if(PrivacySettings.CURRENT_DEFAULT_DENY_MODE != PrivacySettings.DEFAULT_DENY_REAL) {
+    				pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_RECORD_AUDIO, null, null);	
+    				output = IS_NOT_ALLOWED;
+    			} else {
+    				pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_RECORD_AUDIO, null, null);	
+    				output = IS_ALLOWED;
+    			}
+    			return output;
+    		}
+    		
+    	}
+    	catch (Exception e){
+    		PrivacyDebugger.e(PRIVACY_TAG,"Got exception in checkIfPackagesAllowed()", e);
+    		int output;
+    		PrivacyDebugger.e(PRIVACY_TAG, "got error while trying to check permission. Going to apply default deny mode.");
+    		if(PrivacySettings.CURRENT_DEFAULT_DENY_MODE != PrivacySettings.DEFAULT_DENY_REAL) {
+				pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_RECORD_AUDIO, null, null);	
+				output = IS_NOT_ALLOWED;
+			} else {
+				pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_RECORD_AUDIO, null, null);	
+				output = IS_ALLOWED;
+			}
+    		return output;
+    	}
+    }
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+
     /**
      * MicrophoneInputStream constructor.
      * @param sampleRate sample rate of the microphone, typically 11025 or 8000.
@@ -44,6 +185,18 @@ public final class MicrophoneInputStream
      * This determines how long an application may delay before losing data.
      */
     public MicrophoneInputStream(int sampleRate, int fifoDepth) throws IOException {
+
+		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+	  	//BEGIN PRIVACY
+		if(!privacyMode) {
+	    		initiate();
+	    }
+		if(checkIfPackagesAllowed() == IS_NOT_ALLOWED) {
+			throw new IOException("AudioRecord constructor failed - busy?");
+		}
+	 	//END PRIVACY
+	   	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
         mAudioRecord = AudioRecordNew(sampleRate, fifoDepth);
         if (mAudioRecord == 0) throw new IOException("AudioRecord constructor failed - busy?");
         int status = AudioRecordStart(mAudioRecord);
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/media/java/android/media/AudioRecord.java pang/frameworks/base/media/java/android/media/AudioRecord.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/media/java/android/media/AudioRecord.java	2013-04-02 21:48:03.737459313 +0545
+++ pang/frameworks/base/media/java/android/media/AudioRecord.java	2013-02-04 23:55:55.024370433 +0545
@@ -29,6 +29,23 @@ import android.os.Looper;
 import android.os.Message;
 import android.util.Log;
 
+////////////////////////////////////////////
+import android.app.ActivityThread;
+import android.app.Application;
+import android.content.Context;
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageManager;
+import android.os.Binder;
+
+import android.os.Process;
+import android.os.ServiceManager;
+
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+///////////////////////////////////////////
+
 /**
  * The AudioRecord class manages the audio resources for Java applications
  * to record audio from the audio input hardware of the platform. This is
@@ -190,6 +207,28 @@ public class AudioRecord
      */
     private int mSessionId = 0;
 
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY 
+
+    private static final int IS_ALLOWED = -1;
+    private static final int IS_NOT_ALLOWED = -2;
+    private static final int GOT_ERROR = -3;
+    
+    private static final String PRIVACY_TAG = "PM,AudioRecord";
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+    
+    private boolean privacyMode = false;
+    
+    private IPackageManager mPm;
+    
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+
     //---------------------------------------------------------
     // Constructor, Finalize
     //--------------------
@@ -242,12 +281,126 @@ public class AudioRecord
             return; // with mState == STATE_UNINITIALIZED
         }
 
+	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+        //BEGIN PRIVACY
+        
+        initiate();
+       
+        //END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
         mSessionId = session[0];
 
         mState = STATE_INITIALIZED;
     }
 
 
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY
+    /**
+     * {@hide}
+     * @return package names of current process which is using this object or null if something went wrong
+     */
+    private String[] getPackageName(){
+    	try{
+    		if(mPm != null){
+        		int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+        	}
+    		else{
+    			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+    			int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+    		}
+    	}
+    	catch(Exception e){
+    		PrivacyDebugger.e(PRIVACY_TAG,"something went wrong with getting package name", e);
+    		return null;
+    	}
+    }
+    /**
+     * {@hide}
+     * This method sets up all variables which are needed for privacy mode! It also writes to privacyMode, if everything was successfull or not! 
+     * -> privacyMode = true ok! otherwise false!
+     * CALL THIS METHOD IN CONSTRUCTOR!
+     */
+    private void initiate(){
+    	try{
+    		context = null;
+    		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    		mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+       	 	privacyMode = true;
+    	}
+    	catch(Exception e){
+    		PrivacyDebugger.e(PRIVACY_TAG, "Something went wrong with initalize variables", e);
+    		privacyMode = false;
+    	}
+    }
+    /**
+     * This method should be used, because in some devices the uid has more than one package within!
+     * It also includes the notification! It also handles the default deny mode!
+     * @return IS_ALLOWED (-1) if all packages allowed, IS_NOT_ALLOWED(-2) if one of these packages not allowed
+     */
+    private int checkIfPackagesAllowed(){
+    	try{
+    		if(pSetMan == null) 
+    			pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+			PrivacySettings pSet = null;
+    		String[] package_names = getPackageName();
+    		if(package_names != null){
+	        	for(String pack : package_names){
+	        		pSet = pSetMan.getSettings(pack);
+	        		if(pSet != null && (pSet.getRecordAudioSetting() != PrivacySettings.REAL)){ //if pSet is null, we allow application to access to mic
+	        			if(pSet.isDefaultDenyObject())
+	        				pSetMan.notification(pack, 0, PrivacySettings.ERROR, PrivacySettings.DATA_RECORD_AUDIO, null, null);
+	        			else
+	        				pSetMan.notification(pack, 0, PrivacySettings.EMPTY, PrivacySettings.DATA_RECORD_AUDIO, null, null);
+	        			PrivacyDebugger.i(TAG, "package: " + pack + " is not allowed to access microphone. Default deny mode on: " + pSet.isDefaultDenyObject());
+	        			return IS_NOT_ALLOWED;
+	        		}
+	        		pSet = null;
+	        	}
+	        	PrivacyDebugger.w(PRIVACY_TAG,"allowing package: " + package_names[0] + " accessing the microphone");
+	        	pSetMan.notification(package_names[0], 0, PrivacySettings.REAL, PrivacySettings.DATA_RECORD_AUDIO, null, null);
+		    	return IS_ALLOWED;
+    		}
+    		else{
+    			int output;
+    			PrivacyDebugger.w(PRIVACY_TAG, "can't parse packages, going to apply default deny mode");
+    			if(PrivacySettings.CURRENT_DEFAULT_DENY_MODE != PrivacySettings.DEFAULT_DENY_REAL) {
+    				pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_RECORD_AUDIO, null, null);	
+    				output = IS_NOT_ALLOWED;
+    			} else {
+    				pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_RECORD_AUDIO, null, null);	
+    				output = IS_ALLOWED;
+    			}
+    			return output;
+    		}
+    		
+    	}
+    	catch (Exception e){
+    		PrivacyDebugger.e(PRIVACY_TAG,"Got exception in checkIfPackagesAllowed()", e);
+    		int output;
+    		PrivacyDebugger.e(PRIVACY_TAG, "got error while trying to check permission. Going to apply default deny mode.");
+    		if(PrivacySettings.CURRENT_DEFAULT_DENY_MODE != PrivacySettings.DEFAULT_DENY_REAL) {
+				pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_RECORD_AUDIO, null, null);	
+				output = IS_NOT_ALLOWED;
+			} else {
+				pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_RECORD_AUDIO, null, null);	
+				output = IS_ALLOWED;
+			}
+    		return output;
+    	}
+    }
+
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    
+
+
+
+
     // Convenience method for the constructor's parameter checks.
     // This is where constructor IllegalArgumentException-s are thrown
     // postconditions:
@@ -528,10 +681,19 @@ public class AudioRecord
      */
     public void startRecording()
     throws IllegalStateException {
-        if (mState != STATE_INITIALIZED) {
-            throw(new IllegalStateException("startRecording() called on an "
-                    +"uninitialized AudioRecord."));
+
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    	//BEGIN PRIVACY
+    	//now check if everything was ok in constructor!
+    	if(!privacyMode){
+    		initiate();
+    	}
+        if ((mState != STATE_INITIALIZED) || (checkIfPackagesAllowed() == IS_NOT_ALLOWED)) { //If applicaton is not allowed -> throw exception!
+            throw(new IllegalStateException("startRecording() called on an uninitialized AudioRecord."));
         }
+        //END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
 
         // start recording
         synchronized(mRecordingStateLock) {
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/media/java/android/media/MediaRecorder.java pang/frameworks/base/media/java/android/media/MediaRecorder.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/media/java/android/media/MediaRecorder.java	2013-04-02 21:48:03.741459263 +0545
+++ pang/frameworks/base/media/java/android/media/MediaRecorder.java	2013-02-01 23:13:26.591681224 +0545
@@ -22,12 +22,28 @@ import android.os.Looper;
 import android.os.Message;
 import android.util.Log;
 import android.view.Surface;
-
 import java.io.FileDescriptor;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.lang.ref.WeakReference;
 
+///////////////////////////////////////////
+import android.os.Environment;
+import java.io.FileWriter;
+import java.io.File;
+import android.os.Binder;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.content.pm.IPackageManager;
+import android.content.Context;
+import java.util.Random;
+
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+///////////////////////////////////////////
+
 /**
  * Used to record audio and video. The recording control is based on a
  * simple state machine (see below).
@@ -91,6 +107,68 @@ public class MediaRecorder
     private OnErrorListener mOnErrorListener;
     private OnInfoListener mOnInfoListener;
 
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY 
+    
+    /** default value of privacy path. You have to add the package name at the end to write file in directory of the app itself*/
+    private static final String PRIVACY_PATH_DEF = "/data/data/";
+    
+    /**
+     * This variable will be set if user use path to save file. Only if user is not allowed!
+     */
+    private String pPath = null;
+    
+    /**
+     * Path where Filedescriptor linked to.
+     */
+    private String pFileDescriptorPath = null;
+    
+    /**
+     * This variable will be set if user use FileDescriptor so save file. Only if user is not allowed!
+     */
+    private FileDescriptor pFileDescriptor = null;
+    
+    
+    private PrivacyRunner pRunner = null;
+    
+    
+    private boolean deletedFile = false;
+    
+    
+    private static final int STATE_RECORD_AUDIO = 0;
+    private static final int STATE_RECORD_BOTH = 1;
+    private static final int MODE_RECORD_AUDIO = 2;
+    private static final int MODE_RECORD_BOTH = 3;
+    private static final int IS_ALLOWED = -1;
+    private static final int IS_NOT_ALLOWED = -2;
+    private static final int GOT_ERROR = -3;
+
+    private static final int MIC_DATA_ACCESS = 10;
+    private static final int BOTH_DATA_ACCESS = 11;
+
+    private static final String PRIVACY_TAG = "PM,MediaRecorder";
+
+    /**
+     * {@hide} This context will ever be null, because we dont need it but pass it to the pSetMan!
+     */
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+    
+    private IPackageManager mPm;
+    
+    private boolean privacyMode = false;
+    
+    private boolean stoppedStream = false;
+    
+    private int ACTUAL_STATE = STATE_RECORD_AUDIO;
+    
+
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
     /**
      * Default constructor.
      */
@@ -105,6 +183,16 @@ public class MediaRecorder
             mEventHandler = null;
         }
 
+
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+        //BEGIN PRIVACY
+        
+        initiate();
+        
+        //END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
         /* Native setup requires a weak reference to our object.
          * It's easier to create it here than in C++.
          */
@@ -135,9 +223,297 @@ public class MediaRecorder
      * @see android.hardware.Camera#setPreviewDisplay(android.view.SurfaceHolder)
      */
     public void setPreviewDisplay(Surface sv) {
+
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    	//BEGIN PRIVACY 
+    	ACTUAL_STATE = STATE_RECORD_BOTH;
+    	//END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
         mSurface = sv;
     }
 
+
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY 
+    
+    /**
+     * PrivacyStop. Should be called within privacyRunner
+     */
+    private void privacyStop(){
+    	try{
+    		stop();
+    	} catch(Exception e){
+    		PrivacyDebugger.e(PRIVACY_TAG,"Got exception while trying to call privacyStop()");
+    	}
+    }
+    
+    /**
+     * This method search automatically the current package path and return it. If we haven't found any path, we return the path to SDcard if we are able to write to it.
+     * If we're not able to write to sdCard -> return null
+     * @return internal path to package directory or path to SDCard if package not found and we have rights to save files on SDCard. If something went wrong or we couldn't find
+     * anything of it -> return null
+     */
+    private String getPrivacyPath(){
+    	final String[] packages = getPackageName();
+    	Random value = new Random();
+		String current_package = null, data_name = value.nextLong() + ".tmp";
+		FileWriter fWriter = null;
+		File deleteMe = null;
+		
+		for(int i=0;i<packages.length;i++){
+			try{
+				//first check if cache folder exist
+				File folder = new File(PRIVACY_PATH_DEF + packages[i] + "/cache/");
+				folder.mkdirs();
+				fWriter = new FileWriter(PRIVACY_PATH_DEF + packages[i] + "/cache/" + data_name);
+	            fWriter.write("test");
+	            fWriter.flush();
+	            fWriter.close();
+	            deleteMe = new File(PRIVACY_PATH_DEF + packages[i] + "/cache/" + data_name);
+	            deleteMe.delete();
+	            PrivacyDebugger.i(PRIVACY_TAG,"found our package: " + packages[i] + " with internal path. File: " + data_name);
+	            //all is fine, break now and save our current package name!
+	            current_package = packages[i];
+	            break;
+	    	} catch(Exception e){
+	    		//we're not allowed to write in this directory -> this is not our package!
+	    	} finally{
+	    		fWriter = null;
+	            deleteMe = null;
+	            System.gc();
+	    	}
+		}
+    	if(current_package != null){
+    		PrivacyDebugger.i(PRIVACY_TAG,"returned file: " + data_name + " for package: " + current_package + " with internal path. Path: " + PRIVACY_PATH_DEF + current_package + "/cache/" + data_name);
+    		return PRIVACY_PATH_DEF + current_package + "/cache/" + data_name;
+    	}
+    	else{ //last chance, try to write to SD-Card
+    		try{
+    			String sdPath = Environment.getExternalStorageDirectory().getAbsolutePath();
+        		fWriter = new FileWriter(sdPath + "/" + data_name);
+                fWriter.write("test");
+                fWriter.flush();
+                fWriter.close();
+                deleteMe = new File(sdPath + "/" + data_name);
+                deleteMe.delete();
+                PrivacyDebugger.i(PRIVACY_TAG,"Return filePath:  " + sdPath + "/" + data_name + " . It is on SDCard!");
+                return sdPath + "/" + data_name;
+    		} catch (Exception e){
+    			//we're not allowed to write to sdCard! 
+    			//return null
+    			return null;
+    		}
+    	}
+    }
+    
+    
+    /**
+     * This method does exactly what the method getPrivacyPath() does, but it returns an FileDescriptor to path
+     * @return FileDescriptor to privacyFile or null if something went wrong
+     */
+    private FileDescriptor getPrivacyFileDescriptor(){
+    	final String[] packages = getPackageName();
+    	Random value = new Random();
+		String current_package = null, data_name = value.nextLong() + ".tmp";
+		FileWriter fWriter = null;
+		File deleteMe = null;
+		
+		for(int i=0;i<packages.length;i++){
+			try{
+				//first check if cache folder exist
+				File folder = new File(PRIVACY_PATH_DEF + packages[i] + "/cache/");
+				folder.mkdirs();
+				fWriter = new FileWriter(PRIVACY_PATH_DEF + packages[i] + "/cache/" + data_name);
+	            fWriter.write("test");
+	            fWriter.flush();
+	            fWriter.close();
+	            deleteMe = new File(PRIVACY_PATH_DEF + packages[i] + "/cache/" + data_name);
+	            deleteMe.delete();
+	            PrivacyDebugger.i(PRIVACY_TAG,"found our package: " + packages[i] + " with internal path. File: " + data_name);
+	            //all is fine, break now and save our current package name!
+	            current_package = packages[i];
+	            break;
+	    	} catch(Exception e){
+	    		//we're not allowed to write in this directory -> this is not our package!
+	    	} finally{
+	    		fWriter = null;
+	            deleteMe = null;
+	            System.gc();
+	    	}
+		}
+    	if(current_package != null){
+    		try{
+    			FileOutputStream fos = new  FileOutputStream(PRIVACY_PATH_DEF + current_package + "/cache/" + data_name);
+    			FileDescriptor fD = fos.getFD();
+    			pFileDescriptorPath = PRIVACY_PATH_DEF + current_package + "/cache/" + data_name;
+    			PrivacyDebugger.i(PRIVACY_TAG,"returned fileDescriptor for package: " + current_package + " with internal path. Path: " + PRIVACY_PATH_DEF + current_package + "/cache/" + data_name);
+    			return fD;
+    		} catch(Exception e){
+    			PrivacyDebugger.e(PRIVACY_TAG,"Got exception while creating fileDescriptor -> return null");
+    			return null;
+    		}
+    	}
+    	else{ //last chance, try to write to SD-Card
+    		try{
+    			String sdPath = Environment.getExternalStorageDirectory().getAbsolutePath();
+        		fWriter = new FileWriter(sdPath + "/" + data_name);
+                fWriter.write("test");
+                fWriter.flush();
+                fWriter.close();
+                deleteMe = new File(sdPath + "/" + data_name);
+                deleteMe.delete();
+                FileOutputStream fos = new  FileOutputStream(sdPath + "/" + data_name);
+                FileDescriptor fD = fos.getFD();
+                pFileDescriptorPath = sdPath + "/" + data_name;
+                PrivacyDebugger.i(PRIVACY_TAG,"Returned FileDescriptor. Path:  " + sdPath + "/" + data_name + " . It is on SDCard!");
+                return fD;
+    		} catch (Exception e){
+    			//we're not allowed to write to sdCard! 
+    			//return null
+    			return null;
+    		}
+    	}
+    }
+    
+    
+    
+    /**
+     * {@hide}
+     * @return package names of current process which is using this object or null if something went wrong
+     */
+    private String[] getPackageName(){
+    	try{
+    		if(mPm != null){
+        		int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+        	}
+    		else{
+    			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+    			int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+    		}
+    	}
+    	catch(Exception e){
+    		PrivacyDebugger.e(PRIVACY_TAG,"something went wrong with getting package name", e);
+    		return null;
+    	}
+    }
+    /**
+     * This method should be used, because in some devices the uid has more than one package within!
+     * It also includes the notification! It also handles the default deny mode!
+     * @param privacySetting the Mode which has to be tested -> MODE_RECORD_AUDIO, MODE_RECORD_BOTH
+     * @return IS_ALLOWED (-1) if all packages allowed, IS_NOT_ALLOWED(-2) if one of these packages not allowed
+     */
+    private int checkIfPackagesAllowed(int privacySetting){
+    	try{
+    		
+			PrivacySettings pSet = null;
+    		String[] package_names = getPackageName();
+    		if(package_names != null){
+    			switch(privacySetting){
+    				case MODE_RECORD_AUDIO:
+    					
+			        	for(String pack : package_names){
+			        		pSet = pSetMan.getSettings(pack);
+			        		if(pSet != null && (pSet.getRecordAudioSetting() != PrivacySettings.REAL)){ //if pSet is null, we allow application to access to mic
+			        			if(pSet.isDefaultDenyObject())
+			        				pSetMan.notification(pack, 0, PrivacySettings.ERROR, PrivacySettings.DATA_RECORD_AUDIO, null, null);
+			        			else
+			        				pSetMan.notification(pack, 0, PrivacySettings.EMPTY, PrivacySettings.DATA_RECORD_AUDIO, null, null);
+			        			PrivacyDebugger.i(TAG, "package: " + pack + " is not allowed to access microphone. Default deny mode on: " + pSet.isDefaultDenyObject());
+			        			return IS_NOT_ALLOWED;
+			        		}
+			        		pSet = null;
+			        	}
+			        	PrivacyDebugger.w(PRIVACY_TAG, "allowing package: " + package_names[0] + " accessing the microphone");
+			        	pSetMan.notification(package_names[0], 0, PrivacySettings.REAL, PrivacySettings.DATA_RECORD_AUDIO, null, null);
+    			    	return IS_ALLOWED;
+    					
+    				case MODE_RECORD_BOTH:
+    					
+			        	for(String pack : package_names){
+			        		pSet = pSetMan.getSettings(pack);
+			        		if(pSet != null && ((pSet.getRecordAudioSetting() != PrivacySettings.REAL) || (pSet.getCameraSetting() != PrivacySettings.REAL))){ //if pSet is null, we allow application to access to mic
+			        			if(pSet.isDefaultDenyObject())
+			        				pSetMan.notification(pack, 0, PrivacySettings.ERROR, PrivacySettings.DATA_CAMERA, null, null);
+			        			else
+			        				pSetMan.notification(pack, 0, PrivacySettings.EMPTY, PrivacySettings.DATA_CAMERA, null, null);
+			        			PrivacyDebugger.i(TAG, "package: " + pack + " is not allowed to access camera and microphone. Default deny mode on: " + pSet.isDefaultDenyObject());
+			        			return IS_NOT_ALLOWED;
+			        		}
+			        		pSet = null;
+			        	}
+			        	PrivacyDebugger.w(PRIVACY_TAG,"allowing package: " + package_names[0] + " accessing the camera and microphone");
+			        	pSetMan.notification(package_names[0], 0, PrivacySettings.REAL, PrivacySettings.DATA_CAMERA, null, null);
+    			    	return IS_ALLOWED;
+    			    	
+    				default: //that should never happen!
+    					PrivacyDebugger.e(PRIVACY_TAG, "called method checkIfPackagesAllowed() with wrong parameter, implementation failure!! -> returning now IS_NOT_ALLOWED!");
+    					return IS_NOT_ALLOWED;
+    					
+    			}
+    		}
+    		else{
+    			int output;
+    			PrivacyDebugger.w(PRIVACY_TAG, "can't parse packages because array is null, going to apply default deny mode");
+    			if(PrivacySettings.CURRENT_DEFAULT_DENY_MODE != PrivacySettings.DEFAULT_DENY_REAL) {
+    				pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, 
+    						(privacySetting == MODE_RECORD_BOTH) ? PrivacySettings.DATA_CAMERA : PrivacySettings.DATA_RECORD_AUDIO, null, null);	
+    				output = IS_NOT_ALLOWED;
+    			} else {
+    				pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, 
+    						(privacySetting == MODE_RECORD_BOTH) ? PrivacySettings.DATA_CAMERA : PrivacySettings.DATA_RECORD_AUDIO, null, null);
+    				output = IS_ALLOWED;
+    			}
+    			return output;
+    		}
+    		
+    		
+    	}
+    	catch (Exception e){
+    		PrivacyDebugger.e(PRIVACY_TAG,"Got exception in checkIfPackagesAllowed", e);
+    		int output;
+    		PrivacyDebugger.e(PRIVACY_TAG, "got error while trying to check permission. Going to apply default deny mode.");
+			if(PrivacySettings.CURRENT_DEFAULT_DENY_MODE != PrivacySettings.DEFAULT_DENY_REAL) {
+				pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, 
+						(privacySetting == MODE_RECORD_BOTH) ? PrivacySettings.DATA_CAMERA : PrivacySettings.DATA_RECORD_AUDIO, null, null);	
+				output = IS_NOT_ALLOWED;
+			} else {
+				pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, 
+						(privacySetting == MODE_RECORD_BOTH) ? PrivacySettings.DATA_CAMERA : PrivacySettings.DATA_RECORD_AUDIO, null, null);
+				output = IS_ALLOWED;
+			}
+			return output;
+    	}
+    }
+    /**
+     * {@hide}
+     * This method sets up all variables which are needed for privacy mode! It also writes to privacyMode, if everything was successfull or not! 
+     * -> privacyMode = true ok! otherwise false!
+     * CALL THIS METHOD IN CONSTRUCTOR!
+     */
+    private void initiate(){
+    	try{
+    		context = null;
+    		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    		mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+       	 	//runner = new PrivacyRunner();
+       	 	privacyMode = true;
+    	}
+    	catch(Exception e){
+    		PrivacyDebugger.e(PRIVACY_TAG, "Something went wrong with initalize variables", e);
+    		privacyMode = false;
+    	}
+    }
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+
     /**
      * Defines the audio source. These constants are used with
      * {@link MediaRecorder#setAudioSource(int)}.
@@ -340,6 +716,13 @@ public class MediaRecorder
      * @see android.media.CamcorderProfile
      */
     public void setProfile(CamcorderProfile profile) {
+
+    	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    	//BEGIN PRIVACY 
+    	ACTUAL_STATE = STATE_RECORD_BOTH;
+    	//END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
         setOutputFormat(profile.fileFormat);
         setVideoFrameRate(profile.videoFrameRate);
         setVideoSize(profile.videoFrameWidth, profile.videoFrameHeight);
@@ -374,6 +757,13 @@ public class MediaRecorder
      * possible.
      */
     public void setCaptureRate(double fps) {
+
+    	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    	//BEGIN PRIVACY 
+    	ACTUAL_STATE = STATE_RECORD_BOTH;
+    	//END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
         // Make sure that time lapse is enabled when this method is called.
         setParameter("time-lapse-enable=1");
 
@@ -601,6 +991,13 @@ public class MediaRecorder
      * @param bitRate the video encoding bit rate in bits per second.
      */
     public void setVideoEncodingBitRate(int bitRate) {
+
+	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    	//BEGIN PRIVACY 
+    	ACTUAL_STATE = STATE_RECORD_BOTH;
+    	//END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
         if (bitRate <= 0) {
             throw new IllegalArgumentException("Video encoding bit rate is not positive");
         }
@@ -641,6 +1038,7 @@ public class MediaRecorder
     {
         mPath = null;
         mFd = fd;
+        deletedFile = false;
     }
 
     /**
@@ -655,6 +1053,7 @@ public class MediaRecorder
     {
         mFd = null;
         mPath = path;
+        deletedFile = false;
     }
 
     // native implementation
@@ -673,6 +1072,51 @@ public class MediaRecorder
      */
     public void prepare() throws IllegalStateException, IOException
     {
+
+    	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    	//BEGIN PRIVACY
+    	if(!privacyMode){
+    		initiate();
+    	}
+    	deletedFile = false;
+		boolean skip = false;
+		switch(ACTUAL_STATE){
+    		case STATE_RECORD_AUDIO:
+				if(checkIfPackagesAllowed(MODE_RECORD_AUDIO) == IS_NOT_ALLOWED){
+					pRunner = new PrivacyRunner();
+					//here we do not need to exchange the path or filedescriptor, because we can interrupt very quick!
+					pRunner.setDelay(50); // try very low value
+					pRunner.start();
+					skip = true;
+				}
+				break;
+    		case STATE_RECORD_BOTH:
+				if(checkIfPackagesAllowed(MODE_RECORD_BOTH) == IS_NOT_ALLOWED){
+					if(mPath != null){
+						//now overwrite path
+						mPath = getPrivacyPath();
+					} else if(mFd != null){
+						//now overwrite fileDescriptor
+						mFd = getPrivacyFileDescriptor();
+					} else{
+						//no chance to get it, throw exception
+						throw new IOException("No valid output file");
+					}
+					pRunner = new PrivacyRunner();
+					//we use default time for video record
+					pRunner.start();
+					skip = true;
+					
+				}
+				break;
+		}
+		//END PRIVACY
+	    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+		//THX at MB66 who found this bug :-)
+		if(!skip){
+			deletedFile = true;
+		}
+
         if (mPath != null) {
             FileOutputStream fos = new FileOutputStream(mPath);
             try {
@@ -725,7 +1169,24 @@ public class MediaRecorder
      */
     public void reset() {
         native_reset();
-
+        if(!deletedFile){
+        	if(mPath != null){
+			File tmp = new File(mPath);
+			if(tmp.delete())
+				deletedFile = true;
+			} else if(mFd != null && pFileDescriptorPath != null){
+				File tmp = new File(pFileDescriptorPath);
+				if(tmp.delete())
+					deletedFile = true;
+			} else{
+				PrivacyDebugger.e(PRIVACY_TAG,"Can't delete temporary File, because all is null?! It could be that we only want to record audio?!");
+				deletedFile = false;
+			}
+        }
+        //
+        pRunner = null;
+        System.gc();
+        //
         // make sure none of the listeners get called anymore
         mEventHandler.removeCallbacksAndMessages(null);
     }
@@ -1006,5 +1467,81 @@ public class MediaRecorder
     private native void setParameter(String nameValuePair);
 
     @Override
-    protected void finalize() { native_finalize(); }
+    protected void finalize() { 
+    	
+    	if(!deletedFile){
+        	if(mPath != null){
+			File tmp = new File(mPath);
+			if(tmp.delete())
+				deletedFile = true;
+			} else if(mFd != null && pFileDescriptorPath != null){
+				File tmp = new File(pFileDescriptorPath);
+				if(tmp.delete())
+					deletedFile = true;
+			} else{
+				PrivacyDebugger.e(PRIVACY_TAG,"Can't delete temporary File, because all is null?! It could be that we only want to record audio?!");
+				deletedFile = false;
+			}
+        }
+    	native_finalize(); }
+    
+    
+//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+//BEGIN PRIVACY
+	/**
+	* Helper class to interrupt stream.
+	* @author CollegeDev
+	* {@hide}
+	*/
+	private class PrivacyRunner extends Thread{
+	
+		private static final long OFFSET_DELAY = 2500;	
+		
+		private long delay = OFFSET_DELAY;
+		
+		public PrivacyRunner(){
+		
+		}
+		
+		public void setDelay(long delay){
+			this.delay = delay;
+		}
+		
+		public long getDelay(){
+			return delay;
+		}
+		
+		@Override
+		public void run() {
+			try{
+				Thread.sleep(delay);
+				//now we're going to stop stream
+				privacyStop();
+				if(mPath != null){
+					File tmp = new File(mPath);
+					if(tmp.delete())
+						deletedFile = true;
+				} else if(mFd != null && pFileDescriptorPath != null){
+					File tmp = new File(pFileDescriptorPath);
+					if(tmp.delete())
+						deletedFile = true;
+				} else{
+					PrivacyDebugger.e(PRIVACY_TAG,"Can't delete temporary File, because all is null?! It could be that we only want to record audio?!");
+					deletedFile = false;
+				}
+			}
+			catch(Exception e){
+				PrivacyDebugger.e(PRIVACY_TAG,"Something went wrong while waiting for cancel the stream!");
+				e.printStackTrace();
+			}
+			finally{
+				privacyStop();
+			}
+		}
+	
+	}
+	//END PRIVACY
+	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    
+    
 }
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/preloaded-classes pang/frameworks/base/preloaded-classes
--- /media/ROM-Speicher/CM10.1/frameworks/base/preloaded-classes	2013-04-02 21:48:05.805433315 +0545
+++ pang/frameworks/base/preloaded-classes	2013-02-08 18:47:35.355739435 +0545
@@ -2,6 +2,22 @@
 # Automatically generated by frameworks/base/tools/preload/WritePreloadedClassFile.java.
 # MIN_LOAD_TIME_MICROS=1250
 # MIN_PROCESSES=10
+# BEGIN PRIVACY
+android.privacy.utilities.PrivacyConstants
+android.privacy.utilities.PrivacyDebugger
+android.privacy.utilities.ResolveHelper
+android.privacy.PrivacySettingsManagerService
+android.privacy.PrivacySettingsManager
+android.privacy.PrivacySettings
+android.privacy.PrivacyPersistenceAdapter
+android.privacy.IPrivacySettingsManager
+android.privacy.surrogate.PrivacyActivityManagerService
+android.privacy.surrogate.PrivacyCDMALTEPhone
+android.privacy.surrogate.PrivacyCDMAPhone
+android.privacy.surrogate.PrivacyGSMPhone
+android.privacy.surrogate.PrivacyPhoneProxy
+android.privacy.surrogate.PrivacySipPhone
+# END PRIVACY
 android.R$styleable
 android.accounts.Account
 android.accounts.Account$1
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/IPrivacySettingsManager.aidl pang/frameworks/base/privacy/java/android/privacy/IPrivacySettingsManager.aidl
--- /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/IPrivacySettingsManager.aidl	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/base/privacy/java/android/privacy/IPrivacySettingsManager.aidl	2013-02-05 04:02:30.000000000 +0545
@@ -0,0 +1,24 @@
+package android.privacy;
+import android.privacy.PrivacySettings;
+
+/** {@hide} */
+interface IPrivacySettingsManager
+{
+    PrivacySettings getSettings(String packageName);
+    boolean saveSettings(in PrivacySettings settings);
+    boolean deleteSettings(String packageName);
+    void notification(String packageName, byte accessMode, String dataType, String output);
+    void registerObservers();
+    void addObserver(String packageName);
+    boolean purgeSettings();
+    double getVersion();
+    boolean setEnabled(boolean enable);
+    boolean setNotificationsEnabled(boolean enable);
+    void setBootCompleted();
+    void killTask(in String[] packageName, int UID);
+    int getLastCallerId(long uniqueId);
+    void toggleDebugMode(boolean state);
+    boolean isFailSafeActive();
+    void setFailSafeMode(boolean state);
+    void disableOrEnableApplication(String packageName, int UID, boolean disable);
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/PrivacyCache.java pang/frameworks/base/privacy/java/android/privacy/PrivacyCache.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/PrivacyCache.java	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/base/privacy/java/android/privacy/PrivacyCache.java	2013-02-08 20:05:27.000000000 +0545
@@ -0,0 +1,154 @@
+package android.privacy;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+
+import android.privacy.PrivacySettings;
+
+import android.privacy.utilities.PrivacyDebugger;
+
+
+/**
+ * Copyright (C) 2012-2013 Stefan Thiele (CollegeDev)
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+/**
+ * {@hide}
+ *
+ */
+public final class PrivacyCache {
+	
+	private static final String TAG = "PrivacyCache";
+	
+	/**
+	 * Cache holds all fresh settings -> speeds up accesses and saves battery consumption
+	 */
+    private final HashMap<String, PrivacySettings> mCache = new HashMap<String, PrivacySettings>();
+    
+    /**
+     * Checks whether the settings are available in cache or not.
+     * @param packageName the packageName of the application
+     * @return	true if cache contains settings for packageName, false otherwise
+     */
+    public boolean containsSetting(String packageName) {
+    	if(packageName == null){
+    		PrivacyDebugger.e(TAG,"passed null to containsSetting, return false");
+    		return false;
+    	}
+    	boolean output = false;
+    	synchronized(mCache) {
+    		output = mCache.containsKey(packageName);
+    	}
+    	return output;
+    }
+    
+    /**
+     * 
+     * @param packageName the packageName of the application
+     * @return the privacySettings for the given applicationName or null if cache doesn't contain this setting
+     */
+    public PrivacySettings getSettings(String packageName) {
+    	if(packageName == null) {
+    		PrivacyDebugger.e(TAG,"passed null to getSettings(), return");
+    		return null;
+    	}
+    	PrivacySettings output = null;
+    	synchronized(mCache) {
+    		output = mCache.get(packageName);
+    		PrivacyDebugger.i(TAG, "cache contains package: " + packageName + " -> " + output);
+    	}
+    	return output;
+    }
+    
+    /**
+     * Fills the cache with given DataSet. Data which exists will be overwritten
+     * @param dataSet collections of privacySettings you want to store in cache
+     */
+    public void fillCache(ArrayList<PrivacySettings> dataSet) {
+    	if(dataSet.isEmpty() || dataSet == null) {
+    		PrivacyDebugger.e(TAG,"can't fill cache, because list is empty or null!");
+    	}
+    	synchronized(mCache) {
+    		for(PrivacySettings settings : dataSet) {
+        		mCache.put(settings.getPackageName(), settings);
+        		PrivacyDebugger.i(TAG,"put package: " + settings.getPackageName() +" to cache");
+        	}
+    	}
+    	
+    }
+    
+    /**
+     * Updates the cache with given settings or fill it first.
+     * @param data PrivacySettings you want to store in cache
+     */
+    public void updateOrSaveSettings(PrivacySettings data) {
+    	if(data == null) {
+    		PrivacyDebugger.e(TAG,"passed NULL as parameter to updateOrSaveSettings(), return");
+    		return;
+    	}
+    	synchronized(mCache) {
+    		mCache.put(data.getPackageName(), data);
+    		PrivacyDebugger.i(TAG, "put package: " + data.getPackageName() + " to cache");
+    	}
+    }
+    
+    /**
+     * deletes the given entry from cache
+     * @param packageName packagename of application 
+     */
+    public void deleteSettings(String packageName) {
+    	if(packageName == null) {
+    		PrivacyDebugger.e(TAG,"passed NULL as parameter to deleteSettings(), return");
+    		return;
+    	}
+    	synchronized(mCache) {
+    		if(mCache.remove(packageName) != null)
+    			PrivacyDebugger.w(TAG,"removed settings for package: " + packageName + " from cache");
+    		else
+    			PrivacyDebugger.e(TAG,"got error while trying to remove settings for package: " + packageName + " from cache");
+    	}
+    }
+    
+    /**
+     * 
+     * @return ArrayList with all PrivacySettings which are stored in the cache
+     */
+    public ArrayList<PrivacySettings> getAllSetings() {
+    	synchronized(mCache) {
+    		return new ArrayList<PrivacySettings>(mCache.values());
+    	}
+    }
+     
+    /**
+     * Marks the whole settings in our cache as new entries for the database.
+     * Only call this method for recovery purpose after unauthorized database access.
+     */
+    public void markAllAsNewEntry() {
+    	synchronized(mCache) {
+    		ArrayList<PrivacySettings> tmp = new ArrayList<PrivacySettings>(mCache.values());
+        	mCache.clear();
+        	for(PrivacySettings settings : tmp) {
+        		PrivacyDebugger.i(TAG,"marking settings for package: " + settings.getPackageName() + " as new entry");
+        		mCache.put(settings.getPackageName(), PrivacySettings.markAsNewEntry(settings));
+        	}
+    	}
+    }
+    
+    /**
+     * Deletes the whole cache
+     */
+    public void removeAll() {
+    	synchronized(mCache) {
+    		mCache.clear();
+    		PrivacyDebugger.w(TAG,"cleared whole privacy Cache!");
+    	}
+    }
+    
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/PrivacyFileObserver.java pang/frameworks/base/privacy/java/android/privacy/PrivacyFileObserver.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/PrivacyFileObserver.java	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/base/privacy/java/android/privacy/PrivacyFileObserver.java	2013-01-22 01:30:45.000000000 +0545
@@ -0,0 +1,118 @@
+package android.privacy;
+
+import android.os.FileObserver;
+import android.util.Log;
+
+import java.io.File;
+import java.util.HashMap;
+import java.util.StringTokenizer;
+
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+/**
+ * {@hide}
+ * @author Svyatoslav Hresyk; modified & improved by CollegeDev (Stefan. T)
+ *
+ */
+public class PrivacyFileObserver extends FileObserver {
+    
+    public static final String TAG = "PrivacyFileObserver";
+    
+    public static final int PACKAGE_PATH_INDEX = 3;
+
+    public static final int SETTINGS_TYPE_INDEX = PACKAGE_PATH_INDEX + 1;
+    
+    public String absolutePath;
+    
+    private PrivacySettingsManagerService pSetManServ;
+    
+    public HashMap<String, PrivacyFileObserver> children; 
+    
+    public PrivacyFileObserver(String path, PrivacySettingsManagerService pSetManServ) {
+        super(path, FileObserver.ALL_EVENTS);
+        this.absolutePath = path;
+        this.pSetManServ = pSetManServ;
+        
+        this.children = new HashMap<String, PrivacyFileObserver>();
+        File thisFile = new File(absolutePath);
+        if (thisFile.isDirectory()) {
+            File[] subfiles = thisFile.listFiles();
+            for (File file : subfiles) {
+                String observePath = file.getAbsolutePath();
+                PrivacyFileObserver child = new PrivacyFileObserver(observePath, pSetManServ);
+                children.put(observePath, child);
+                // don't watch directories, only the settings files
+                if (file.isFile()) child.startWatching();
+            }
+        }
+        
+    }
+
+    @Override
+    public void onEvent(int event, String path) {
+        if ((FileObserver.ACCESS & event) != 0) { // data was read from a file
+//            PrivacyDebugger.d(TAG, "onEvent - file accessed: " + absolutePath);
+            StringTokenizer tokenizer = new StringTokenizer(absolutePath, "/");
+            for (int i = 0; i < PACKAGE_PATH_INDEX && tokenizer.hasMoreElements(); i++) {
+                tokenizer.nextToken();
+            }	
+            
+            // get the package and UID of accessing application
+            String packageName = tokenizer.nextToken();
+            String settingsType = null;
+            if(tokenizer.hasMoreElements()) settingsType = tokenizer.nextToken();
+//            int uid = 0;
+//            try {
+//                uid = Integer.parseInt(tokenizer.nextToken());
+//            } catch (NumberFormatException e) {
+//                PrivacyDebugger.e(TAG, "onEvent - could not get the UID of accessing application", e);
+//                // we still can continue, UID is optional here
+//            }
+            
+            // read the setting
+	    try{
+	    		if(settingsType != null && settingsType.equals("ipTableProtectSetting")){
+	    			PrivacySettings pSet = pSetManServ.getSettings(packageName);
+	            	pSetManServ.notification(packageName, pSet.getIpTableProtectSetting(), PrivacySettings.DATA_IP_TABLES, null);
+	    		} else{
+	    			PrivacySettings pSet = pSetManServ.getSettings(packageName);
+	            	pSetManServ.notification(packageName, pSet.getSystemLogsSetting(), PrivacySettings.DATA_SYSTEM_LOGS, null);
+	    		}
+	    }
+	    catch (Exception e){
+		//nothing here
+            }
+        }
+        
+    }
+    
+    public void addObserver(String relativePath) {
+        String observePath = absolutePath + "/" + relativePath;
+        // remove existing observer(s) if any
+        children.remove(observePath); // child observers should be destroyed at next GC
+        // create new observer(s)
+        PrivacyFileObserver child = new PrivacyFileObserver(observePath, pSetManServ);
+        children.put(observePath, child);
+    }
+
+    @Override
+    public void startWatching() {
+//        PrivacyDebugger.d("PrivacyFileObserver", "PrivacyFileObserver - observing directory: " + absolutePath);
+        super.startWatching();
+    }
+    
+//    public void verifyObserver() {
+//        PrivacyDebugger.d(TAG, "verifyObservers - observer path: " + absolutePath);
+//        for (PrivacyFileObserver obs : children.values()) obs.verifyObserver();
+//    }
+    
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/PrivacyNotificationHandler.java pang/frameworks/base/privacy/java/android/privacy/PrivacyNotificationHandler.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/PrivacyNotificationHandler.java	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/base/privacy/java/android/privacy/PrivacyNotificationHandler.java	2013-04-02 19:06:32.631340903 +0545
@@ -0,0 +1,51 @@
+package android.privacy;
+
+import java.util.HashMap;
+import android.privacy.utilities.PrivacyDebugger;
+
+/**
+ * Copyright (C) 2012-2013 Stefan Thiele (CollegeDev)
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+public final class PrivacyNotificationHandler {
+
+	private static final String TAG = "PrivacyNotificationHandler";
+	
+	private final HashMap<String, Long> records = new HashMap<String, Long>();
+	
+	private static final long NOTIFICATION_TIMEOUT = 1000;
+	
+	private void addOrUpdateRecord(final String packageName, final String dataType) {
+		synchronized (records) {
+			records.put(packageName+dataType, Long.valueOf(System.currentTimeMillis()));
+			PrivacyDebugger.i(TAG, "addOrUpdateRecord - added key: [" + packageName+dataType + "]");
+		}
+	}
+	
+	public boolean isNotificationValid(final String packageName, final String dataType) {
+		boolean output = false;
+		synchronized (records) {
+			Long time = records.get(packageName+dataType);
+			if (time != null) {
+				long delta = System.currentTimeMillis() - time;
+				if (Math.abs(delta) > NOTIFICATION_TIMEOUT) {
+					PrivacyDebugger.i(TAG,"notification allowed for package: [" + packageName + "] dataType: [" + dataType + "]");
+					addOrUpdateRecord(packageName, dataType); //update our records!
+					output = true;
+				} 
+			} else {
+				PrivacyDebugger.w(TAG,"isNotificationValid - record does not exists -> return true");
+				addOrUpdateRecord(packageName, dataType); //add new record
+				output = true;
+			}
+		}
+		return output;
+	}
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/PrivacyPersistenceAdapter.java pang/frameworks/base/privacy/java/android/privacy/PrivacyPersistenceAdapter.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/PrivacyPersistenceAdapter.java	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/base/privacy/java/android/privacy/PrivacyPersistenceAdapter.java	2013-02-24 20:14:16.000000000 +0545
@@ -0,0 +1,1164 @@
+package android.privacy;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteException;
+import android.os.FileUtils;
+import android.util.Log;
+
+import android.app.ActivityManagerNative;
+import android.os.RemoteException;
+import android.os.Process;
+import android.privacy.PrivacyWatchDog.PrivacyWatchDogInterface;
+import android.privacy.utilities.PrivacyDebugger;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+/**
+ * Responsible for persisting privacy settings to built-in memory
+ * @author Svyatoslav Hresyk; modified & improved by CollegeDev (Stefan T.)
+ * {@hide}
+ */
+public final class PrivacyPersistenceAdapter implements PrivacyWatchDogInterface {
+
+    private static final String TAG = "PrivacyPersistenceAdapter";
+    
+    private static final int RETRY_QUERY_COUNT = 5;
+
+    private static final String DATABASE_FILE = "/data/system/privacy.db";
+    
+    private static final String DATABASE_JOURNAL_FILE = "/data/system/privacy.db-journal";
+    
+    private static final int DATABASE_VERSION = 4;
+    
+    public static final int DUMMY_UID = -1;
+    
+    /**
+     * Used to save settings for access from core libraries
+     */
+    public static final String SETTINGS_DIRECTORY = "/data/system/privacy";
+
+    /**
+     * Thread safe object for determine how many threads currently have access to database
+     */
+    private final AtomicInteger dbThreads = new AtomicInteger();
+    
+    /**
+     * For locking the database!
+     */
+    private final ReentrantReadWriteLock mLock = new ReentrantReadWriteLock();
+    
+    
+    /**
+     * Since we're not able to extend from SQLiteDatabase we have to call the onauthorized methods on every write access to database!
+     */
+    private PrivacyWatchDog watchDog;
+
+    private static final String TABLE_SETTINGS = "settings";
+    
+    private static final String TABLE_MAP = "map";
+    
+    private static final String TABLE_ALLOWED_CONTACTS = "allowed_contacts";
+    
+    private static final String TABLE_VERSION = "version";
+    
+    private static final String RECEIVE_FAIL_SAFE_TRIGGERED = "android.privacy.RECEIVE_FAIL_SAFE_TRIGGERED";
+    
+    /**
+     * Used for caching some settings
+     */
+    private PrivacyCache mCache = new PrivacyCache();
+    
+    private static final String CREATE_TABLE_SETTINGS = 
+        "CREATE TABLE IF NOT EXISTS " + TABLE_SETTINGS + " ( " + 
+        " _id INTEGER PRIMARY KEY AUTOINCREMENT, " + 
+        " packageName TEXT, " + 
+        " uid INTEGER, " + 
+        " deviceIdSetting INTEGER, " + 
+        " deviceId TEXT, " + 
+        " line1NumberSetting INTEGER, " + 
+        " line1Number TEXT, " + 
+        " locationGpsSetting INTEGER, " + 
+        " locationGpsLat TEXT, " + 
+        " locationGpsLon TEXT, " + 
+        " locationNetworkSetting INTEGER, " + 
+        " locationNetworkLat TEXT, " + 
+        " locationNetworkLon TEXT, " + 
+        " networkInfoSetting INTEGER, " + 
+        " simInfoSetting INTEGER, " + 
+        " simSerialNumberSetting INTEGER, " + 
+        " simSerialNumber TEXT, " + 
+        " subscriberIdSetting INTEGER, " + 
+        " subscriberId TEXT, " + 
+        " accountsSetting INTEGER, " + 
+        " accountsAuthTokensSetting INTEGER, " + 
+        " outgoingCallsSetting INTEGER, " + 
+        " incomingCallsSetting INTEGER, " + 
+        " contactsSetting INTEGER, " + 
+        " calendarSetting INTEGER, " + 
+        " mmsSetting INTEGER, " + 
+        " smsSetting INTEGER, " + 
+        " callLogSetting INTEGER, " + 
+        " bookmarksSetting INTEGER, " + 
+        " systemLogsSetting INTEGER, " + 
+        " externalStorageSetting INTEGER, " + 
+        " cameraSetting INTEGER, " + 
+        " recordAudioSetting INTEGER, " + 
+        " notificationSetting INTEGER, " + 
+        " intentBootCompletedSetting INTEGER," + 
+        " smsSendSetting INTEGER," + 
+        " phoneCallSetting INTEGER," +
+        " ipTableProtectSetting INTEGER," +
+        " iccAccessSetting INTEGER," +
+        " addOnManagementSetting INTEGER," + 
+        " androidIdSetting INTEGER," +
+        " androidId TEXT," +
+        " wifiInfoSetting INTEGER," +
+        " switchConnectivitySetting INTEGER," +
+        " sendMmsSetting INTEGER," +
+        " forceOnlineState INTEGER," + 
+        " switchWifiStateSetting INTEGER" +
+        ");";
+    
+    
+    private static final String CREATE_TABLE_MAP = 
+        "CREATE TABLE IF NOT EXISTS " + TABLE_MAP + " ( name TEXT PRIMARY KEY, value TEXT );";
+    
+    private static final String CREATE_TABLE_ALLOWED_CONTACTS = 
+        "CREATE TABLE IF NOT EXISTS " + TABLE_ALLOWED_CONTACTS + " ( settings_id, contact_id, PRIMARY KEY(settings_id, contact_id) );";
+    
+    private static final String INSERT_VERSION = 
+        "INSERT OR REPLACE INTO " + TABLE_MAP + " (name, value) " + "VALUES (\"db_version\", " + DATABASE_VERSION + ");";
+    
+    private static final String INSERT_ENABLED = 
+        "INSERT OR REPLACE INTO " + TABLE_MAP + " (name, value) " + "VALUES (\"enabled\", \"1\");";
+    
+    private static final String INSERT_NOTIFICATIONS_ENABLED = 
+        "INSERT OR REPLACE INTO " + TABLE_MAP + " (name, value) " + "VALUES (\"notifications_enabled\", \"1\");";
+    
+    private static final String[] DATABASE_FIELDS = new String[] { "_id", "packageName", "uid", 
+        "deviceIdSetting", "deviceId", "line1NumberSetting", "line1Number", "locationGpsSetting", 
+        "locationGpsLat", "locationGpsLon", "locationNetworkSetting", "locationNetworkLat", 
+        "locationNetworkLon", "networkInfoSetting", "simInfoSetting", "simSerialNumberSetting", 
+        "simSerialNumber", "subscriberIdSetting", "subscriberId", "accountsSetting", "accountsAuthTokensSetting", 
+        "outgoingCallsSetting", "incomingCallsSetting", "contactsSetting", "calendarSetting", 
+        "mmsSetting", "smsSetting", "callLogSetting", "bookmarksSetting", "systemLogsSetting", 
+        "externalStorageSetting", "cameraSetting", "recordAudioSetting", "notificationSetting", 
+        "intentBootCompletedSetting", "smsSendSetting", "phoneCallSetting", "ipTableProtectSetting", "iccAccessSetting"
+        , "addOnManagementSetting", "androidIdSetting", "androidId", "wifiInfoSetting", "switchConnectivitySetting", "sendMmsSetting"
+        , "forceOnlineState" , "switchWifiStateSetting"};
+    
+    public static final String SETTING_ENABLED = "enabled";
+    public static final String SETTING_NOTIFICATIONS_ENABLED = "notifications_enabled";
+    public static final String SETTING_DB_VERSION = "db_version";
+    public static final String VALUE_TRUE = "1";
+    public static final String VALUE_FALSE = "0";
+
+    private SQLiteDatabase db;
+    
+    private Context context;
+    
+    private boolean isFailSaveActive = false;
+    
+
+    public PrivacyPersistenceAdapter(Context context) {
+        this.context = context;
+        
+        boolean canWrite = new File("/data/system/").canWrite();
+        watchDog = new PrivacyWatchDog(this);
+        
+        PrivacyDebugger.d(TAG, "Constructing " + TAG + " for package: " +  context.getPackageName() + "; Write permission for /data/system/: " + canWrite);
+        
+        if (canWrite) {
+        	announceConnection();
+        	mLock.writeLock().lock();
+        	watchDog.onBeginAuthorizedTransaction();
+        	try {
+        		if (!new File(DATABASE_FILE).exists()) 
+        			createDatabase();
+        		
+                if (!new File(SETTINGS_DIRECTORY).exists()) 
+                	createSettingsDir();
+                
+                int currentVersion = getDbVersion();
+                PrivacyDebugger.d(TAG, "PrivacyPersistenceAdapter - current DB version: " + currentVersion);
+                
+                if (currentVersion < DATABASE_VERSION) 
+                	upgradeDatabase(currentVersion);
+                
+                fillPrivacyCache();
+                
+        	} catch(Exception e) {
+        		PrivacyDebugger.e(TAG, "got exception while trying to create database and/or settingsDirectories");
+        	} finally {
+        		watchDog.onEndAuthorizedTransaction();
+        		mLock.writeLock().unlock();
+        		closeIdlingDatabase();
+        	}
+        }
+    }
+    
+   
+
+    private void upgradeDatabase(int currentVersion) {
+    	
+        PrivacyDebugger.i(TAG, "upgradeDatabase - upgrading DB from version " + currentVersion + " to " + DATABASE_VERSION);
+        
+        announceConnection();
+        mLock.writeLock().lock();
+        watchDog.onBeginAuthorizedTransaction();
+        SQLiteDatabase db = null;
+        try {
+        	db = getDatabase();
+            db.beginTransaction();
+        	switch (currentVersion) {
+	            case 1:
+	            case 2:
+	            case 3:
+                    if (db != null && db.isOpen()) {
+                        db.execSQL("DROP TABLE IF EXISTS " + TABLE_VERSION + ";");
+                        db.execSQL(CREATE_TABLE_ALLOWED_CONTACTS); 
+                        db.execSQL(CREATE_TABLE_MAP);
+                        db.execSQL(INSERT_VERSION);
+                        db.execSQL(INSERT_ENABLED);
+                        db.execSQL(INSERT_NOTIFICATIONS_ENABLED);
+                        
+                        // remove uid dirs from the settings directory
+                        File settingsDir = new File(SETTINGS_DIRECTORY);
+                        for (File packageDir : settingsDir.listFiles()) {
+                            for (File uidDir : packageDir.listFiles()) {
+                                if (uidDir.isDirectory()) {
+                                    File[] settingsFiles = uidDir.listFiles();
+                                    // copy the first found (most likely the only one) one level up
+                                    if (settingsFiles[0] != null) {
+                                        File newPath = new File(packageDir + "/" + settingsFiles[0].getName());
+                                        newPath.delete();
+                                        settingsFiles[0].renameTo(newPath);
+                                        deleteRecursive(uidDir);
+                                    }
+                                }
+                            }
+                        }
+                        
+                        db.setTransactionSuccessful();
+                    } else {
+                    	PrivacyDebugger.e(TAG, "cannot upgrade database because database is null or isn't open!");
+                    }
+	                break;
+	                
+	            case 4:
+                	if (db != null && db.isOpen()) {
+                		db.execSQL("DROP TABLE IF EXISTS " + TABLE_VERSION + ";");
+                		db.execSQL("DROP TABLE IF EXISTS " + TABLE_SETTINGS + ";");
+                		db.execSQL(CREATE_TABLE_SETTINGS);
+                		db.execSQL(INSERT_VERSION);
+                		
+                		removeFiles(SETTINGS_DIRECTORY);
+                        
+                        db.setTransactionSuccessful();
+                	} else {
+                    	PrivacyDebugger.e(TAG, "cannot upgrade database because database is null or isn't open!");
+                    }
+	                break;
+        	}
+        	purgeSettings();
+        } catch(Exception e) {
+        	PrivacyDebugger.w(TAG, "upgradeDatabase - could not upgrade DB", e);
+        } finally {
+        	watchDog.onEndAuthorizedTransaction();
+        	mLock.writeLock().unlock();
+        	closeIdlingDatabase();
+        	
+        }
+    }
+    
+    private int getDbVersion() {
+    	
+        String versionString = getValue(SETTING_DB_VERSION);
+        if (versionString == null) {
+        	PrivacyDebugger.e(TAG, "getValue returned null for db version, returning version 1");
+        	return 1;
+        }
+        
+        try {
+            return Integer.parseInt(versionString);
+        } catch (Exception e) {
+            PrivacyDebugger.e(TAG, "getDbVersion - failed to parse database version; returning 1");
+            return 1;
+        }
+        
+    }
+    
+    public String getValue(String name) {
+        SQLiteDatabase db = null;
+        Cursor c = null;
+        String output = null;
+        announceConnection();
+        mLock.readLock().lock();
+        try {
+        	db = getDatabase();
+            c = query(db, TABLE_MAP, new String[] { "value" }, "name=?", 
+                    new String[] { name }, null, null, null, null);
+            if (c != null && c.getCount() > 0 && c.moveToFirst()) {
+                output = c.getString(c.getColumnIndex("value"));
+                c.close();
+            } else {
+                PrivacyDebugger.w(TAG, "getValue - could not get value for name: " + name);
+            }
+        } catch (Exception e) {
+            PrivacyDebugger.w(TAG, "getValue - could not get value for name: " + name, e);
+        } finally {
+        	mLock.readLock().unlock();
+        	closeIdlingDatabase();
+        }
+        
+        return output;
+    }
+    
+    public boolean setValue(String name, String value) {
+        PrivacyDebugger.e(TAG, "setValue - name " + name + " value " + value);
+        ContentValues values = new ContentValues();
+        values.put("name", name);
+        values.put("value", value);
+        announceConnection();
+        mLock.writeLock().lock();
+        boolean success = false;
+        watchDog.onBeginAuthorizedTransaction();
+        try {
+            SQLiteDatabase db = getDatabase();
+            success = db.replace(TABLE_MAP, null, values) != -1;
+            
+        } catch (Exception e) {
+        	PrivacyDebugger.e(TAG, "got error while trying to set value: " + name + "to: " + value);
+        } finally {
+        	watchDog.onEndAuthorizedTransaction();
+        	mLock.writeLock().unlock();
+        	closeIdlingDatabase();
+        }
+        return success;
+    }
+    
+    public PrivacySettings getSettings(String packageName) {
+    	return getSettings(packageName, false);
+    }
+    
+    /**
+     * Get the privacySettings for given packageName
+     * @param packageName packageName of the application
+     * @param fillCache pass true if you want to fill the cache (only needed for method fillPrivacyCache after we're in failSafeMode) -> bypassing failSafeMode
+     * @return privacySettings
+     */
+    private PrivacySettings getSettings(String packageName, boolean fillCache) {
+        PrivacySettings s = null;
+
+        if (packageName == null) {
+            PrivacyDebugger.e(TAG, "getSettings - insufficient application identifier - package name is required");
+            return s;
+        }
+        
+        if(isFailSafeActive() && !fillCache) { 
+        	PrivacyDebugger.w(TAG,"failSafeMode is active -> return blocked privacy object!");
+        	return PrivacySettings.getFailSaveObject();
+        }
+        
+        if(mCache.containsSetting(packageName)) {
+        	return mCache.getSettings(packageName);
+        }
+
+        announceConnection();
+        mLock.readLock().lock();
+        
+        SQLiteDatabase db;
+        try {
+            db = getDatabase();
+        } catch (SQLiteException e) {
+            PrivacyDebugger.e(TAG, "getSettings - database could not be opened.", e);
+            mLock.readLock().unlock();
+            closeIdlingDatabase();
+            PrivacyDebugger.w(TAG, "getSettings - returning now default deny settings object!");
+            return PrivacySettings.getDefaultDenyObject();
+        }
+           
+        Cursor c = null;
+
+        try {
+            c = query(db, TABLE_SETTINGS, DATABASE_FIELDS, "packageName=?", new String[] { packageName }, null, null, null, null);
+
+            if (c != null && c.moveToFirst()) {
+                s = new PrivacySettings(c.getInt(0), c.getString(1), c.getInt(2), (byte)c.getShort(3), c.getString(4), 
+                        (byte)c.getShort(5), c.getString(6), (byte)c.getShort(7), c.getString(8), c.getString(9), (byte)c.getShort(10), 
+                        c.getString(11), c.getString(12), (byte)c.getShort(13), (byte)c.getShort(14), (byte)c.getShort(15), 
+                        c.getString(16), (byte)c.getShort(17), c.getString(18), (byte)c.getShort(19), (byte)c.getShort(20), 
+                        (byte)c.getShort(21), (byte)c.getShort(22), (byte)c.getShort(23), (byte)c.getShort(24), (byte)c.getShort(25), 
+                        (byte)c.getShort(26), (byte)c.getShort(27), (byte)c.getShort(28), (byte)c.getShort(29), (byte)c.getShort(30), 
+                        (byte)c.getShort(31), (byte)c.getShort(32), (byte)c.getShort(33), (byte)c.getShort(34), null, (byte)c.getShort(35), (byte)c.getShort(36), 
+                        (byte)c.getShort(37), (byte)c.getShort(38), (byte)c.getShort(39), (byte)c.getShort(40), c.getString(41), (byte)c.getShort(42),
+                        (byte)c.getShort(43), (byte)c.getShort(44), (byte)c.getShort(45), (byte)c.getShort(46));
+                
+                // get allowed contacts IDs if necessary
+                PrivacyDebugger.d(TAG, "getSettings - looking for allowed contacts for " + s.get_id());
+                c = rawQuery(db, "SELECT * FROM allowed_contacts WHERE settings_id=" + Integer.toString(s.get_id()) + ";");
+                
+                if (c != null && c.getCount() > 0) {
+                    PrivacyDebugger.d(TAG, "getSettings - found allowed contacts");
+                    int[] allowedContacts = new int[c.getCount()];
+                    while (c.moveToNext()) allowedContacts[c.getPosition()] = c.getInt(1);
+                    s.setAllowedContacts(allowedContacts);
+                }
+                PrivacyDebugger.d(TAG, "getSettings - found settings entry for package: " + packageName);
+                mCache.updateOrSaveSettings(s); 
+            } 
+            else {
+                PrivacyDebugger.e(TAG, "getSettings - no settings found for package: " + packageName);
+            } 
+        } catch (Exception e) {
+            PrivacyDebugger.e(TAG, "getSettings - failed to get settings for package: " + packageName, e);
+            
+            PrivacyDebugger.w(TAG, "getSettings - we now passing default deny object!");
+            s = PrivacySettings.getDefaultDenyObject(); // we prevent leaking data by passing a default deny settings object
+            
+            if (c != null) 
+            	c.close();
+        } finally {
+            if (c != null) 
+            	c.close();
+            mLock.readLock().unlock();
+            closeIdlingDatabase();
+        }
+        PrivacyDebugger.d(TAG, "getSettings - returning settings: " + s);
+
+        return s;
+    }
+    
+    
+
+    /**
+     * Saves the settings object fields into DB and into plain text files where applicable. 
+     * The DB changes will not be made persistent if saving settings to plain text files
+     * fails.
+     * @param s settings object
+     * @return true if settings were saved successfully, false otherwise
+     */
+    public boolean saveSettings(PrivacySettings s) {
+        boolean result = true;
+        
+        if(s == null) {
+        	PrivacyDebugger.e(TAG, "settings are null, cannot save NULL to database!");
+        	return false;
+        }
+        
+        String packageName = s.getPackageName();
+        
+        if (packageName == null || packageName.isEmpty()) {
+            PrivacyDebugger.e(TAG, "saveSettings - either package name, UID or both is missing");
+            return false;
+        }
+        
+        ContentValues values = new ContentValues();
+        values.put("packageName", packageName);
+        values.put("uid", DUMMY_UID);
+        
+        values.put("deviceIdSetting", s.getDeviceIdSetting());
+        values.put("deviceId", s.getDeviceId());
+        
+        values.put("line1NumberSetting", s.getLine1NumberSetting());
+        values.put("line1Number", s.getLine1Number());
+        
+        values.put("locationGpsSetting", s.getLocationGpsSetting());
+        values.put("locationGpsLat", s.getLocationGpsLat());
+        values.put("locationGpsLon", s.getLocationGpsLon());
+        
+        values.put("locationNetworkSetting", s.getLocationNetworkSetting());
+        values.put("locationNetworkLat", s.getLocationNetworkLat());
+        values.put("locationNetworkLon", s.getLocationNetworkLon());
+        
+        values.put("networkInfoSetting", s.getNetworkInfoSetting());        
+        values.put("simInfoSetting", s.getSimInfoSetting());
+        
+        values.put("simSerialNumberSetting", s.getSimSerialNumberSetting());        
+        values.put("simSerialNumber", s.getSimSerialNumber());
+        values.put("subscriberIdSetting", s.getSubscriberIdSetting());        
+        values.put("subscriberId", s.getSubscriberId());
+        
+        values.put("accountsSetting", s.getAccountsSetting());
+        values.put("accountsAuthTokensSetting", s.getAccountsAuthTokensSetting());
+        values.put("outgoingCallsSetting", s.getOutgoingCallsSetting());
+        values.put("incomingCallsSetting", s.getIncomingCallsSetting());
+        
+        values.put("contactsSetting", s.getContactsSetting());
+        values.put("calendarSetting", s.getCalendarSetting());
+        values.put("mmsSetting", s.getMmsSetting());
+        values.put("smsSetting", s.getSmsSetting());
+        values.put("callLogSetting", s.getCallLogSetting());
+        values.put("bookmarksSetting", s.getBookmarksSetting());
+        values.put("systemLogsSetting", s.getSystemLogsSetting());
+        values.put("notificationSetting", s.getNotificationSetting());
+        values.put("intentBootCompletedSetting", s.getIntentBootCompletedSetting());
+//        values.put("externalStorageSetting", s.getExternalStorageSetting());
+        values.put("cameraSetting", s.getCameraSetting());
+        values.put("recordAudioSetting", s.getRecordAudioSetting());
+        values.put("smsSendSetting",s.getSmsSendSetting());
+        values.put("phoneCallSetting",s.getPhoneCallSetting());
+        values.put("ipTableProtectSetting", s.getIpTableProtectSetting());
+        values.put("iccAccessSetting", s.getIccAccessSetting());
+        values.put("addOnManagementSetting", s.getAddOnManagementSetting());
+        values.put("androidIdSetting", s.getAndroidIdSetting());
+        values.put("androidId", s.getAndroidID());
+        values.put("wifiInfoSetting", s.getWifiInfoSetting());
+        values.put("switchConnectivitySetting", s.getSwitchConnectivitySetting());
+        values.put("sendMmsSetting", s.getSendMmsSetting());
+        values.put("forceOnlineState", s.getForceOnlineState());
+        values.put("switchWifiStateSetting", s.getSwitchWifiStateSetting());
+        
+        announceConnection();
+        mLock.writeLock().lock();
+        watchDog.onBeginAuthorizedTransaction();
+        SQLiteDatabase db = null;
+        Cursor c = null;
+        
+        try {
+        	db = getDatabase();
+            db.beginTransaction(); // make sure this ends up in a consistent state (DB and plain text files)
+            Integer id = s.get_id();
+            if (id != null) { // existing entry -> update
+                PrivacyDebugger.d(TAG, "saveSettings - updating existing entry");
+                if (db.update(TABLE_SETTINGS, values, "_id=?", new String[] { id.toString() }) < 1) {
+                    throw new Exception("saveSettings - failed to update database entry");
+                }
+                
+                db.delete(TABLE_ALLOWED_CONTACTS, "settings_id=?", new String[] { id.toString() });
+                int[] allowedContacts = s.getAllowedContacts();
+                if (allowedContacts != null) {
+                    ContentValues contactsValues = new ContentValues();
+                    for (int i = 0; i < allowedContacts.length; i++) {
+                        contactsValues.put("settings_id", id);
+                        contactsValues.put("contact_id", allowedContacts[i]);
+                        if (db.insert(TABLE_ALLOWED_CONTACTS, null, contactsValues) == -1){
+                        	throw new Exception("saveSettings - failed to update database entry (contacts)");
+                        }
+                            
+                    }
+                }
+
+            } else { // new entry -> insert if no duplicates exist
+                PrivacyDebugger.d(TAG, "saveSettings - new entry; verifying if duplicates exist");
+                c = db.query(TABLE_SETTINGS, new String[] { "_id" }, "packageName=?", 
+                        new String[] { s.getPackageName() }, null, null, null);
+                
+                if (c != null) {
+                    if (c.getCount() == 1) { // exactly one entry
+                        // exists -> update
+                        PrivacyDebugger.d(TAG, "saveSettings - updating existing entry");
+                        if (db.update(TABLE_SETTINGS, values, "packageName=?", 
+                                new String[] { s.getPackageName() }) < 1) {
+                            throw new Exception("saveSettings - failed to update database entry");
+                        }
+                        
+                        if (c.moveToFirst()) {
+                            Integer idAlt = c.getInt(0); // id of the found duplicate entry
+                            db.delete(TABLE_ALLOWED_CONTACTS, "settings_id=?", new String[] { idAlt.toString() });
+                            int[] allowedContacts = s.getAllowedContacts();
+                            if (allowedContacts != null) {
+                                ContentValues contactsValues = new ContentValues();
+                                for (int i = 0; i < allowedContacts.length; i++) {
+                                    contactsValues.put("settings_id", idAlt);
+                                    contactsValues.put("contact_id", allowedContacts[i]);
+                                    if (db.insert(TABLE_ALLOWED_CONTACTS, null, contactsValues) == -1) {
+                                    	throw new Exception("saveSettings - failed to update database entry (contacts)");
+                                    }
+                                        
+                                }
+                            }    
+                        }
+                    } else if (c.getCount() == 0) { // no entries -> insert
+                        PrivacyDebugger.d(TAG, "saveSettings - inserting new entry");
+                        long rowId = db.insert(TABLE_SETTINGS, null, values);
+                        if (rowId == -1) {
+                            throw new Exception("saveSettings - failed to insert new record into DB");
+                        }
+                        
+                        db.delete(TABLE_ALLOWED_CONTACTS, "settings_id=?", new String[] { Long.toString(rowId) });
+                        int[] allowedContacts = s.getAllowedContacts();
+                        if (allowedContacts != null) {
+                            ContentValues contactsValues = new ContentValues();
+                            for (int i = 0; i < allowedContacts.length; i++) {
+                                contactsValues.put("settings_id", rowId);
+                                contactsValues.put("contact_id", allowedContacts[i]);
+                                if (db.insert(TABLE_ALLOWED_CONTACTS, null, contactsValues) == -1) {
+                                	throw new Exception("saveSettings - failed to update database entry (contacts)");
+                                }
+                                    
+                            }
+                        }                        
+                    } else { // something went totally wrong and there are multiple entries for same identifier
+                        result = false;
+                        throw new Exception("saveSettings - duplicate entries in the privacy.db");
+                    }
+                } else {
+                    result = false;
+                    // jump to catch block to avoid marking transaction as successful
+                    throw new Exception("saveSettings - cursor is null, database access failed");
+                }
+            }
+            
+            // save settings to plain text file (for access from core libraries)
+            result = writeExternalSettings("systemLogsSetting", packageName, s);
+            result = writeExternalSettings("ipTableProtectSetting", packageName, s);
+            
+            // mark DB transaction successful (commit the changes)
+            db.setTransactionSuccessful();
+            
+            mCache.updateOrSaveSettings(s);
+            
+            PrivacyDebugger.d(TAG, "saveSettings - completing transaction");
+        } catch (Exception e) {
+            result = false;
+            PrivacyDebugger.d(TAG, "saveSettings - could not save settings", e);
+        } finally {
+            if(db != null) 
+            	db.endTransaction();
+            if (c != null) 
+            	c.close();
+            watchDog.onEndAuthorizedTransaction();
+            mLock.writeLock().unlock();
+            closeIdlingDatabase();
+        }
+        
+        return result;
+    }
+    
+    /**
+     * This method creates external settings files for access from core librarys
+     * @param settingsName field name from database
+     * @param packageName name of package
+     * @param s settings from package
+     * @return true if file was successful written
+     * @throws Exception if we cannot write settings to directory
+     */
+    private boolean writeExternalSettings(String settingsName, String packageName, PrivacySettings s) throws Exception{
+	      // save settings to plain text file (for access from core libraries)
+    	
+		  PrivacyDebugger.d(TAG, "saveSettings - saving to plain text file");
+    	  mLock.writeLock().lock();
+	      try {
+	    	  File settingsPackageDir = new File("/data/system/privacy/" + packageName + "/");
+		      File systemLogsSettingFile = new File("/data/system/privacy/" + packageName + "/" + "/" + settingsName);
+	    	  //create all parent directories on the file path
+	    	  //settingsUidDir.mkdirs();
+	    	  //make the directory readable (requires it to be executable as well)
+	    	  //settingsUidDir.setReadable(true, false);
+	    	  //settingsUidDir.setExecutable(true, false);
+	    	  //make the parent directory readable (requires it to be executable as well)
+	          settingsPackageDir.mkdirs();
+	          settingsPackageDir.setReadable(true, false);
+	          settingsPackageDir.setExecutable(true, false);
+	          // create the setting files and make them readable
+	          systemLogsSettingFile.createNewFile();
+	          systemLogsSettingFile.setReadable(true, false);
+	          // write settings to files
+	          //PrivacyDebugger.d(TAG, "saveSettings - writing to file");
+	          OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(systemLogsSettingFile));
+	          //now decide which feature of setting we have to save
+	          if(settingsName.equals("systemLogsSetting"))
+	        	  writer.append(s.getSystemLogsSetting() + "");
+	          else if(settingsName.equals("ipTableProtectSetting"))
+	        	  writer.append(s.getIpTableProtectSetting() + "");
+	          writer.flush();
+	          writer.close();
+	          return true;
+	      } catch (IOException e) {
+	          // jump to catch block to avoid marking transaction as successful
+	    	  mLock.writeLock().unlock();
+	          throw new Exception("saveSettings - could not write settings to file", e);
+	          
+	      } finally {
+	    	  mLock.writeLock().unlock();
+	      }
+    }
+    
+    /**
+     * Deletes a settings entry from the DB
+     * @return true if settings were deleted successfully, false otherwise
+     */
+    public boolean deleteSettings(String packageName) {
+        boolean result = true;
+
+        announceConnection();
+        mLock.writeLock().lock();
+        watchDog.onBeginAuthorizedTransaction();
+        
+        SQLiteDatabase db = null;
+        Cursor c = null;
+        
+        try {
+        	db = getDatabase();
+            db.beginTransaction(); // make sure this ends up in a consistent state (DB and plain text files)
+            PrivacyDebugger.d(TAG, "deleteSettings - deleting database entry for " + packageName);
+            // try deleting contacts allowed entries; do not fail if deletion not possible
+            c = db.query(TABLE_SETTINGS, new String[] { "_id" }, "packageName=?", 
+                    new String[] { packageName }, null, null, null);
+            if (c != null && c.getCount() > 0 && c.moveToFirst()) {
+                int id = c.getInt(0);
+                db.delete(TABLE_ALLOWED_CONTACTS, "settings_id=?", new String[] { Integer.toString(id) });
+                c.close();
+            }
+            
+            if (db.delete(TABLE_SETTINGS, "packageName=?", new String[] { packageName }) == 0) {
+                PrivacyDebugger.e(TAG, "deleteSettings - database entry for " + packageName + " not found");
+                return false;
+            }
+            
+            // delete settings from plain text file (for access from core libraries)
+            File settingsPackageDir = new File("/data/system/privacy/" + packageName + "/");
+            File systemLogsSettingFile = new File("/data/system/privacy/" + packageName + "/systemLogsSetting");
+            // delete the setting files
+            systemLogsSettingFile.delete();
+            // delete the parent directories
+            if (settingsPackageDir.list() == null || settingsPackageDir.list().length == 0) settingsPackageDir.delete();
+            // mark DB transaction successful (commit the changes)
+            db.setTransactionSuccessful();
+            
+            mCache.deleteSettings(packageName);
+            
+        } catch (Exception e) {
+            result = false;
+            PrivacyDebugger.e(TAG, "deleteSettings - could not delete settings", e);
+        } finally {
+        	if(c != null)
+        		c.close();
+        	if(db != null)
+        		db.endTransaction();
+        	watchDog.onEndAuthorizedTransaction();
+        	mLock.writeLock().unlock();
+        	closeIdlingDatabase();
+        }
+        
+        return result;
+    }
+    
+    private Cursor query(SQLiteDatabase db, String table, String[] columns, String selection, 
+            String[] selectionArgs, String groupBy, String having, String orderBy, String limit) throws Exception {
+        Cursor c = null;
+        // make sure getting settings does not fail because of IllegalStateException (db already closed)
+        boolean success = false;
+        for (int i = 0; success == false && i < RETRY_QUERY_COUNT; i++) {
+            try {
+                if (c != null) 
+                	c.close();
+                c = db.query(table, columns, selection, selectionArgs, groupBy, having, orderBy, limit);
+                success = true;
+            } catch (IllegalStateException e) {
+                success = false;
+                closeIdlingDatabase();
+                announceConnection();
+                db = getDatabase();
+            } 
+        }
+        if (success == false) 
+        	throw new Exception("query - failed to execute query on the DB");
+        return c;
+    }
+    
+    private Cursor rawQuery(SQLiteDatabase db, String sql) throws Exception {
+        Cursor c = null;
+        // make sure getting settings does not fail because of IllegalStateException (db already closed)
+        boolean success = false;
+        for (int i = 0; success == false && i < RETRY_QUERY_COUNT; i++) {
+            try {
+                if (c != null) c.close();
+                c = db.rawQuery(sql, null);
+                success = true;
+            } catch (IllegalStateException e) {
+                success = false;
+                closeIdlingDatabase();
+                announceConnection();
+                db = getDatabase();
+            }
+        }
+        if (success == false) 
+        	throw new Exception("query - failed to execute query on the DB");
+        return c;
+    }
+    
+    /**
+     * Removes obsolete entries from the DB and file system. Should not be used in methods, which rely on the DB
+     * being open after this method has finished. It will close the DB if no other threads has increased
+     * the readingThread count.
+     * @return true if purge was successful, false otherwise.
+     */
+    public boolean purgeSettings() {
+        boolean result = true;
+        PrivacyDebugger.d(TAG, "purgeSettings - begin purging settings");
+
+        List<String> apps = new ArrayList<String>();
+        PackageManager pMan = context.getPackageManager();
+        List<ApplicationInfo> installedApps = pMan.getInstalledApplications(0);
+        for (ApplicationInfo appInfo : installedApps) { 
+            apps.add(appInfo.packageName);
+        }
+        
+        announceConnection();
+        mLock.writeLock().lock();
+        watchDog.onBeginAuthorizedTransaction();
+        
+        SQLiteDatabase db = null;
+        Cursor c = null;
+        try {
+        	
+        	File settingsDir = new File(SETTINGS_DIRECTORY);
+            for (File packageDir : settingsDir.listFiles()) {
+                String packageName = packageDir.getName();
+                PrivacyDebugger.d(TAG, "purgeSettings - checking package directory " + packageName);
+                
+                if (!apps.contains(packageName)) { // remove package dir if no such app installed
+                    PrivacyDebugger.d(TAG, "purgeSettings - deleting " + packageName);
+                    deleteRecursive(packageDir);
+                } 
+            }
+            
+            PrivacyDebugger.d(TAG, "purgeSettings - purging database");
+            // delete obsolete entries from DB and update outdated entries
+        	
+        	db = getDatabase();
+        	
+            c = query(db, TABLE_SETTINGS, new String[] {"packageName"}, null, null, null, null, null, null);
+            PrivacyDebugger.d(TAG, "purgeSettings - found " + c.getCount() + " entries in the DB");
+            List<String> appsInDb = new ArrayList<String>();
+            while (c.moveToNext()) {
+                String packageName = c.getString(0);
+                if (!apps.contains(packageName)) {
+                    deleteSettings(packageName);
+                } else {
+                    if (appsInDb.contains(packageName)) { // if duplicate entry, remove all duplicates and keep only one
+                        PrivacySettings pSetTmp = getSettings(packageName);
+                        deleteSettings(packageName);
+                        saveSettings(pSetTmp);
+                    } else {
+                        appsInDb.add(packageName);
+                    }
+                }
+            }
+        } catch (Exception e) {
+            PrivacyDebugger.e(TAG, "purgeSettings - purging DB failed.", e);
+            result = false;
+        } finally {
+            if (c != null) c.close();
+            watchDog.onEndAuthorizedTransaction();
+            mLock.writeLock().unlock();
+            closeIdlingDatabase();
+        }
+        return result;
+    }
+    
+    /**
+     * @deprecated
+     * @param fileOrDirectory
+     */
+    private void deleteRecursive(File fileOrDirectory) {
+        if (fileOrDirectory.isDirectory()) {
+            for (File child : fileOrDirectory.listFiles()) deleteRecursive(child);
+        }
+        fileOrDirectory.delete();
+    }
+    
+    private void createDatabase() {
+        PrivacyDebugger.i(TAG, "createDatabase - creating privacy database file");
+        watchDog.onBeginAuthorizedTransaction();
+        try {
+        	
+        	
+            SQLiteDatabase db = 
+                SQLiteDatabase.openDatabase(DATABASE_FILE, null, SQLiteDatabase.OPEN_READWRITE | 
+                        SQLiteDatabase.CREATE_IF_NECESSARY);
+            PrivacyDebugger.i(TAG, "createDatabase - creating privacy database");
+            db.execSQL(CREATE_TABLE_SETTINGS);
+            db.execSQL(CREATE_TABLE_ALLOWED_CONTACTS);
+            db.execSQL(CREATE_TABLE_MAP);
+            db.execSQL(INSERT_VERSION);
+            db.execSQL(INSERT_ENABLED);
+            db.execSQL(INSERT_NOTIFICATIONS_ENABLED);
+            PrivacyDebugger.d(TAG, "createDatabase - closing connection to privacy.db");
+            if (db != null && db.isOpen()) 
+            	db.close();
+            
+           
+        } catch (SQLException e) {
+            PrivacyDebugger.e(TAG, "createDatabase - failed to create privacy database", e);
+        } finally {
+        	watchDog.onEndAuthorizedTransaction();
+        }
+    }
+    
+
+    private void createSettingsDir() {
+        // create settings directory (for settings accessed from core libraries)
+        File settingsDir = new File("/data/system/privacy/");
+        settingsDir.mkdirs();
+        // make it readable for everybody
+        settingsDir.setReadable(true, false);
+        settingsDir.setExecutable(true, false);
+    }
+    
+	@Override
+	public void onUnauthorizedDatabaseAccess(int msg) {
+		
+		if(isFailSafeActive()) return; //prevents hammering -> only oneshot possible
+		//make sure you only call thread safe methods!
+		try {
+			setFailSafeMode(true);
+			watchDog.onBeginAuthorizedTransaction();
+			// inform user first
+			Intent intent = new Intent();
+			Intent backup = new Intent();
+			PrivacyDebugger.e(TAG,"recognized unauthorized databaseaccess. Reason: " + watchDog.msgToString(msg));
+			intent.setAction(PrivacySettingsManager.ACTION_FAIL_SAFE_MODE_TRIGGERED);
+			intent.putExtra(PrivacyWatchDog.MSG_WHAT_INT, msg);
+			intent.putExtra(PrivacyWatchDog.MSG_WHAT_STRING, watchDog.msgToString(msg));
+			context.sendBroadcast(intent, RECEIVE_FAIL_SAFE_TRIGGERED);
+			
+			// try to handle our self!
+			deleteCompleteSettings();
+			reinitAll();
+			//once again to be sure!
+			watchDog.startWatching();
+			//now try to recover
+			ArrayList<String> recovery = tryRecoverFromCache();
+			
+			//inform user!
+			if(recovery.isEmpty()) { 
+				backup.setAction(PrivacySettingsManager.ACTION_FAIL_SAFE_BACKUP_COMPLETE);
+				context.sendBroadcast(backup, RECEIVE_FAIL_SAFE_TRIGGERED);
+			} else {// some settings can't be saved, inform user about that!
+				backup.putStringArrayListExtra(PrivacyWatchDog.MSG_RECOVERY_FAIL_INFO, recovery);
+				backup.setAction(PrivacySettingsManager.ACTION_FAIL_SAFE_BACKUP_FAILED);
+				context.sendBroadcast(backup, RECEIVE_FAIL_SAFE_TRIGGERED);
+			}
+
+		} catch (Exception e) {
+			PrivacyDebugger.e(TAG,"something went totally wrong in onUnauthorizedDatabaseAccess()");
+		} finally {
+			watchDog.onEndAuthorizedTransaction();
+		}
+	}
+	
+	@Override
+	public void onWatchDogFinalize(int authorizedAccessInProgress) {
+		PrivacyDebugger.w(TAG,"got information that watchdog is dead, initiate a new one!");
+		watchDog = new PrivacyWatchDog(this, authorizedAccessInProgress);
+	}
+	
+	/**
+	 * Call this method at the end on every database access. It closes automatically the idling database.
+	 * Only call this method after you called watchDog.onEndAuthorized.....!
+	 */
+	private void closeIdlingDatabase() {
+		int threads = (dbThreads.get() > 0) ? dbThreads.decrementAndGet() : 0;
+		PrivacyDebugger.i(TAG,"amount of database threads: " + threads);
+		if(threads == 0 && db != null && db.isOpen()) {
+			watchDog.onBeginAuthorizedTransaction();
+			db.close();
+			watchDog.onEndAuthorizedTransaction();
+			PrivacyDebugger.i(TAG,"closed idling database, because amount of threads are 0");
+		}
+	}
+	
+	/**
+	 * Call this method right before you lock the read or write access
+	 */
+	private void announceConnection() {
+		int threads = dbThreads.incrementAndGet();
+		PrivacyDebugger.i(TAG, "current amount of dbThreads: " + threads);
+	}
+	
+	private synchronized SQLiteDatabase getDatabase() {
+		// create the database if it does not exist
+        if (!new File(DATABASE_FILE).exists()) createDatabase();
+
+		if (db == null || !db.isOpen() || db.isReadOnly()) {
+			PrivacyDebugger.i(TAG, "opening privacy database");
+            db = SQLiteDatabase.openDatabase(DATABASE_FILE, null, SQLiteDatabase.OPEN_READWRITE);
+        }
+		return db;
+	}
+
+	
+	
+	/**
+	 * 
+	 * @return true if failsafemode is active, false otherwise
+	 */
+	public boolean isFailSafeActive () {
+		return isFailSaveActive;
+	}
+	
+	
+	/**
+	 * Only call it after boot is ready and failSafeMode was not deactivated by user or to deactivate the fail safe mode
+	 * @param state true -> activates the failSafeMode, false -> deactivates the failSafeMode
+	 */
+	public void setFailSafeMode(boolean state) {
+		PrivacyDebugger.w(TAG,"setFailSafeMode() got a call, do you really want that?!");
+		isFailSaveActive = state;
+	}
+	
+    /**
+     * Fills the complete cache with all data from database
+     * Only call this method in constructor
+     */
+    private synchronized void fillPrivacyCache() {
+    	PrivacyDebugger.i(TAG, "on entry fillPrivacyCache()");
+        List<ApplicationInfo> apps = context.getPackageManager().getInstalledApplications(0);
+        for (ApplicationInfo appInfo : apps) { 
+        	PrivacyDebugger.i(TAG,"filling cache for package: " + appInfo.packageName);
+            getSettings(appInfo.packageName, true); //only call it 
+        }
+        PrivacyDebugger.i(TAG,"on exit fillPrivacyCache()");
+    }
+    
+    /**
+     * Deletes the given folder or files and all sub-directories with files
+     * @param path path t
+     */
+    private void removeFiles(String path) {
+        File file = new File(path);
+        PrivacyDebugger.w(TAG, "deleting now file(s) or folder(s): " + file.getAbsolutePath());
+        if (file.exists()) {
+            String cmd = "rm -r " + path;
+            Runtime runtime = Runtime.getRuntime();
+            try {
+                runtime.exec(cmd);
+                PrivacyDebugger.i(TAG, "deleted file(s) or folder(s) successful");
+            } catch (IOException e) { 
+            	PrivacyDebugger.e(TAG, "Got IOException while trying to delete file(s) or folder(s)", e);
+            } catch (Exception e) {
+            	PrivacyDebugger.e(TAG, "Got Exception while trying to delete file(s) or folder(s)", e);
+            }
+        } else {
+        	PrivacyDebugger.e(TAG,"can't delete file(s) or folder(s) for path: " + file.getAbsolutePath() + " because it doesn't exists");
+        }
+    }
+    
+    /**
+     * Deletes all PrivacySettings files:
+     * 		- Database 
+     * 		- Database journal file
+     *  	- Settingsdirectory
+     *  It also stops monitoring on privacy.db (for watchDog)
+     */
+    private void deleteCompleteSettings() {
+    	if(watchDog != null) 
+    		watchDog.stopWatching();
+    	removeFiles(DATABASE_JOURNAL_FILE);
+    	removeFiles(DATABASE_FILE);
+    	removeFiles(SETTINGS_DIRECTORY);
+    }
+    
+    /**
+     * Recovers all settings from current cache to database. Call this method 
+     * if database base is empty only!
+     * @return true, if <b>all</b> settings have been successful saved, false otherwise
+     */
+    private ArrayList<String> tryRecoverFromCache() {
+    	ArrayList<String> output = new ArrayList<String>();
+    	announceConnection();
+    	mLock.writeLock().lock();
+    	watchDog.onBeginAuthorizedTransaction();
+    	mCache.markAllAsNewEntry();
+    	PrivacyDebugger.i(TAG,"now trying to recover settings from cache!");
+    	try {
+    		// TODO: speed this up by leaving the database open!!
+    		ArrayList<PrivacySettings> settings = mCache.getAllSetings();
+    		for(PrivacySettings insertion : settings) {
+    			if(!saveSettings(insertion)) {
+    				output.add(insertion.getPackageName());
+    				PrivacyDebugger.e(TAG,"restore failed for package: " + insertion.getPackageName());
+    			} 
+    		}
+    		mCache.removeAll();
+    		if(settings.size() == output.size()) {
+    			PrivacyDebugger.e(TAG, "nothing can't be restore :-! ?");
+    		} else {
+    			fillPrivacyCache();
+    		}
+    		
+    	} catch (Exception e) {
+    		PrivacyDebugger.e(TAG,"something went wrong while trying to recover settings from cache after unauthorized database access!");
+    		
+    	} finally {
+    		if(output.isEmpty())
+    			PrivacyDebugger.i(TAG,"successful recovered ALL settings from cache");
+    		else 
+    			PrivacyDebugger.e(TAG, "wasn't able to recover all settings?!");
+    		watchDog.onEndAuthorizedTransaction();
+    		mLock.writeLock().unlock();
+    		closeIdlingDatabase();
+    	}
+    	return output;
+    }
+    
+    /**
+     * Reinit the whole set (privacy db, privacy settings dir, ...)
+     * Only call this method after you called the deleteCompleteSettings() method!
+     * this also triggers the watchdog to watch on privacy.db
+     */
+    private void reinitAll() {
+    	boolean canWrite = new File("/data/system/").canWrite();
+    	PrivacyDebugger.i(TAG, "called reinitAll() - canWrite: " + canWrite);
+    	if (canWrite) {
+    		PrivacyDebugger.i(TAG,"we're able to write, create complete new set now");
+        	announceConnection();
+        	mLock.writeLock().lock();
+        	watchDog.onBeginAuthorizedTransaction();
+        	try {
+        		if (!new File(DATABASE_FILE).exists()) 
+        			createDatabase();
+        		
+        		if(watchDog != null)
+        			watchDog.startWatching();
+        		
+                if (!new File(SETTINGS_DIRECTORY).exists()) 
+                	createSettingsDir();
+                
+                int currentVersion = getDbVersion();
+                PrivacyDebugger.d(TAG, "PrivacyPersistenceAdapter - current DB version: " + currentVersion);
+                
+                if (currentVersion < DATABASE_VERSION) 
+                	upgradeDatabase(currentVersion);
+
+        	} catch(Exception e) {
+        		PrivacyDebugger.e(TAG, "got exception while trying to create database and/or settingsDirectories for reinitializing!");
+        	} finally {
+        		PrivacyDebugger.i(TAG,"successful reinitialized the whole set");
+        		watchDog.onEndAuthorizedTransaction();
+        		mLock.writeLock().unlock();
+        		closeIdlingDatabase();
+        	}
+        }
+    }
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/PrivacySettings.aidl pang/frameworks/base/privacy/java/android/privacy/PrivacySettings.aidl
--- /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/PrivacySettings.aidl	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/base/privacy/java/android/privacy/PrivacySettings.aidl	2013-01-02 22:11:58.000000000 +0545
@@ -0,0 +1,4 @@
+package android.privacy;
+
+/** {@hide} */
+parcelable PrivacySettings;
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/PrivacySettings.java pang/frameworks/base/privacy/java/android/privacy/PrivacySettings.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/PrivacySettings.java	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/base/privacy/java/android/privacy/PrivacySettings.java	2013-02-01 21:48:04.000000000 +0545
@@ -0,0 +1,1177 @@
+package android.privacy;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.Log;
+
+import java.math.BigDecimal;
+import java.util.List;
+import java.util.Random;
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+/**
+ * Holds privacy settings for access to all private data types for a single application
+ * @author Svyatoslav Hresyk; modified & improved by CollegeDev (Stefan. T)
+ * {@hide} 
+ */
+public final class PrivacySettings implements Parcelable {
+    
+    /**
+     * Real value, provided by the unmodified Android framework.
+     */
+    public static final byte REAL = 0;
+    
+    /**
+     * Empty or unavailable, depending on setting type. For String settings, it is
+     * setter method caller's responsibility to make sure that the corresponding 
+     * setting field will contain an empty String.
+     */
+    public static final byte EMPTY = 1;
+    
+    /**
+     * Custom specified output, appropriate for relevant setting. For String settings, 
+     * it is setter method caller's responsibility to make sure that the corresponding 
+     * setting field will contain a custom String.
+     */
+    public static final byte CUSTOM = 2;
+    
+    /**
+     * Random output, appropriate for relevant setting. When this option is set, the
+     * corresponding getter methods will generate appropriate random values automatically.
+     * 
+     * Device ID: a random string consisting of 15 numeric digits preceded by a "+"
+     * Line1Number: a random string consisting of 13 numeric digits
+     */
+    public static final byte RANDOM = 3;
+    
+    /**
+     * Indicates database connection errors, and all kind of that. If this option is set,
+     * the user will get information that something went wrong and the default deny Settings
+     * grab.
+     */
+    public static final byte ERROR = 4;
+    
+    public static final byte SETTING_NOTIFY_OFF = 0;
+    public static final byte SETTING_NOTIFY_ON = 1;
+    
+    /** used to create random android ID*/
+    public static final String[] ID_PATTERN = { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"};
+    
+    // constants for identification of data types transmitted in the notification intent
+    public static final String DATA_DEVICE_ID = "deviceID";
+    public static final String DATA_LINE_1_NUMBER = "line1Number";
+    public static final String DATA_LOCATION_GPS = "locationGPS";
+    public static final String DATA_LOCATION_NETWORK = "locationNetwork";
+    public static final String DATA_NETWORK_INFO_CURRENT = "networkInfoCurrent";
+    public static final String DATA_NETWORK_INFO_SIM = "networkInfoSIM";
+    public static final String DATA_SIM_SERIAL = "simSerial";
+    public static final String DATA_SUBSCRIBER_ID = "subscriberID";
+    public static final String DATA_ACCOUNTS_LIST = "accountsList";
+    public static final String DATA_AUTH_TOKENS = "authTokens";
+    public static final String DATA_OUTGOING_CALL = "outgoingCall";
+    public static final String DATA_INCOMING_CALL = "incomingCall";
+    public static final String DATA_CONTACTS = "contacts";
+    public static final String DATA_CALENDAR = "calendar";
+    public static final String DATA_MMS = "mms";
+    public static final String DATA_SMS = "sms";
+    public static final String DATA_MMS_SMS = "mmsSms";
+    public static final String DATA_CALL_LOG = "callLog";
+    public static final String DATA_BOOKMARKS = "bookmarks";
+    public static final String DATA_SYSTEM_LOGS = "systemLogs";
+    public static final String DATA_INTENT_BOOT_COMPLETED = "intentBootCompleted";
+//    public static final String DATA_EXTERNAL_STORAGE = "externalStorage";
+    public static final String DATA_CAMERA = "camera";
+    public static final String DATA_RECORD_AUDIO = "recordAudio";
+    public static final String DATA_SMS_SEND = "SmsSend";
+    public static final String DATA_PHONE_CALL = "phoneCall";
+    public static final String DATA_ANDROID_ID = "android_id";
+    public static final String DATA_ICC_ACCESS = "iccAccess";
+    public static final String DATA_WIFI_INFO = "wifiInfo";
+    public static final String DATA_IP_TABLES = "iptables";
+    public static final String DATA_SWITCH_CONNECTIVITY = "switchconnectivity";
+    public static final String DATA_SEND_MMS = "sendMms";
+    public static final String DATA_SWITCH_WIFI_STATE = "switchWifiState";
+    
+    
+    /**
+     * One of three possible option which declare how PDroid handles if
+     * we are not able to get current PrivacySettings. 
+     * Empty means that if we can't get settings for the application for several reason, 
+     * we will return a PrivacySettings object where all Settings are empty.
+     */
+    public static final int DEFAULT_DENY_EMPTY = -1;
+    /**
+     * One of three possible option which declare how PDroid handles if
+     * we are not able to get current PrivacySettings. 
+     * Real means that if we can't get settings for the application for several reason, 
+     * we will return a PrivacySettings object where all Settings are real.
+     */
+    public static final int DEFAULT_DENY_REAL = -2;
+    /**
+     * One of three possible option which declare how PDroid handles if
+     * we are not able to get current PrivacySettings. 
+     * Random means that if we can't get settings for the application for several reason, 
+     * we will return a PrivacySettings object where all Settings are random.
+     */
+    public static final int DEFAULT_DENY_RANDOM = -3;
+    
+    /**
+     * Represents the current default deny mode. Just change it to your demanded mode if you like.
+     */
+    public static final int CURRENT_DEFAULT_DENY_MODE = DEFAULT_DENY_EMPTY;
+    
+    /**
+     * The package name of the default deny object. With the package name you're able to check if it is 
+     * a default deny object or a real settings object.
+     */
+    public static final String DEFAULT_DENY_OBJECT_PACKAGE_NAME = "default.deny.object";
+    
+    /**
+     * The package name of the fail save mode object. With the package name you're able to check if it is 
+     * a fail save settings object or a real settings object.
+     */
+    public static final String FAIL_SAFE_MODE_OBJECT_PACKAGE_NAME = "fail.safe.object";
+    
+    
+    // Database entry ID
+    private final Integer _id;
+    
+    // Application identifiers
+    private String packageName;
+    private int uid;
+    
+    //
+    // Privacy settings
+    //
+    
+    private byte deviceIdSetting;
+    private String deviceId;
+    
+    // Phone and Voice Mailbox Number
+    private byte line1NumberSetting; 
+    private String line1Number;
+    
+    private byte locationGpsSetting;
+    private String locationGpsLat;
+    private String locationGpsLon;
+    private byte locationNetworkSetting;
+    private String locationNetworkLat;
+    private String locationNetworkLon;
+    
+    // CountryIso, Operator Code, Operator Name
+    private byte networkInfoSetting;
+    private byte simInfoSetting;
+    
+    private byte simSerialNumberSetting;
+    private String simSerialNumber;
+    private byte subscriberIdSetting;
+    private String subscriberId;
+    
+    private byte accountsSetting;
+    private byte accountsAuthTokensSetting;
+    private byte outgoingCallsSetting;
+    private byte incomingCallsSetting;
+    
+    private byte contactsSetting;
+    private byte calendarSetting;
+    private byte mmsSetting;
+    private byte smsSetting;
+    private byte callLogSetting;
+    private byte bookmarksSetting; // browser bookmarks and history
+    
+    private byte systemLogsSetting;
+    
+    private byte notificationSetting;
+    
+    private byte intentBootCompletedSetting;
+//    private byte externalStorageSetting;
+    private byte cameraSetting;
+    private byte recordAudioSetting;
+    private byte smsSendSetting;
+    private byte phoneCallSetting;
+
+    private byte ipTableProtectSetting;
+    private byte iccAccessSetting;
+    private byte addOnManagementSetting;
+    
+    private byte androidIdSetting;
+    private String androidID;
+    
+    private byte wifiInfoSetting;
+    
+    private byte switchConnectivitySetting;
+    
+    private byte sendMmsSetting;
+    
+    private byte forceOnlineState; //used to fake online state
+    
+    private byte switchWifiStateSetting;
+   
+
+	private int[] allowedContacts;
+	
+	/**
+	 * Constructor to set all Values REAL
+	 * @param _id id in database
+	 * @param packageName	packagename of the app
+	 * @param uid uid of application
+	 * {@hide}
+	 */
+    public PrivacySettings(Integer _id, String packageName, int uid) {
+        this._id = _id;
+        
+        this.packageName = packageName;
+        this.uid = uid;
+        
+        this.deviceIdSetting = REAL;
+        this.deviceId = null;
+        this.line1NumberSetting = REAL;
+        this.line1Number = null;
+        this.locationGpsSetting = REAL;
+        this.locationGpsLat = null;
+        this.locationGpsLon = null;
+        this.locationNetworkSetting = REAL;
+        this.locationNetworkLat = null;
+        this.locationNetworkLon = null;
+        this.networkInfoSetting = REAL;
+        this.simInfoSetting = REAL;
+        this.simSerialNumberSetting = REAL;
+        this.simSerialNumber = null;
+        this.subscriberIdSetting = REAL;
+        this.subscriberId = null;
+        this.accountsSetting = REAL;
+        this.accountsAuthTokensSetting = REAL;
+        this.outgoingCallsSetting = REAL;
+        this.incomingCallsSetting = REAL;
+        this.contactsSetting = REAL;
+        this.calendarSetting = REAL;
+        this.mmsSetting = REAL;
+        this.smsSetting = REAL;
+        this.callLogSetting = REAL;
+        this.bookmarksSetting = REAL;
+        this.systemLogsSetting = REAL;
+        this.notificationSetting = SETTING_NOTIFY_OFF;
+        this.intentBootCompletedSetting = REAL;
+//        this.externalStorageSetting = REAL;
+        this.cameraSetting = REAL; 
+        this.recordAudioSetting = REAL;
+        this.allowedContacts = null;
+        this.smsSendSetting = REAL;
+        this.phoneCallSetting = REAL;
+        this.ipTableProtectSetting = REAL;
+        this.iccAccessSetting = REAL;
+        this.addOnManagementSetting = EMPTY;
+        this.androidIdSetting = REAL;
+        this.androidID = null;
+        this.wifiInfoSetting = REAL;
+        this.switchConnectivitySetting = REAL;
+        this.sendMmsSetting = REAL;
+        this.forceOnlineState = EMPTY;
+        this.switchWifiStateSetting = REAL;
+    }
+    
+    /**
+     * Constructor for two possibilities:<br>
+     * 1. pass allEmpty = true for set all values to empty
+     * 2. pass allEmpty = false for set all possible values to RANDOM 
+     * @param _id id in database
+     * @param packageName packagename of application
+     * @param uid the uid of application
+     * @param allEmpty see description above
+     * {@hide}
+     */
+    public PrivacySettings(Integer _id, String packageName, int uid, boolean allEmpty) {
+        this._id = _id;
+        
+        this.packageName = packageName;
+        this.uid = uid;
+        if(allEmpty){
+        	this.deviceIdSetting = EMPTY;
+	        this.deviceId = null;
+	        this.line1NumberSetting = EMPTY;
+	        this.line1Number = null;
+	        this.locationGpsSetting = EMPTY;
+	        this.locationGpsLat = null;
+	        this.locationGpsLon = null;
+	        this.locationNetworkSetting = EMPTY;
+	        this.locationNetworkLat = null;
+	        this.locationNetworkLon = null;
+	        this.networkInfoSetting = EMPTY;
+	        this.simInfoSetting = EMPTY;
+	        this.simSerialNumberSetting = EMPTY;
+	        this.simSerialNumber = null;
+	        this.subscriberIdSetting = EMPTY;
+	        this.subscriberId = null;
+	        this.accountsSetting = EMPTY;
+	        this.accountsAuthTokensSetting = EMPTY;
+	        this.outgoingCallsSetting = EMPTY;
+	        this.incomingCallsSetting = EMPTY;
+	        this.contactsSetting = EMPTY;
+	        this.calendarSetting = EMPTY;
+	        this.mmsSetting = EMPTY;
+	        this.smsSetting = EMPTY;
+	        this.callLogSetting = EMPTY;
+	        this.bookmarksSetting = EMPTY;
+	        this.systemLogsSetting = EMPTY;
+	        this.notificationSetting = SETTING_NOTIFY_OFF;
+	        this.intentBootCompletedSetting = EMPTY;
+	//        this.externalStorageSetting = REAL;
+	        this.cameraSetting = EMPTY;
+	        this.recordAudioSetting = EMPTY;
+	        this.allowedContacts = null;
+	        this.smsSendSetting = EMPTY;
+	        this.phoneCallSetting = EMPTY;
+	        this.ipTableProtectSetting = EMPTY;
+	        this.iccAccessSetting = EMPTY;
+	        this.addOnManagementSetting = EMPTY;
+	        this.androidIdSetting = EMPTY;
+	        this.androidID = null;
+	        this.wifiInfoSetting = EMPTY;
+	        this.switchConnectivitySetting = EMPTY;
+	        this.sendMmsSetting = EMPTY;
+	        this.forceOnlineState = REAL;
+	        this.switchWifiStateSetting = EMPTY;
+        } else {
+        	this.deviceIdSetting = RANDOM;
+	        this.deviceId = null;
+	        this.line1NumberSetting = RANDOM;
+	        this.line1Number = null;
+	        this.locationGpsSetting = RANDOM;
+	        this.locationGpsLat = null;
+	        this.locationGpsLon = null;
+	        this.locationNetworkSetting = RANDOM;
+	        this.locationNetworkLat = null;
+	        this.locationNetworkLon = null;
+	        this.networkInfoSetting = EMPTY;
+	        this.simInfoSetting = EMPTY;
+	        this.simSerialNumberSetting = RANDOM;
+	        this.simSerialNumber = null;
+	        this.subscriberIdSetting = RANDOM;
+	        this.subscriberId = null;
+	        this.accountsSetting = EMPTY;
+	        this.accountsAuthTokensSetting = EMPTY;
+	        this.outgoingCallsSetting = EMPTY;
+	        this.incomingCallsSetting = EMPTY;
+	        this.contactsSetting = EMPTY;
+	        this.calendarSetting = EMPTY;
+	        this.mmsSetting = EMPTY;
+	        this.smsSetting = EMPTY;
+	        this.callLogSetting = EMPTY;
+	        this.bookmarksSetting = EMPTY;
+	        this.systemLogsSetting = EMPTY;
+	        this.notificationSetting = SETTING_NOTIFY_OFF;
+	        this.intentBootCompletedSetting = EMPTY;
+	//        this.externalStorageSetting = REAL;
+	        this.cameraSetting = EMPTY;
+	        this.recordAudioSetting = EMPTY;
+	        this.allowedContacts = null;
+	        this.smsSendSetting = EMPTY;
+	        this.phoneCallSetting = EMPTY;
+	        this.ipTableProtectSetting = EMPTY;
+	        this.iccAccessSetting = EMPTY;
+	        this.addOnManagementSetting = EMPTY;
+	        this.androidIdSetting = RANDOM;
+	        this.androidID = null;
+	        this.wifiInfoSetting = EMPTY;
+	        this.switchConnectivitySetting = EMPTY;
+	        this.sendMmsSetting = EMPTY;
+	        this.forceOnlineState = REAL;
+	        this.switchWifiStateSetting = EMPTY;
+        }
+    }
+    
+    
+    public PrivacySettings(Integer id, String packageName, int uid, byte deviceIdSetting, String deviceId,
+            byte line1NumberSetting, String line1Number, byte locationGpsSetting, String locationGpsLat,
+            String locationGpsLon, byte locationNetworkSetting, String locationNetworkLat, 
+            String locationNetworkLon, byte networkInfoSetting, byte simInfoSetting, byte simSerialNumberSetting,
+            String simSerialNumber, byte subscriberIdSetting, String subscriberId, byte accountsSetting, 
+            byte accountsAuthTokensSetting, byte outgoingCallsSetting, byte incomingCallsSetting, byte contactsSetting,
+            byte calendarSetting, byte mmsSetting, byte smsSetting, byte callLogSetting, byte bookmarksSetting, 
+            byte systemLogsSetting, byte externalStorageSetting, byte cameraSetting, byte recordAudioSetting, 
+            byte notificationSetting, byte intentBootCompletedSetting, int[] allowedContacts, byte smsSendSetting, byte phoneCallSetting, byte ipTableProtectSetting,
+            byte iccAccessSetting, byte addOnManagementSetting, byte androidIdSetting, String androidID, byte wifiInfoSetting, byte switchConnectivitySetting, byte sendMmsSetting,
+            byte forceOnlineState, byte switchWifiStateSetting) {
+        this._id = id;
+        
+        this.packageName = packageName;
+        this.uid = uid;
+        
+        this.deviceIdSetting = deviceIdSetting;
+        this.deviceId = deviceId;
+        this.line1NumberSetting = line1NumberSetting;
+        this.line1Number = line1Number;
+        this.locationGpsSetting = locationGpsSetting;
+        this.locationGpsLat = locationGpsLat;
+        this.locationGpsLon = locationGpsLon;
+        this.locationNetworkSetting = locationNetworkSetting;
+        this.locationNetworkLat = locationNetworkLat;
+        this.locationNetworkLon = locationNetworkLon;
+        this.networkInfoSetting = networkInfoSetting;
+        this.simInfoSetting = simInfoSetting;
+        this.simSerialNumberSetting = simSerialNumberSetting;
+        this.simSerialNumber = simSerialNumber;
+        this.subscriberIdSetting = subscriberIdSetting;
+        this.subscriberId = subscriberId;
+        this.accountsSetting = accountsSetting;
+        this.accountsAuthTokensSetting = accountsAuthTokensSetting;
+        this.outgoingCallsSetting = outgoingCallsSetting;
+        this.incomingCallsSetting = incomingCallsSetting;
+        this.contactsSetting = contactsSetting;
+        this.calendarSetting = calendarSetting;
+        this.mmsSetting = mmsSetting;
+        this.smsSetting = smsSetting;
+        this.callLogSetting = callLogSetting;
+        this.bookmarksSetting = bookmarksSetting;
+        this.systemLogsSetting = systemLogsSetting;
+        this.notificationSetting = notificationSetting;
+        this.intentBootCompletedSetting = intentBootCompletedSetting;
+//        this.externalStorageSetting = externalStorageSetting;
+        this.cameraSetting = cameraSetting;
+        this.recordAudioSetting = recordAudioSetting;
+        this.allowedContacts = allowedContacts;
+        this.smsSendSetting = smsSendSetting;
+        this.phoneCallSetting = phoneCallSetting;
+        this.ipTableProtectSetting = ipTableProtectSetting;
+        this.iccAccessSetting = iccAccessSetting;
+        this.addOnManagementSetting = addOnManagementSetting;
+        this.androidIdSetting = androidIdSetting;
+        this.androidID = androidID;
+        this.wifiInfoSetting = wifiInfoSetting;
+        this.switchConnectivitySetting = switchConnectivitySetting;
+        this.sendMmsSetting = sendMmsSetting;
+        this.forceOnlineState = forceOnlineState;
+        this.switchWifiStateSetting = switchWifiStateSetting;
+    }
+    
+    public byte getSwitchWifiStateSetting() {
+		return switchWifiStateSetting;
+	}
+
+	public void setSwitchWifiStateSetting(byte switchWifiStateSetting) {
+		this.switchWifiStateSetting = switchWifiStateSetting;
+	}
+    
+    public byte getForceOnlineState() {
+		return forceOnlineState;
+	}
+
+	public void setForceOnlineState(byte forceOnlineState) {
+		this.forceOnlineState = forceOnlineState;
+	}
+
+	public byte getSendMmsSetting() {
+		return sendMmsSetting;
+	}
+
+	public void setSendMmsSetting(byte sendMmsSetting) {
+		this.sendMmsSetting = sendMmsSetting;
+	}
+
+	public byte getSwitchConnectivitySetting() {
+		return switchConnectivitySetting;
+	}
+
+	public void setSwitchConnectivitySetting(byte switchConnectivitySetting) {
+		this.switchConnectivitySetting = switchConnectivitySetting;
+	}
+    
+    public byte getAndroidIdSetting() {
+		return androidIdSetting;
+	}
+
+	public void setAndroidIdSetting(byte androidIdSetting) {
+		this.androidIdSetting = androidIdSetting;
+	}
+	
+	/**
+	 * @return random ID, constant fake id or null
+	 */
+	public String getAndroidID() {
+		if(androidIdSetting == EMPTY) return "q4a5w896ay21dr46"; //we can not pull out empty android id, because we get bootlops then
+		if(androidIdSetting == RANDOM) {
+			Random value = new Random();
+			StringBuilder localBuilder = new StringBuilder();
+			for(int i = 0; i < ID_PATTERN.length; i++)
+				localBuilder.append(ID_PATTERN[value.nextInt(ID_PATTERN.length-1)]);
+			return localBuilder.toString();
+		}
+		return androidID;
+	}
+	
+	public byte getWifiInfoSetting() {
+		return wifiInfoSetting;
+	}
+
+	public void setWifiInfoSetting(byte wifiInfoSetting) {
+		this.wifiInfoSetting = wifiInfoSetting;
+	}
+
+	public void setAndroidID(String androidID) {
+		this.androidID = androidID;
+	}
+    
+    public byte getIpTableProtectSetting() {
+		return ipTableProtectSetting;
+	}
+
+	public void setIpTableProtectSetting(byte ipTableProtectSetting) {
+		this.ipTableProtectSetting = ipTableProtectSetting;
+	}
+
+	public byte getIccAccessSetting() {
+		return iccAccessSetting;
+	}
+
+	public void setIccAccessSetting(byte iccAccessSetting) {
+		this.iccAccessSetting = iccAccessSetting;
+	}
+
+	public byte getAddOnManagementSetting() {
+		return addOnManagementSetting;
+	}
+
+	public void setAddOnManagementSetting(byte addOnManagementSetting) {
+		this.addOnManagementSetting = addOnManagementSetting;
+	}
+    public byte getSmsSendSetting(){
+	return smsSendSetting;
+    }
+
+    public void setSmsSendSetting(byte smsSendSetting){
+	this.smsSendSetting = smsSendSetting;
+    }
+
+    public byte getPhoneCallSetting(){
+	return phoneCallSetting;
+    }
+
+    public void setPhoneCallSetting(byte phoneCallSetting){
+	this.phoneCallSetting = phoneCallSetting;
+    }
+
+    public byte getRecordAudioSetting(){
+	return recordAudioSetting;
+    }
+
+    public void setRecordAudioSetting(byte recordAudioSetting){
+	this.recordAudioSetting = recordAudioSetting;
+    }
+
+    public byte getCameraSetting(){
+	return cameraSetting;
+    }
+
+    public void setCameraSetting(byte cameraSetting){
+	this.cameraSetting = cameraSetting;
+    }
+
+    public Integer get_id() {
+        return _id;
+    }
+
+    public String getPackageName() {
+        return packageName;
+    }
+    
+    public void setPackageName(String packageName) {
+        this.packageName = packageName;
+    }
+    
+    public int getUid() {
+        return uid;
+    }
+
+    public void setUid(int uid) {
+        this.uid = uid;
+    }
+
+    public byte getDeviceIdSetting() {
+        return deviceIdSetting;
+    }
+
+    public void setDeviceIdSetting(byte deviceIdSetting) {
+        this.deviceIdSetting = deviceIdSetting;
+    }
+
+    public String getDeviceId() {
+        if (deviceIdSetting == EMPTY) return "";
+        if (deviceIdSetting == RANDOM) {
+            Random rnd = new Random();
+            String rndId = Math.abs(rnd.nextLong()) + "";
+	    if(rndId.length() > 15)
+            	return rndId.substring(0, 15);
+	    else{
+		for(int i = rndId.length(); i <= 16; i++)
+			rndId += rnd.nextInt(9);
+		return rndId.substring(0, 15);
+	    }
+            //return rndId.substring(0, 15);
+        }
+        return deviceId;
+    }
+
+    public void setDeviceId(String deviceId) {
+        this.deviceId = deviceId;
+    }
+
+    public byte getLine1NumberSetting() {
+        return line1NumberSetting;
+    }
+
+    public void setLine1NumberSetting(byte line1NumberSetting) {
+        this.line1NumberSetting = line1NumberSetting;
+    }
+
+    public String getLine1Number() {
+        if (line1NumberSetting == EMPTY) return "";
+        if (line1NumberSetting == RANDOM) {
+            Random rnd = new Random();
+            String rndId = "+" + Math.abs(rnd.nextLong()) + "";
+	    if(rndId.length() > 13)
+            	return rndId.substring(0, 13);
+	    else{
+		for(int i = rndId.length(); i <= 14; i++)
+			rndId += rnd.nextInt(9);
+		return rndId.substring(0, 13);
+	    }
+            //return rndId.substring(0, 13);
+        }
+        return line1Number;
+    }
+
+    public void setLine1Number(String line1Number) {
+        this.line1Number = line1Number;
+    }
+
+    public byte getLocationGpsSetting() {
+        return locationGpsSetting;
+    }
+
+    public void setLocationGpsSetting(byte locationGpsSetting) {
+        this.locationGpsSetting = locationGpsSetting;
+    }
+    
+    public String getLocationGpsLat() {
+        if (locationGpsSetting == EMPTY) return "";
+        if (locationGpsSetting == RANDOM) return getRandomLat();
+        return locationGpsLat;
+    }
+
+    public void setLocationGpsLat(String locationGpsLat) {
+        this.locationGpsLat = locationGpsLat;
+    }
+
+    public String getLocationGpsLon() {
+        if (locationGpsSetting == EMPTY) return "";        
+        if (locationGpsSetting == RANDOM) return getRandomLon();
+        return locationGpsLon;
+    }
+
+    public void setLocationGpsLon(String locationGpsLon) {
+        this.locationGpsLon = locationGpsLon;
+    }
+
+    public byte getLocationNetworkSetting() {
+        return locationNetworkSetting;
+    }
+
+    public void setLocationNetworkSetting(byte locationNetworkSetting) {
+        this.locationNetworkSetting = locationNetworkSetting;
+    }
+
+    public String getLocationNetworkLat() {
+        if (locationNetworkSetting == EMPTY) return "";
+        if (locationNetworkSetting == RANDOM) return getRandomLat();  
+        return locationNetworkLat;
+    }
+
+    public void setLocationNetworkLat(String locationNetworkLat) {
+        this.locationNetworkLat = locationNetworkLat;
+    }
+
+    public String getLocationNetworkLon() {
+        if (locationNetworkSetting == EMPTY) return "";
+        if (locationNetworkSetting == RANDOM) return getRandomLon();
+        return locationNetworkLon;
+    }
+
+    public void setLocationNetworkLon(String locationNetworkLon) {
+        this.locationNetworkLon = locationNetworkLon;
+    }
+
+    public byte getNetworkInfoSetting() {
+        return networkInfoSetting;
+    }
+
+    public void setNetworkInfoSetting(byte networkInfoSetting) {
+        this.networkInfoSetting = networkInfoSetting;
+    }
+
+    public byte getSimInfoSetting() {
+        return simInfoSetting;
+    }
+
+    public void setSimInfoSetting(byte simInfoSetting) {
+        this.simInfoSetting = simInfoSetting;
+    }
+
+    public byte getSimSerialNumberSetting() {
+        return simSerialNumberSetting;
+    }
+
+    public void setSimSerialNumberSetting(byte simSerialNumberSetting) {
+        this.simSerialNumberSetting = simSerialNumberSetting;
+    }
+
+    public String getSimSerialNumber() {
+        if (simSerialNumberSetting == EMPTY) return "";
+        if (simSerialNumberSetting == RANDOM) {
+            Random rnd = new Random();
+            return Math.abs(rnd.nextLong()) + "";
+        }
+        return simSerialNumber;
+    }
+
+    public void setSimSerialNumber(String simSerialNumber) {
+        this.simSerialNumber = simSerialNumber;
+    }
+
+    public byte getSubscriberIdSetting() {
+        return subscriberIdSetting;
+    }
+
+    public void setSubscriberIdSetting(byte subscriberIdSetting) {
+        this.subscriberIdSetting = subscriberIdSetting;
+    }
+
+    public String getSubscriberId() {
+        if (subscriberIdSetting == EMPTY) return "";
+        if (subscriberIdSetting == RANDOM) {
+            Random rnd = new Random();
+            String rndId = Math.abs(rnd.nextLong()) + "";
+	    if(rndId.length() > 15)
+            	return rndId.substring(0, 15);
+	    else{
+		for(int i = rndId.length(); i <= 16; i++)
+			rndId += rnd.nextInt(9);
+		return rndId.substring(0, 15);
+	    }
+        }
+        return subscriberId;
+    }
+
+    public void setSubscriberId(String subscriberId) {
+        this.subscriberId = subscriberId;
+    }
+
+    public byte getAccountsSetting() {
+        return accountsSetting;
+    }
+
+    public void setAccountsSetting(byte accountsSetting) {
+        this.accountsSetting = accountsSetting;
+    }
+
+    public byte getAccountsAuthTokensSetting() {
+        return accountsAuthTokensSetting;
+    }
+
+    public void setAccountsAuthTokensSetting(byte accountsAuthTokensSetting) {
+        this.accountsAuthTokensSetting = accountsAuthTokensSetting;
+    }
+
+    public byte getOutgoingCallsSetting() {
+        return outgoingCallsSetting;
+    }
+
+    public void setOutgoingCallsSetting(byte outgoingCallsSetting) {
+        this.outgoingCallsSetting = outgoingCallsSetting;
+    }
+    
+    public byte getIncomingCallsSetting() {
+        return incomingCallsSetting;
+    }
+    
+    public void setIncomingCallsSetting(byte incomingCallsSetting) {
+        this.incomingCallsSetting = incomingCallsSetting;
+    }
+
+    public byte getContactsSetting() {
+        return contactsSetting;
+    }
+
+    public void setContactsSetting(byte contactsSetting) {
+        this.contactsSetting = contactsSetting;
+    }
+
+    public byte getCalendarSetting() {
+        return calendarSetting;
+    }
+
+    public void setCalendarSetting(byte calendarSetting) {
+        this.calendarSetting = calendarSetting;
+    }
+
+    public byte getMmsSetting() {
+        return mmsSetting;
+    }
+
+    public void setMmsSetting(byte mmsSetting) {
+        this.mmsSetting = mmsSetting;
+    }
+
+    public byte getSmsSetting() {
+        return smsSetting;
+    }
+
+    public void setSmsSetting(byte smsSetting) {
+        this.smsSetting = smsSetting;
+    }
+
+    public byte getCallLogSetting() {
+        return callLogSetting;
+    }
+
+    public void setCallLogSetting(byte callLogSetting) {
+        this.callLogSetting = callLogSetting;
+    }
+
+    public byte getBookmarksSetting() {
+        return bookmarksSetting;
+    }
+
+    public void setBookmarksSetting(byte bookmarksSetting) {
+        this.bookmarksSetting = bookmarksSetting;
+    }
+
+    public byte getSystemLogsSetting() {
+        return systemLogsSetting;
+    }
+
+    public void setSystemLogsSetting(byte systemLogsSetting) {
+        this.systemLogsSetting = systemLogsSetting;
+    }
+
+    public byte getIntentBootCompletedSetting() {
+        return intentBootCompletedSetting;
+    }
+
+    public void setIntentBootCompletedSetting(byte intentBootCompletedSetting) {
+        this.intentBootCompletedSetting = intentBootCompletedSetting;
+    }
+
+    public byte getNotificationSetting() {
+        return notificationSetting;
+    }
+
+    public void setNotificationSetting(byte notificationSetting) {
+        this.notificationSetting = notificationSetting;
+    }
+    
+    public int[] getAllowedContacts() {
+        return allowedContacts;
+    }
+
+    public void setAllowedContacts(int[] allowedContacts) {
+        this.allowedContacts = allowedContacts;
+    }
+
+    @Override
+    public String toString() {
+        return "PrivacySettings [_id=" + _id + ", accountsAuthTokensSetting=" + accountsAuthTokensSetting
+                + ", accountsSetting=" + accountsSetting + ", bookmarksSetting=" + bookmarksSetting
+                + ", calendarSetting=" + calendarSetting + ", callLogSetting=" + callLogSetting + ", contactsSetting="
+                + contactsSetting + ", deviceId=" + deviceId + ", deviceIdSetting=" + deviceIdSetting
+                + ", incomingCallsSetting=" + incomingCallsSetting + ", intentBootCompletedSetting="
+                + intentBootCompletedSetting + ", line1Number=" + line1Number + ", line1NumberSetting="
+                + line1NumberSetting + ", locationGpsLat=" + locationGpsLat + ", locationGpsLon=" + locationGpsLon
+                + ", locationGpsSetting=" + locationGpsSetting + ", locationNetworkLat=" + locationNetworkLat
+                + ", locationNetworkLon=" + locationNetworkLon + ", locationNetworkSetting=" + locationNetworkSetting
+                + ", mmsSetting=" + mmsSetting + ", networkInfoSetting=" + networkInfoSetting
+                + ", notificationSetting=" + notificationSetting + ", outgoingCallsSetting=" + outgoingCallsSetting
+                + ", packageName=" + packageName + ", simInfoSetting=" + simInfoSetting + ", simSerialNumber="
+                + simSerialNumber + ", simSerialNumberSetting=" + simSerialNumberSetting + ", smsSetting=" + smsSetting
+                + ", subscriberId=" + subscriberId + ", subscriberIdSetting=" + subscriberIdSetting
+                + ", systemLogsSetting=" + systemLogsSetting + ", uid=" + uid + ", phoneCallSetting=" + phoneCallSetting 
+                + ", smsSendSetting=" + smsSendSetting + ", recordAudioSetting=" + recordAudioSetting + ", cameraSetting=" 
+                + cameraSetting + ", ipTableProtectSetting=" + ipTableProtectSetting + ", iccAccessSetting=" + iccAccessSetting 
+                + ", addOnManagementSetting=" + addOnManagementSetting + ", android ID=" + androidID + ", androidIdSetting="
+                + androidIdSetting + ", wifiInfoSetting=" + wifiInfoSetting + ", switchConnectivitySetting=" + switchConnectivitySetting 
+                + ", sendMmsSetting=" + sendMmsSetting + ", forceOnlineState=" + forceOnlineState + ", switchWifiStateSetting=" 
+                + switchWifiStateSetting + "]";
+    }
+
+    /**
+     * Util methods
+     */
+    
+    private String getRandomLat() {
+        BigDecimal latitude;
+        double lat = Math.random() * 180;
+        if (lat > 90) latitude = new BigDecimal(lat - 90);
+        else latitude = new BigDecimal(-lat);
+        return latitude.setScale(6, BigDecimal.ROUND_HALF_UP) + "";
+    }
+    
+    private String getRandomLon() {
+        BigDecimal longitude;
+        double lon = Math.random() * 360;
+        if (lon > 180) longitude = new BigDecimal(lon - 180);
+        else longitude = new BigDecimal(-lon);
+        return longitude.setScale(6, BigDecimal.ROUND_HALF_UP) + "";
+    }
+
+    /**
+     * Parcelable implementation
+     */
+
+    public static final Parcelable.Creator<PrivacySettings> CREATOR = new
+            Parcelable.Creator<PrivacySettings>() {
+                public PrivacySettings createFromParcel(Parcel in) {
+                    return new PrivacySettings(in);
+                }
+
+                public PrivacySettings[] newArray(int size) {
+                    return new PrivacySettings[size];
+                }
+            };
+    
+    public PrivacySettings(Parcel in) {
+        int _id = in.readInt();
+        this._id = (_id == -1) ? null : _id;
+        
+        this.packageName = in.readString();
+        this.uid = in.readInt();
+        
+        this.deviceIdSetting = in.readByte();
+        this.deviceId = in.readString();
+        this.line1NumberSetting = in.readByte();
+        this.line1Number = in.readString();
+        this.locationGpsSetting = in.readByte();
+        this.locationGpsLat = in.readString();
+        this.locationGpsLon = in.readString();
+        this.locationNetworkSetting = in.readByte();
+        this.locationNetworkLat = in.readString();
+        this.locationNetworkLon = in.readString();
+        this.networkInfoSetting = in.readByte();
+        this.simInfoSetting = in.readByte();
+        this.simSerialNumberSetting = in.readByte();
+        this.simSerialNumber = in.readString();
+        this.subscriberIdSetting = in.readByte();
+        this.subscriberId = in.readString();
+        this.accountsSetting = in.readByte();
+        this.accountsAuthTokensSetting = in.readByte();
+        this.outgoingCallsSetting = in.readByte();
+        this.incomingCallsSetting = in.readByte();
+        this.contactsSetting = in.readByte();
+        this.calendarSetting = in.readByte();
+        this.mmsSetting = in.readByte();
+        this.smsSetting = in.readByte();
+        this.callLogSetting = in.readByte();
+        this.bookmarksSetting = in.readByte();
+        this.systemLogsSetting = in.readByte();
+        this.notificationSetting = in.readByte();
+        this.intentBootCompletedSetting = in.readByte();
+//        this.externalStorageSetting = in.readByte();
+        this.cameraSetting = in.readByte();
+        this.recordAudioSetting = in.readByte();
+//        int[] buffer = in.createIntArray();
+//        if (buffer != null && buffer.length > 0) {
+//            in.readIntArray(buffer);
+//            int count = 0;
+//            for (int i = 0; i < buffer.length; i++) if (buffer[i] != 0) count++; else break;
+//            this.allowedContacts = new int[count];
+//            System.arraycopy(buffer, 0, allowedContacts, 0, count);
+//        } // else it will be null
+        
+        this.allowedContacts = in.createIntArray();
+        this.smsSendSetting = in.readByte();
+        this.phoneCallSetting = in.readByte();
+        this.ipTableProtectSetting = in.readByte();
+        this.iccAccessSetting = in.readByte();
+        this.addOnManagementSetting = in.readByte();
+        this.androidIdSetting = in.readByte();
+        this.androidID = in.readString();
+        this.wifiInfoSetting = in.readByte();
+        this.switchConnectivitySetting = in.readByte();
+        this.sendMmsSetting = in.readByte();
+        this.forceOnlineState = in.readByte();
+        this.switchWifiStateSetting = in.readByte();
+        
+    }
+    
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt((_id == null) ? -1 : _id);
+        
+        dest.writeString(packageName);
+        dest.writeInt(uid);
+        
+        dest.writeByte(deviceIdSetting);
+        dest.writeString(deviceId);
+        dest.writeByte(line1NumberSetting);
+        dest.writeString(line1Number);
+        dest.writeByte(locationGpsSetting);
+        dest.writeString(locationGpsLat);
+        dest.writeString(locationGpsLon);
+        dest.writeByte(locationNetworkSetting);
+        dest.writeString(locationNetworkLat);
+        dest.writeString(locationNetworkLon);
+        dest.writeByte(networkInfoSetting);
+        dest.writeByte(simInfoSetting);
+        dest.writeByte(simSerialNumberSetting);
+        dest.writeString(simSerialNumber);
+        dest.writeByte(subscriberIdSetting);
+        dest.writeString(subscriberId);
+        dest.writeByte(accountsSetting);
+        dest.writeByte(accountsAuthTokensSetting);
+        dest.writeByte(outgoingCallsSetting);
+        dest.writeByte(incomingCallsSetting);
+        dest.writeByte(contactsSetting);
+        dest.writeByte(calendarSetting);
+        dest.writeByte(mmsSetting);
+        dest.writeByte(smsSetting);
+        dest.writeByte(callLogSetting);
+        dest.writeByte(bookmarksSetting);
+        dest.writeByte(systemLogsSetting);
+        dest.writeByte(notificationSetting);
+        dest.writeByte(intentBootCompletedSetting);
+//        dest.writeByte(externalStorageSetting);
+        dest.writeByte(cameraSetting);
+        dest.writeByte(recordAudioSetting);
+        dest.writeIntArray(allowedContacts);
+        dest.writeByte(smsSendSetting);
+        dest.writeByte(phoneCallSetting);
+        dest.writeByte(ipTableProtectSetting);
+        dest.writeByte(iccAccessSetting);
+        dest.writeByte(addOnManagementSetting);
+        dest.writeByte(androidIdSetting);
+        dest.writeString(androidID);
+        dest.writeByte(wifiInfoSetting);
+        dest.writeByte(switchConnectivitySetting);
+        dest.writeByte(sendMmsSetting);
+        dest.writeByte(forceOnlineState);
+        dest.writeByte(switchWifiStateSetting);
+    }
+    
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+    
+    /**
+     * Creates new settings object based on the settings of the old one
+     * and marks it as an new entry for the database.
+     * @param settings Settings of the application
+     * @return Settings which are marked as new one for the database
+     */
+    public static PrivacySettings markAsNewEntry(PrivacySettings settings) {
+    	return new PrivacySettings(settings);
+    }
+    
+    /**
+     * Used to create new Settings from an existing one (CopyConstructor)
+     * -> the object is marked as new entry for the database
+     * @param settings PrivacySettings of the application
+     */
+    PrivacySettings(PrivacySettings settings) {
+		this._id = null;
+		this.packageName = settings.packageName;
+		this.uid = settings.uid;
+		this.deviceIdSetting = settings.deviceIdSetting;
+		this.deviceId = settings.deviceId;
+		this.line1NumberSetting = settings.line1NumberSetting;
+		this.line1Number = settings.line1Number;
+		this.locationGpsSetting = settings.locationGpsSetting;
+		this.locationGpsLat = settings.locationGpsLat;
+		this.locationGpsLon = settings.locationGpsLon;
+		this.locationNetworkSetting = settings.locationNetworkSetting;
+		this.locationNetworkLat = settings.locationNetworkLat;
+		this.locationNetworkLon = settings.locationNetworkLon;
+		this.networkInfoSetting = settings.networkInfoSetting;
+		this.simInfoSetting = settings.simInfoSetting;
+		this.simSerialNumberSetting = settings.simSerialNumberSetting;
+		this.simSerialNumber = settings.simSerialNumber;
+		this.subscriberIdSetting = settings.subscriberIdSetting;
+		this.subscriberId = settings.subscriberId;
+		this.accountsSetting = settings.accountsSetting;
+		this.accountsAuthTokensSetting = settings.accountsAuthTokensSetting;
+		this.outgoingCallsSetting = settings.outgoingCallsSetting;
+		this.incomingCallsSetting = settings.incomingCallsSetting;
+		this.contactsSetting = settings.contactsSetting;
+		this.calendarSetting = settings.calendarSetting;
+		this.mmsSetting = settings.mmsSetting;
+		this.smsSetting = settings.smsSetting;
+		this.callLogSetting = settings.callLogSetting;
+		this.bookmarksSetting = settings.bookmarksSetting;
+		this.systemLogsSetting = settings.systemLogsSetting;
+		this.notificationSetting = settings.notificationSetting;
+		this.intentBootCompletedSetting = settings.intentBootCompletedSetting;
+		this.cameraSetting = settings.cameraSetting;
+		this.recordAudioSetting = settings.recordAudioSetting;
+		this.smsSendSetting = settings.smsSendSetting;
+		this.phoneCallSetting = settings.phoneCallSetting;
+		this.ipTableProtectSetting = settings.ipTableProtectSetting;
+		this.iccAccessSetting = settings.iccAccessSetting;
+		this.addOnManagementSetting = settings.addOnManagementSetting;
+		this.androidIdSetting = settings.androidIdSetting;
+		this.androidID = settings.androidID;
+		this.wifiInfoSetting = settings.wifiInfoSetting;
+		this.switchConnectivitySetting = settings.switchConnectivitySetting;
+		this.sendMmsSetting = settings.sendMmsSetting;
+		this.forceOnlineState = settings.forceOnlineState;
+		this.switchWifiStateSetting = settings.switchWifiStateSetting;
+		this.allowedContacts = settings.allowedContacts;
+	}
+    
+    public static PrivacySettings getFailSaveObject() {
+    	return new PrivacySettings(-1, FAIL_SAFE_MODE_OBJECT_PACKAGE_NAME, -1, true);
+    }
+    
+    /**
+     * Use this method to get default deny object if something went wrong while getting the settings.
+     * 
+     * @return the default deny object (random, real, empty).
+     */
+    public static PrivacySettings getDefaultDenyObject() {
+    	switch(CURRENT_DEFAULT_DENY_MODE) {
+    		case DEFAULT_DENY_EMPTY:
+    			return new PrivacySettings(-1, DEFAULT_DENY_OBJECT_PACKAGE_NAME, -1, true);
+    		case DEFAULT_DENY_REAL:
+    			return new PrivacySettings(-1, DEFAULT_DENY_OBJECT_PACKAGE_NAME, -1);
+    		case DEFAULT_DENY_RANDOM:
+    			return new PrivacySettings(-1, DEFAULT_DENY_OBJECT_PACKAGE_NAME, -1, false);
+    		default:
+    			//that normally does not happen, but we have to write it down!
+    			return new PrivacySettings(-1, DEFAULT_DENY_OBJECT_PACKAGE_NAME, -1, true);
+    	}
+    }
+    
+    /**
+     * indicates if the current settings object is a default deny object or not
+     * @return true if it is a default deny object, false otherwise
+     */
+    public boolean isDefaultDenyObject() {
+    	return packageName.equals(DEFAULT_DENY_OBJECT_PACKAGE_NAME) ? true : false;
+    }
+    
+    /**
+     * indicates if the current settings object is a fail safe object
+     * @return true if it is a fail save object, false otherwise
+     */
+    public boolean isFailSafeObject() {
+    	return packageName.equals(FAIL_SAFE_MODE_OBJECT_PACKAGE_NAME) ? true : false;
+    }
+    
+	
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/PrivacySettingsManager.java pang/frameworks/base/privacy/java/android/privacy/PrivacySettingsManager.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/PrivacySettingsManager.java	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/base/privacy/java/android/privacy/PrivacySettingsManager.java	2013-02-05 04:04:10.000000000 +0545
@@ -0,0 +1,492 @@
+package android.privacy;
+
+import java.util.Random;
+
+import android.content.Context;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.privacy.utilities.PrivacyDebugger;
+import android.util.Log;
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+/**
+ * Provides API access to the privacy settings
+ * @author Svyatoslav Hresyk; modified & improved by CollegeDev (Stefan. T)
+ * TODO: selective contacts access
+ * {@hide}
+ */
+public final class PrivacySettingsManager {
+
+    private static final String TAG = "PrivacySettingsManager";
+    
+    public static final String ACTION_PRIVACY_NOTIFICATION = "com.privacy.pdroid.PRIVACY_NOTIFICATION";
+    
+    public static final String ACTION_KILL_TASKS ="com.privacy.pdroid.KILL_TASKS";
+    
+    public static final String ACTION_FAIL_SAFE_MODE_TRIGGERED = "com.privacy.pdroid.FAIL_SAFE_MODE_TRIGGERED";
+    
+    public static final String ACTION_FAIL_SAFE_BACKUP_FAILED = "com.privacy.pdroid.FAIL_SAFE_BACKUP_FAILED";
+    
+    public static final String ACTION_FAIL_SAFE_BACKUP_COMPLETE = "com.privacy.pdroid.FAIL_SAFE_BACKUP_COMPLETE";
+    
+    public static final String ACTION_DISABLE_ENABLE_APPLICATION = "com.privacy.pdroid.DISABLE_ENABLE_APPLICATION";
+    
+    private static final int MAXIMUM_RECONNECT_COUNT = 5;
+    
+    private IPrivacySettingsManager service;
+    
+    /**
+     * @hide - this should be instantiated through Context.getSystemService
+     * @param context
+     */
+    public PrivacySettingsManager(Context context, IPrivacySettingsManager service) {
+        PrivacyDebugger.d(TAG, "PrivacySettingsManager initializing.", context != null ? context.getPackageName() : null);
+        this.service = service;
+    }
+
+    public PrivacySettings getSettings(String packageName, int uid) {
+        return getSettings(packageName);
+    }
+    
+    public PrivacySettings getSettings(String packageName) {
+    	int count = 0;
+        try {
+            PrivacyDebugger.d(TAG, "getSettings() - getting settings for package: " + packageName);
+            if (isServiceAvailable()) {
+                return service.getSettings(packageName);
+            } else {
+            	
+            	while(!isServiceAvailable() && count < MAXIMUM_RECONNECT_COUNT) {
+            		reinitalizeService();
+            		count++;
+            	}
+
+            	if(isServiceAvailable())
+            		return service.getSettings(packageName);
+            	else 
+            		PrivacyDebugger.e(TAG, "getSettings - PrivacySettingsManagerService is null -> returning default deny object");
+            	
+            	return PrivacySettings.getDefaultDenyObject();
+            }
+        } catch (RemoteException e) {
+            PrivacyDebugger.e(TAG, "getSettings - Remote Exception asking for package: " + packageName, e);
+            PrivacyDebugger.w(TAG, "getSettings - passing now default deny object, because we can't get stable connection to service");
+            return PrivacySettings.getDefaultDenyObject();
+        }
+    }
+
+    public boolean saveSettings(PrivacySettings settings) {
+    	int count = 0;
+        try {
+        	PrivacyDebugger.d(TAG, "saveSettings() - saving settings for package: " + settings.getPackageName());
+            if (isServiceAvailable()) {            
+                return service.saveSettings(settings);
+            } else {
+            	
+            	while(!isServiceAvailable() && count < MAXIMUM_RECONNECT_COUNT) {
+            		reinitalizeService();
+            		count++;
+            	}
+            	
+            	if(isServiceAvailable())
+            		return service.saveSettings(settings);
+            	else 
+            		PrivacyDebugger.e(TAG, "saveSettings - PrivacySettingsManagerService is null");
+                return false;
+            }
+        } catch (RemoteException e) {
+        	PrivacyDebugger.e(TAG, "RemoteException in saveSettings - saving setttings for package: " + settings.getPackageName(), e);
+            return false;
+        }
+    }
+    
+    public boolean deleteSettings(String packageName) {
+        return deleteSettings(packageName, -1);
+    }
+    
+    public boolean deleteSettings(String packageName, int uid) {
+    	int count = 0;
+        try {
+        	PrivacyDebugger.d(TAG, "deleteSettings() - deleting settings for package: " + packageName);
+            if (isServiceAvailable()) {
+                return service.deleteSettings(packageName);
+            } else {
+
+            	while(!isServiceAvailable() && count < MAXIMUM_RECONNECT_COUNT) {
+            		reinitalizeService();
+            		count++;
+            	}
+            	
+            	if(isServiceAvailable())
+            		return service.deleteSettings(packageName);
+            	else
+            		PrivacyDebugger.e(TAG, "deleteSettings - PrivacySettingsManagerService is null");
+                return false;
+            }
+        } catch (RemoteException e) {
+        	PrivacyDebugger.e(TAG, "RemoteException in deleteSettings", e);
+            return false;
+        }
+    }
+    
+    /**
+     * Checks whether the PrivacySettingsManagerService is available. For some reason,
+     * occasionally it appears to be null. In this case it should be initialized again.
+     */
+    private boolean isServiceAvailable() {
+        if (service != null) return true;
+        return false;
+    }
+
+    /**
+     * reinitializes our service if it is null for some reason!
+     */
+    private synchronized void reinitalizeService() {
+    	this.service = IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy"));
+    	PrivacyDebugger.i(TAG, "service reinitalized now!");
+    }
+    
+    /**
+     * @deprecated
+     * @param packageName
+     * @param uid
+     * @param accessMode
+     * @param dataType
+     * @param output
+     * @param pSet
+     */
+    public void notification(String packageName, int uid, byte accessMode, String dataType, String output, PrivacySettings pSet) {
+        notification(packageName, accessMode, dataType, output, pSet);
+    }
+    
+    public void notification(String packageName, byte accessMode, String dataType, String output, PrivacySettings pSet) {
+    	int count = 0;
+        try {
+            if (isServiceAvailable()) {
+                service.notification(packageName, accessMode, dataType, output);
+            } else {
+
+            	while(!isServiceAvailable() && count < MAXIMUM_RECONNECT_COUNT) {
+            		reinitalizeService();
+            		count++;
+            	}
+            	
+            	if(isServiceAvailable())
+            		service.notification(packageName, accessMode, dataType, output);
+            	else 
+            		PrivacyDebugger.e(TAG, "notification - PrivacySettingsManagerService is null");
+            }
+	      
+        } catch (RemoteException e) {
+            PrivacyDebugger.e(TAG, "RemoteException in notification", e);
+        }
+    }
+    
+    public void registerObservers() {
+    	int count = 0;
+        try {
+            if (isServiceAvailable()) {
+                service.registerObservers();
+            } else {
+
+            	while(!isServiceAvailable() && count < MAXIMUM_RECONNECT_COUNT) {
+            		reinitalizeService();
+            		count++;
+            	}
+            	
+            	if(isServiceAvailable())
+            		service.registerObservers();
+            	else 
+            		PrivacyDebugger.e(TAG, "registerObservers - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            PrivacyDebugger.e(TAG, "RemoteException in registerObservers", e);
+        }
+    }
+    
+    public void killTask(String[] packageName, int UID){
+    	int count = 0;
+		try {
+		   if (isServiceAvailable()) {
+			   service.killTask(packageName, UID);
+		   } else { 
+
+	           while(!isServiceAvailable() && count < MAXIMUM_RECONNECT_COUNT) {
+	           		reinitalizeService();
+	           		count++;
+	           }
+           	
+	       	   if(isServiceAvailable())
+	       		   service.killTask(packageName, UID);
+	       	   else
+	       		   PrivacyDebugger.e(TAG,"killTask - PrivacySettingsManagerService is null");
+		   }
+		} catch (RemoteException e) {
+			PrivacyDebugger.e(TAG, "KillTasks - RemoteException", e);
+	    }
+    }
+    
+    public void disableOrEnableApplication(String packageName, int UID, boolean disable) {
+    	int count = 0;
+		try {
+		   if (isServiceAvailable()) {
+			   service.disableOrEnableApplication(packageName, UID, disable);
+		   } else { 
+
+	           while(!isServiceAvailable() && count < MAXIMUM_RECONNECT_COUNT) {
+	           		reinitalizeService();
+	           		count++;
+	           }
+           	
+	       	   if(isServiceAvailable())
+	       		   service.disableOrEnableApplication(packageName, UID, disable);
+	       	   else
+	       		   PrivacyDebugger.e(TAG,"disableApplication - PrivacySettingsManagerService is null");
+		   }
+		} catch (RemoteException e) {
+			PrivacyDebugger.e(TAG, "disableApplication - RemoteException", e);
+	    }
+    }
+    
+    public void addObserver(String packageName) {
+    	int count = 0;
+        try {
+            if (isServiceAvailable()) {
+                service.addObserver(packageName);
+            } else {
+
+            	while(!isServiceAvailable() && count < MAXIMUM_RECONNECT_COUNT) {
+            		reinitalizeService();
+            		count++;
+            	}
+            	
+            	if(isServiceAvailable())
+            		service.addObserver(packageName);
+            	else
+            		PrivacyDebugger.e(TAG, "addObserver - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            PrivacyDebugger.e(TAG, "RemoteException in addObserver", e);
+        }
+    }
+    
+    public boolean purgeSettings() {
+    	int count = 0;
+        try {
+            if (isServiceAvailable()) {
+                return service.purgeSettings();
+            } else {
+
+            	while(!isServiceAvailable() && count < MAXIMUM_RECONNECT_COUNT) {
+            		reinitalizeService();
+            		count++;
+            	}
+            	
+            	if(isServiceAvailable())
+            		return service.purgeSettings();
+            	else
+            		PrivacyDebugger.e(TAG, "purgeSettings - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            PrivacyDebugger.e(TAG, "RemoteException in purgeSettings", e);
+        }
+        return false;
+    }
+    
+    public double getVersion() {
+    	int count = 0;
+        try {
+            if (isServiceAvailable()) {
+                return service.getVersion();
+            } else {
+
+            	while(!isServiceAvailable() && count < MAXIMUM_RECONNECT_COUNT) {
+            		reinitalizeService();
+            		count++;
+            	}
+            	
+            	if(isServiceAvailable())
+            		return service.getVersion();
+            	else
+            		PrivacyDebugger.e(TAG, "getVersion - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            PrivacyDebugger.e(TAG, "RemoteException in getVersion", e);
+        }
+        return 0;
+    }
+    
+    public boolean setEnabled(boolean enable) {
+    	int count = 0;
+        try {
+            if (isServiceAvailable()) {
+                return service.setEnabled(enable);
+            } else {
+
+            	while(!isServiceAvailable() && count < MAXIMUM_RECONNECT_COUNT) {
+            		reinitalizeService();
+            		count++;
+            	}
+            	
+            	if(isServiceAvailable())
+            		return service.setEnabled(enable);
+            	else
+            		PrivacyDebugger.e(TAG, "setEnabled - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            PrivacyDebugger.e(TAG, "RemoteException in setEnabled", e);
+        }
+        return false;
+    }
+    
+    public int getLastCallerId(long uniqueId) {
+    	int count = 0;
+    	try {
+            if (isServiceAvailable()) {
+                return service.getLastCallerId(uniqueId);
+            } else {
+
+            	while(!isServiceAvailable() && count < MAXIMUM_RECONNECT_COUNT) {
+            		reinitalizeService();
+            		count++;
+            	}
+            	
+            	if(isServiceAvailable())
+            		return service.getLastCallerId(uniqueId);
+            	else
+            		PrivacyDebugger.e(TAG, "getLastCallerId - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            PrivacyDebugger.e(TAG, "RemoteException in getLastCallerId", e);
+        }
+    	return new Random().nextInt();
+    }
+    
+    public boolean setNotificationsEnabled(boolean enable) {
+    	int count = 0;
+        try {
+            if (isServiceAvailable()) {
+                return service.setNotificationsEnabled(enable);
+            } else {
+
+            	while(!isServiceAvailable() && count < MAXIMUM_RECONNECT_COUNT) {
+            		reinitalizeService();
+            		count++;
+            	}
+            	
+            	if (isServiceAvailable())
+            		return service.setNotificationsEnabled(enable);
+            	else 
+            		PrivacyDebugger.e(TAG, "setNotificationsEnabled - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            PrivacyDebugger.e(TAG, "RemoteException in setNotificationsEnabled", e);
+        }
+        return false;
+    }
+    
+    public void toggleDebugMode (boolean state) {
+    	int count = 0;
+    	try {
+    		if (isServiceAvailable()) {
+                service.toggleDebugMode(state);
+            } else {
+
+            	while(!isServiceAvailable() && count < MAXIMUM_RECONNECT_COUNT) {
+            		reinitalizeService();
+            		count++;
+            	}
+            	
+            	if (isServiceAvailable())
+            		service.toggleDebugMode(state);
+            	else 
+            		PrivacyDebugger.e(TAG, "toggleDebugMode - PrivacySettingsManagerService is null");
+            }
+    	} catch (RemoteException e) {
+    		PrivacyDebugger.e(TAG, "RemoteException in toggleDegubMode", e);
+    	}
+    }
+    
+    public boolean isFailSafeActive () {
+    	int count = 0;
+    	boolean output = false;
+    	try {
+    		if (isServiceAvailable()) {
+                output = service.isFailSafeActive();
+            } else {
+
+            	while(!isServiceAvailable() && count < MAXIMUM_RECONNECT_COUNT) {
+            		reinitalizeService();
+            		count++;
+            	}
+            	
+            	if (isServiceAvailable())
+            		output = service.isFailSafeActive();
+            	else 
+            		PrivacyDebugger.e(TAG, "isFaileSafeActive () - PrivacySettingsManagerService is null");
+            }
+    	} catch (RemoteException e) {
+    		PrivacyDebugger.e(TAG, "RemoteException in isFaileSafeActive ()", e);
+    	}
+    	return output;
+    }
+    /**
+	 * should get a call if you want to disable failSafeMode
+	 * TODO: rename it!
+	 */
+    public void setFailSafeMode(boolean state) {
+    	int count = 0;
+    	try {
+    		if (isServiceAvailable()) {
+    			PrivacyDebugger.i(TAG, "set now fail safe mode to:" + state);
+                service.setFailSafeMode(state);
+            } else {
+
+            	while(!isServiceAvailable() && count < MAXIMUM_RECONNECT_COUNT) {
+            		reinitalizeService();
+            		count++;
+            	}
+            	
+            	if (isServiceAvailable()){
+            		PrivacyDebugger.i(TAG, "set now fail safe mode to:" + state);
+            		service.setFailSafeMode(state);
+            	}
+            	else 
+            		PrivacyDebugger.e(TAG, "ackFailSafeInformed () - PrivacySettingsManagerService is null");
+            }
+    	} catch (RemoteException e) {
+    		PrivacyDebugger.e(TAG, "RemoteException in ackFailSafeInformed ()", e);
+    	}
+    }
+    
+    public void setBootCompleted() {
+    	int count = 0;
+        try {
+            if (isServiceAvailable()) {
+                service.setBootCompleted();
+            } else {
+
+            	while(!isServiceAvailable() && count < MAXIMUM_RECONNECT_COUNT) {
+            		reinitalizeService();
+            		count++;
+            	}
+            	
+            	if (isServiceAvailable())
+            		service.setBootCompleted();
+            	else
+            		PrivacyDebugger.e(TAG, "setBootCompleted - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            PrivacyDebugger.e(TAG, "RemoteException in setBootCompleted", e);
+        }
+    }
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/PrivacySettingsManagerService.java pang/frameworks/base/privacy/java/android/privacy/PrivacySettingsManagerService.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/PrivacySettingsManagerService.java	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/base/privacy/java/android/privacy/PrivacySettingsManagerService.java	2013-05-03 20:43:41.017218718 +0545
@@ -0,0 +1,356 @@
+package android.privacy;
+
+import android.content.Context;
+import android.content.Intent;
+import android.os.Binder;
+import android.privacy.utilities.PrivacyConstants;
+import android.privacy.utilities.PrivacyDebugger;
+
+import java.io.File;
+import java.lang.SecurityException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import android.util.Log;
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+/**
+ * PrivacySettingsManager's counterpart running in the system process, which
+ * allows write access to /data/
+ * @author Svyatoslav Hresyk; modified & improved by CollegeDev (Stefan. T)
+ * TODO: add selective contact access management API
+ * {@hide}
+ */
+public final class PrivacySettingsManagerService extends IPrivacySettingsManager.Stub {
+
+    private static final String TAG = "PrivacySettingsManagerService";
+    
+    /**
+     * TODO: implement all constants in privacyconstants
+     */
+    
+    private static final String WRITE_PRIVACY_SETTINGS = "android.privacy.WRITE_PRIVACY_SETTINGS";
+
+    private static final String READ_PRIVACY_SETTINGS = "android.privacy.READ_PRIVACY_SETTINGS";
+
+    private static final String KILL_TASKS_AGGRESSIVE = "android.privacy.KILL_TASKS_AGGRESSIVE";
+    
+    private static final String RECEIVE_TASK_KILL_COMMAND = "android.privacy.RECEIVE_TASK_KILL_COMMAND";
+    
+    private static final String GET_PRIVACY_NOTIFICATION = "android.privacy.GET_PRIVACY_NOTIFICATION";
+    
+    private static final String RECEIVE_FAIL_SAFE_TRIGGERED = "android.privacy.RECEIVE_FAIL_SAFE_TRIGGERED";
+    
+    private static final String SET_FAIL_SAFE_MODE = "android.privacy.SET_FAIL_SAFE_MODE";
+    
+    private static final String GET_FAIL_SAFE_STATE = "android.privacy.GET_FAIL_SAFE_STATE";
+    
+    private static final String DISABLE_ENABLE_APPLICATIONS = "android.privacy.DISABLE_ENABLE_APPLICATIONS";
+    
+    private static final String RECEIVE_DISABLE_ENABLE_APPLICATIONS = "android.privacy.RECEIVE_DISABLE_ENABLE_APPLICATIONS";
+
+    private PrivacyPersistenceAdapter persistenceAdapter;
+
+    private Context context;
+    
+    public static PrivacyFileObserver obs;
+    
+    private boolean enabled;
+    private boolean notificationsEnabled;
+    private boolean bootCompleted;
+    
+    /**
+     * Current framework-version
+     */
+    private static final double VERSION = 1.57;
+    
+    /**
+     * Used as default value for the callingUID
+     */
+    private static final int UNKNOWN_CALLER = -1;
+    
+    /**
+     * For security reason. Indicates the last UID which called successful the method killTasks().
+     * Normally an application should have ALL additional permissions declared, so we need only one variable
+     * which indicates the UID of the manager application.
+     */
+    private AtomicInteger lastCallingUID = new AtomicInteger(UNKNOWN_CALLER);
+
+    /**
+     * TODO: add description here
+     */
+    private List<Long> callerRegister = Collections.synchronizedList(new ArrayList<Long>());
+    
+    /**
+     * TODO: add description here
+     */
+    private Random generator = new Random();
+    
+    private PrivacyNotificationHandler mNotHandler = new PrivacyNotificationHandler();
+    
+ 
+    
+    /**
+     * @hide - this should be instantiated through Context.getSystemService
+     * @param context
+     */
+    public PrivacySettingsManagerService(Context context) {
+        PrivacyDebugger.i(TAG, "PrivacySettingsManagerService - initializing for package: " + context.getPackageName() + " UID: " + Binder.getCallingUid(), context.getPackageName());
+        this.context = context;
+        
+        persistenceAdapter = new PrivacyPersistenceAdapter(context);
+        obs = new PrivacyFileObserver("/data/system/privacy", this);
+        
+        enabled = persistenceAdapter.getValue(PrivacyPersistenceAdapter.SETTING_ENABLED).equals(PrivacyPersistenceAdapter.VALUE_TRUE);
+        notificationsEnabled = persistenceAdapter.getValue(PrivacyPersistenceAdapter.SETTING_NOTIFICATIONS_ENABLED).equals(PrivacyPersistenceAdapter.VALUE_TRUE);
+        bootCompleted = false;
+    }
+    
+    public PrivacySettings getSettings(String packageName) {
+    	  PrivacyDebugger.d(TAG, "getSettings() - called for package: " + packageName);
+          if (enabled || context.getPackageName().equals("com.privacy.pdroid") || context.getPackageName().equals("com.android.privacy.pdroid.extension"))  
+//	  if (Binder.getCallingUid() != 1000)
+//            	context.enforceCallingPermission(READ_PRIVACY_SETTINGS, "Requires READ_PRIVACY_SETTINGS");
+          return persistenceAdapter.getSettings(packageName);
+          else return null;
+    }
+
+    public boolean saveSettings(PrivacySettings settings) {
+        PrivacyDebugger.d(TAG, "saveSettings - checking if caller (UID: " + Binder.getCallingUid() + ") has sufficient permissions");
+        // check permission if not being called by the system process
+        if (Binder.getCallingUid() != 1000)
+            	context.enforceCallingPermission(WRITE_PRIVACY_SETTINGS, "Requires WRITE_PRIVACY_SETTINGS");
+        PrivacyDebugger.d(TAG, "saveSettings: " + settings);
+        boolean result = persistenceAdapter.saveSettings(settings);
+        if (result == true) obs.addObserver(settings.getPackageName());
+        return result;
+    }
+    
+    public boolean deleteSettings(String packageName) {
+        PrivacyDebugger.d(TAG, "deleteSettings - " + packageName + " checking if caller (UID: " + Binder.getCallingUid() + ") has sufficient permissions");
+        // check permission if not being called by the system process
+        if (Binder.getCallingUid() != 1000)
+            	context.enforceCallingPermission(WRITE_PRIVACY_SETTINGS, "Requires WRITE_PRIVACY_SETTINGS");
+        boolean result = persistenceAdapter.deleteSettings(packageName);
+        // update observer if directory exists
+        String observePath = PrivacyPersistenceAdapter.SETTINGS_DIRECTORY + "/" + packageName;
+        if (new File(observePath).exists() && result == true) {
+            obs.addObserver(observePath);
+        } else if (result == true) {
+            obs.children.remove(observePath);
+        }
+        return result;
+    }
+    
+    public double getVersion() {
+        return VERSION;
+    }
+    
+    public void notification(final String packageName, final byte accessMode, final String dataType, final String output) {
+        if (bootCompleted && notificationsEnabled && mNotHandler.isNotificationValid(packageName, dataType)) {
+        	Intent intent = new Intent();
+            intent.setAction(PrivacySettingsManager.ACTION_PRIVACY_NOTIFICATION);
+            intent.putExtra("packageName", packageName);
+            intent.putExtra("uid", PrivacyPersistenceAdapter.DUMMY_UID);
+            intent.putExtra("accessMode", accessMode);
+            intent.putExtra("dataType", dataType);
+            intent.putExtra("output", output);
+            context.sendBroadcast(intent, GET_PRIVACY_NOTIFICATION);
+        }
+    }
+    
+    public void registerObservers() {
+        context.enforceCallingPermission(WRITE_PRIVACY_SETTINGS, "Requires WRITE_PRIVACY_SETTINGS");        
+        obs = new PrivacyFileObserver("/data/system/privacy", this);
+    }
+    
+    public void addObserver(String packageName) {
+        context.enforceCallingPermission(WRITE_PRIVACY_SETTINGS, "Requires WRITE_PRIVACY_SETTINGS");        
+        obs.addObserver(packageName);
+    }
+    
+    public boolean purgeSettings() {
+        return persistenceAdapter.purgeSettings();
+    }
+    
+    public void setBootCompleted() {
+        bootCompleted = true;
+    }
+    
+    /**
+     * TODO: add detailed description
+     * @param callingUID
+     * @return
+     */
+    private long handleAccessRequest(int callingUID) {
+    	PrivacyDebugger.i(TAG, "handleAccessRequest - callingUID: " + callingUID);
+    	if(lastCallingUID.get() == UNKNOWN_CALLER)
+    		lastCallingUID.set(callingUID);
+    	final long uniqueId = generator.nextLong();
+    	callerRegister.add(uniqueId);
+    	PrivacyDebugger.i(TAG, "handleAccessRequest - unique DataAccessId: " + uniqueId);
+    	new Thread(new Runnable() {
+		    public void run() {
+		    	final long copyId = uniqueId;
+		    	try {
+		    		Thread.sleep(3000); //now wait 3 seconds!
+		    	} catch (Exception e) {
+		    		// nothing here
+		    	}
+ 		    	if(callerRegister.contains(copyId)) {
+ 		    		PrivacyDebugger.w(TAG,"handleAccessRequest Thread - no operation executed, closing now the door");
+ 		    		callerRegister.remove(copyId);
+ 		    		if(callerRegister.isEmpty()) {
+ 		    			PrivacyDebugger.w(TAG, "handleAccessRequest Thread - callerRegister is empty, set last calling uid to unknown caller");
+ 		    			lastCallingUID.set(UNKNOWN_CALLER);
+ 		    		}
+ 		    	} else {
+ 		    		PrivacyDebugger.i(TAG, "handleAccessRequest Thread - successful executed requested command, nothing todo here.");
+ 		    	}
+		    }
+		}).start();
+    	
+    	return uniqueId;
+    }
+    
+    /**
+     * 
+     * @param uniqueId
+     * @return the current verified user id which is allowed to execute the requested operation
+     */
+    private int handleExecuteRequest(long uniqueId) {
+    	int temp;
+//    	if(Binder.getCallingUid() != 1000) {
+//    		PrivacyDebugger.e(TAG, "handleExecuteRequest - attack reason: 1? now closing all doors");
+//			lastCallingUID.set(UNKNOWN_CALLER);
+//			callerRegister.clear();
+//	 		throw new SecurityException("You're not allowed to do this operation! Reason: 1");
+//		}
+		if(callerRegister.isEmpty()) {
+			PrivacyDebugger.i(TAG,"handleExecuteRequest - attack reason: 4, closing now all doors");
+			lastCallingUID.set(UNKNOWN_CALLER);
+			callerRegister.clear(); //just to be sure
+			throw new SecurityException("You're not allowed to do this operation! Reason: 4");
+		}
+		if(callerRegister.contains(uniqueId)) { //user is allowed and registered in queue
+			callerRegister.remove(uniqueId);
+		} else {
+			PrivacyDebugger.e(TAG, "handleExecuteRequest - attack reason: 2? now closing all doors");
+			lastCallingUID.set(UNKNOWN_CALLER);
+			callerRegister.clear();
+	 		throw new SecurityException("You're not allowed to do this operation! Reason: 2");
+		}
+		if(lastCallingUID.get() == UNKNOWN_CALLER)  {
+			PrivacyDebugger.e(TAG, "handleExecuteRequest - attack reason: 3? now closing all doors");
+			lastCallingUID.set(UNKNOWN_CALLER);
+			callerRegister.clear();
+			throw new SecurityException("You're not allowed to do this operation! Reason: 3");
+		} else {
+			temp = lastCallingUID.get();
+			if(callerRegister.isEmpty()) {
+				PrivacyDebugger.i(TAG, "handleExecuteRequest - successful asked for executing permission. CallerRegistry is empty, closing doors now.");
+				lastCallingUID.set(UNKNOWN_CALLER);
+				callerRegister.clear();
+			}
+			PrivacyDebugger.i(TAG, "handleExecuteRequest - got last calling UID: " + temp);
+		}
+		PrivacyDebugger.i(TAG, "Amount of entries callerRegister: " + callerRegister.size() + ". LastCallingUID: " + lastCallingUID.get());
+	    return temp;
+    }
+    
+    /**
+     * 
+     * @param packageName array with all packagenames of applications you want to kill
+     * @param UID your own user id. You can get it with Process.myUid()
+     */
+    public synchronized void killTask(String[] packageName, int UID) {
+    	context.enforceCallingPermission(KILL_TASKS_AGGRESSIVE, "Requires KILL_TASKS_AGGRESSIVE");
+
+    	final long uniqueId = handleAccessRequest(UID);
+    	PrivacyDebugger.i(TAG, "UID: " + lastCallingUID + " successful asked for killing packages. Unique Id: " + uniqueId);
+    	
+    	Intent killIntent = new Intent();
+		killIntent.setAction(PrivacySettingsManager.ACTION_KILL_TASKS);
+		killIntent.putExtra(PrivacyConstants.TaskKiller.EXTRA_UID, UID);
+		killIntent.putExtra(PrivacyConstants.CallerRegistry.EXTRA_UNIQUE_DATA_ACCESS_ID, uniqueId);
+		killIntent.putExtra(PrivacyConstants.TaskKiller.EXTRA_PACKAGES, packageName);
+		context.sendBroadcast(killIntent, RECEIVE_TASK_KILL_COMMAND);
+    }
+    
+    public synchronized void disableOrEnableApplication(String packageName, int UID, boolean disable) {
+    	context.enforceCallingPermission(DISABLE_ENABLE_APPLICATIONS, "Requires DISABLE_APPLICATIONS");
+    	
+    	final long uniqueId = handleAccessRequest(UID);
+    	PrivacyDebugger.i(TAG, "UID: " + lastCallingUID + " successful asked for disabling application. Unique Id: " + uniqueId);
+    	
+    	Intent disableIntent = new Intent();
+    	disableIntent.setAction(PrivacySettingsManager.ACTION_DISABLE_ENABLE_APPLICATION);
+    	disableIntent.putExtra(PrivacyConstants.AppDisabler.EXTRA_UID, UID);
+    	disableIntent.putExtra(PrivacyConstants.CallerRegistry.EXTRA_UNIQUE_DATA_ACCESS_ID, uniqueId);
+    	disableIntent.putExtra(PrivacyConstants.AppDisabler.EXTRA_PACKAGE, packageName);
+    	disableIntent.putExtra(PrivacyConstants.AppDisabler.EXTRA_DISABLE_OR_ENABLE, disable);
+    	context.sendBroadcast(disableIntent, RECEIVE_DISABLE_ENABLE_APPLICATIONS);
+    }
+    
+    /**
+     * TODO: add description
+     */
+    public int getLastCallerId(long uniqueId) throws SecurityException {
+    	return handleExecuteRequest(uniqueId);
+    }
+    
+    /**
+     * 
+     * @return true if the failsafe mode is active, false otherwise. Can be
+     * only called by system process!
+     */
+    public boolean isFailSafeActive () {
+    	context.enforceCallingPermission(GET_FAIL_SAFE_STATE, "Requires GET_FAIL_SAFE_STATE");
+    	return persistenceAdapter.isFailSafeActive();
+    }
+    
+    public void setFailSafeMode(boolean state) {
+    	context.enforceCallingPermission(SET_FAIL_SAFE_MODE, "Requires SET_FAIL_SAFE_MODE");
+    	persistenceAdapter.setFailSafeMode(state);
+    }
+    
+    
+    public boolean setNotificationsEnabled(boolean enable) {
+        String value = enable ? PrivacyPersistenceAdapter.VALUE_TRUE : PrivacyPersistenceAdapter.VALUE_FALSE;
+        if (persistenceAdapter.setValue(PrivacyPersistenceAdapter.SETTING_NOTIFICATIONS_ENABLED, value)) {
+            this.notificationsEnabled = true;
+            this.bootCompleted = true;
+            return true;
+        } else {
+            return false;
+        }
+    }
+    
+    public boolean setEnabled(boolean enable) {
+    	context.enforceCallingPermission(WRITE_PRIVACY_SETTINGS, "Requires WRITE_PRIVACY_SETTINGS");
+        String value = enable ? PrivacyPersistenceAdapter.VALUE_TRUE : PrivacyPersistenceAdapter.VALUE_FALSE;
+        if (persistenceAdapter.setValue(PrivacyPersistenceAdapter.SETTING_ENABLED, value)) {
+            this.enabled = true;
+            return true;
+        } else {
+            return false;
+        }
+    }
+    
+    public void toggleDebugMode (boolean state) {
+    	PrivacyDebugger.setDebuggerState(state, context);
+    }
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/PrivacyWatchDog.java pang/frameworks/base/privacy/java/android/privacy/PrivacyWatchDog.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/PrivacyWatchDog.java	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/base/privacy/java/android/privacy/PrivacyWatchDog.java	2013-03-05 15:56:29.841000261 +0545
@@ -0,0 +1,213 @@
+package android.privacy;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import android.os.FileObserver;
+import android.privacy.utilities.PrivacyDebugger;
+/**
+ * Copyright (C) 2012-2013 Stefan Thiele (CollegeDev)
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+public final class PrivacyWatchDog extends FileObserver {
+
+	private static final String TAG = "PrivacyWatchDog";
+	
+	private static final String WATCH_PATH = "/data/system/privacy.db";
+	
+	private PrivacyWatchDogInterface callBack;
+	
+	/**
+	 * intent data key
+	 */
+	public static final String MSG_WHAT_INT = "msg_what_i";
+	
+	/**
+	 * intent data key
+	 */
+	public static final String MSG_WHAT_STRING = "msg_what_s";
+	
+	/**
+	 * intent data key, this key contains an ArrayList with all packageNames inside for which
+	 * we wasn't able to restore the settings.
+	 */
+	public static final String MSG_RECOVERY_FAIL_INFO = "rc_info";
+
+	/**
+	 * MSG will be attached in callBack if someone changed the database
+	 */
+	public static final int MSG_DATABASE_MODIFY = 1;
+	/**
+	 * MSG will be attached in CallBack if someone deleted the database
+	 */
+	public static final int MSG_DATABASE_DELETED = 2;
+	/**
+	 * MSG will be attached in CallBack if someone moved the database
+	 */
+	public static final int MSG_DATABASE_MOVED = 3;
+	
+	private static final Random random = new Random();
+	
+	
+	//private boolean authorizedSave = false;
+	
+	private AtomicInteger authorizedSave = new AtomicInteger();
+	
+	
+	/**
+	 * Constructor
+	 * @param iface current callBack interface
+	 */
+	public PrivacyWatchDog(PrivacyWatchDogInterface iface) {
+		super(WATCH_PATH);
+		callBack = iface;
+		PrivacyDebugger.i(TAG,"initalized watchdog!");
+		this.startWatching();
+		PrivacyDebugger.i(TAG,"started watching on database");
+	}
+	
+	/**
+	 * Use this constructor if the onWatchDogFinalize callback gets a call.
+	 * It can happen that the watchdog gets finalize during an authorized db access, 
+	 * @param iface
+	 * @param authorizedAccessInProgress true if currently there is one authorized access in progress, false otherwise
+	 */
+	public PrivacyWatchDog(PrivacyWatchDogInterface iface, int authorizedAccessInProgress) {
+		super(WATCH_PATH);
+		callBack = iface;
+		PrivacyDebugger.i(TAG,"Constructor called because watchdog finalized. AuthorizedAccessInProgress: " + authorizedAccessInProgress);
+		if(authorizedAccessInProgress > 0)
+			authorizedSave.set(authorizedAccessInProgress);
+		else
+			authorizedSave.set(0);
+		this.startWatching();
+		PrivacyDebugger.i(TAG,"started watching on database");
+	}
+	
+	/**
+	 * Sets the current interface
+	 * @param iface current callBack interface
+	 */
+	public void setInterface(PrivacyWatchDogInterface iface) {
+		callBack = iface;
+	}
+
+	@Override
+	public void onEvent(int event, String path) {
+
+	    //data was written to a file
+	    if ((FileObserver.MODIFY & event) != 0) {
+	    	PrivacyDebugger.w(TAG, "detected database modified");
+	    	if (authorizedSave.get() > 0) {
+	    		PrivacyDebugger.i(TAG, "user is authorized to modify database, do not inform adapter!");
+	    	} else {
+	    		PrivacyDebugger.w(TAG, "inform adapter about modified database");
+	    		callBack.onUnauthorizedDatabaseAccess(MSG_DATABASE_MODIFY);
+	    	}
+	    }
+	    //the monitored file or directory was deleted, monitoring effectively stops
+	    if ((FileObserver.DELETE_SELF & event) != 0) {
+	    	PrivacyDebugger.w(TAG, "detected database deleted");
+	    	callBack.onUnauthorizedDatabaseAccess(MSG_DATABASE_DELETED);
+	    }
+	    //the monitored file or directory was moved; monitoring continues
+	    if ((FileObserver.MOVE_SELF & event) != 0) {
+	    	PrivacyDebugger.w(TAG, "detected database moved");
+	    	callBack.onUnauthorizedDatabaseAccess(MSG_DATABASE_MOVED);
+	    }
+
+	}
+	
+	@Override
+	public void finalize () {
+		// shit-> inform service about that :-/
+		try {
+			callBack.onWatchDogFinalize(authorizedSave.get());
+		} catch(Exception e) {
+			PrivacyDebugger.e(TAG, "can't inform that WatchDog g finalized!", e);
+		}
+		try {
+			super.finalize();
+		} catch(Exception e) {
+			//nothing here
+		}
+	}
+	
+	/**
+	 * Call this method at the beginning of authorized database accesses
+	 */
+	public synchronized void onBeginAuthorizedTransaction() {
+		int temp = authorizedSave.incrementAndGet();
+		PrivacyDebugger.i(TAG,"onBeginAuthorizedTransaction() - authorized threads: " + temp);
+	}
+	
+	/**
+	 * Call this method at the end of authorized database accesses
+	 */
+	public synchronized void onEndAuthorizedTransaction() {
+		// we need to operate with threads -> since on some device the database accesses are modified to multithreading, we have to
+		// do this here. TODO: find better solution like extend from openhelper?
+		new Thread (new Runnable() {
+		    public void run() {
+		    	try {
+		    		Thread.sleep(800); //now wait 1 seconds! (modify time? to lower value?)
+		    	} catch (Exception e) {
+		    		// nothing here
+		    	}
+		    	PrivacyDebugger.i(TAG,"onEndAuthorizedTransaction() - authorized threads: " + authorizedSave.decrementAndGet());
+		    }
+		}).start();
+	}
+	
+	/**
+	 * Converts callBack message to readable string
+	 * @param msg callBack message
+	 * @return readable string for debug or whatever
+	 */
+	public String msgToString (int msg) {
+		switch(msg) {
+			case MSG_DATABASE_MODIFY:
+				return "database modified";
+			case MSG_DATABASE_DELETED:
+				return "database deleted";
+			case MSG_DATABASE_MOVED:
+				return "database moved";
+			default:
+				return "UNKNOWN";
+		}
+	}
+	
+	/**
+	 * WatchDog interface to handle UnauthorizedDatabaseAccesses
+	 * @author CollegeDev
+	 */
+	public interface PrivacyWatchDogInterface {
+		
+		/**
+		 * This method gets a call if someone tries to:
+		 * 		- Write to database and modifying permissions
+		 * 		- delete the database 
+		 * 		- moving the database
+		 */
+		public void onUnauthorizedDatabaseAccess(int MSG_WHAT);
+		
+		
+		/**
+		 * This method gets a call if our current watchDog gets finalize
+		 * -> WatchDog is stops watching, we have to initiate a new one
+		 * @param authorizedAccessInProgress is the last state of our internal authorizedSave variable
+		 */
+		public void onWatchDogFinalize(int authorizedAccessInProgress);
+		
+	}
+
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyAccountManager.java pang/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyAccountManager.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyAccountManager.java	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyAccountManager.java	2013-02-02 17:20:07.571238492 +0545
@@ -0,0 +1,345 @@
+package android.privacy.surrogate;
+
+import android.accounts.Account;
+import android.accounts.AccountManager;
+import android.accounts.AccountManagerCallback;
+import android.accounts.AccountManagerFuture;
+import android.accounts.AuthenticatorException;
+import android.accounts.IAccountManager;
+import android.accounts.OperationCanceledException;
+import android.app.Activity;
+import android.content.Context;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+/**
+ * Provides privacy handling for {@link android.accounts.AccountManager}
+ * @author Svyatoslav Hresyk; modified & improved by CollegeDev (Stefan. T)
+ * {@hide}
+ */
+public final class PrivacyAccountManager extends AccountManager {
+    
+    private static final String TAG = "PrivacyAccountManager";
+    
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+
+    /** {@hide} */
+    public PrivacyAccountManager(Context context, IAccountManager service) {
+        super(context, service);
+        this.context = context;
+        pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));  
+    }
+
+    /** {@hide} */
+    public PrivacyAccountManager(Context context, IAccountManager service, Handler handler) {
+        super(context, service, handler);
+        this.context = context;
+        pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));        
+    }
+
+    /**
+     * GET_ACCOUNTS
+     */
+    
+    @Override
+    public Account[] getAccounts() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output_label;
+        Account[] output;
+        
+        if (pSet != null && pSet.getAccountsSetting() != PrivacySettings.REAL) {
+            output_label = "[empty accounts list]";
+            output = new Account[0];
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+            else
+            	pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        } else {
+            output_label = "[real value]";
+            output = super.getAccounts(); 
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+            else
+            	pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        }
+        
+        PrivacyDebugger.d(TAG, "getAccounts - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);        
+        return output;
+    }
+
+    @Override
+    public Account[] getAccountsByType(String type) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output_label;
+        Account[] output;
+        
+        if (pSet != null && pSet.getAccountsSetting() != PrivacySettings.REAL) {
+            output_label = "[empty accounts list]";
+            output = new Account[0];
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+            else
+            	pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        } else {
+            output_label = "[real value]";
+            output = super.getAccountsByType(type);
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+            else
+            	pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        }
+        
+        PrivacyDebugger.d(TAG, "getAccountsByType - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);        
+        return output;
+    }
+    
+    @Override
+    public AccountManagerFuture<Boolean> hasFeatures(Account account, String[] features,
+            AccountManagerCallback<Boolean> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);        
+        String output_label;
+        AccountManagerFuture<Boolean> output;
+        
+        if (pSet != null && pSet.getAccountsSetting() != PrivacySettings.REAL) {
+            output_label = "[false]";
+            output = new PrivacyAccountManagerFuture<Boolean>(false);
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);      
+            else	
+            	pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);      
+        } else {
+            output_label = "[real value]";
+            output = super.hasFeatures(account, features, callback, handler);
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);            
+            else
+            	pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);            
+        }
+        
+        PrivacyDebugger.d(TAG, "hasFeatures - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);        
+        return output;
+    }
+
+    @Override
+    public AccountManagerFuture<Account[]> getAccountsByTypeAndFeatures(String type, String[] features,
+            AccountManagerCallback<Account[]> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);       
+        String output_label;
+        AccountManagerFuture<Account[]> output;
+        
+        if (pSet != null && pSet.getAccountsSetting() != PrivacySettings.REAL) {
+            output_label = "[false]";
+            output = new PrivacyAccountManagerFuture<Account[]>(new Account[0]);
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);   
+            else
+            	pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);   
+        } else {
+            output_label = "[real value]";
+            output = super.getAccountsByTypeAndFeatures(type, features, callback, handler);
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);   
+            else
+            	pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet); 
+        }
+        
+        PrivacyDebugger.d(TAG, "getAccountsByTypeAndFeatures - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);           
+        return output;
+    }
+    
+    /**
+     * USE_CREDENTIALS
+     */
+    
+    @Override
+    public String blockingGetAuthToken(Account account, String authTokenType, boolean notifyAuthFailure)
+            throws OperationCanceledException, IOException, AuthenticatorException {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);    
+        String output;
+        
+        if (pSet != null && pSet.getAccountsAuthTokensSetting() != PrivacySettings.REAL) {
+            output = null;
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+            else
+            	pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+            	
+        } else {
+            output = super.blockingGetAuthToken(account, authTokenType, notifyAuthFailure);
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_AUTH_TOKENS, null, pSet); 
+            else
+            	pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_AUTH_TOKENS, null, pSet); 
+        }
+        
+        PrivacyDebugger.d(TAG, "blockingGetAuthToken - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " 
+                + (output == null ? "[null]" : output));
+        return output;
+    }
+
+    @Override
+    public AccountManagerFuture<Bundle> getAuthToken(Account account, String authTokenType, boolean notifyAuthFailure,
+            AccountManagerCallback<Bundle> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);   
+        String output_label;
+        AccountManagerFuture<Bundle> output;
+        
+        if (pSet != null && pSet.getAccountsAuthTokensSetting() != PrivacySettings.REAL) {
+            output_label = "[empty]";
+            output = new PrivacyAccountManagerFuture<Bundle>(new Bundle());
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);     
+            else
+            	pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);     
+        } else {
+            output_label = "[real value]";
+            output = super.getAuthToken(account, authTokenType, notifyAuthFailure, callback, handler);
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);    
+            else
+            	pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);    
+        }
+        
+        PrivacyDebugger.d(TAG, "getAuthToken - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);           
+        return output;
+    }
+
+    @Override
+    public AccountManagerFuture<Bundle> getAuthToken(Account account, String authTokenType, Bundle options,
+            Activity activity, AccountManagerCallback<Bundle> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);   
+        String output_label;
+        AccountManagerFuture<Bundle> output;
+        
+        if (pSet != null && pSet.getAccountsAuthTokensSetting() != PrivacySettings.REAL) {
+            output_label = "[empty]";
+            output = new PrivacyAccountManagerFuture<Bundle>(new Bundle());
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+            else
+            	pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);    
+        } else {
+            output_label = "[real value]";
+            output = super.getAuthToken(account, authTokenType, options, activity, callback, handler);
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_AUTH_TOKENS, null, pSet); 
+            else
+            	pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_AUTH_TOKENS, null, pSet); 
+        }
+        
+        PrivacyDebugger.d(TAG, "getAuthToken - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);           
+        return output;
+    }
+
+    /**
+     * MANAGE_ACCOUNTS
+     */
+    
+    @Override
+    public AccountManagerFuture<Bundle> getAuthTokenByFeatures(String accountType, String authTokenType,
+            String[] features, Activity activity, Bundle addAccountOptions, Bundle getAuthTokenOptions,
+            AccountManagerCallback<Bundle> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);   
+        String output_label;
+        AccountManagerFuture<Bundle> output;
+        
+        if (pSet != null && pSet.getAccountsAuthTokensSetting() != PrivacySettings.REAL) {
+            output_label = "[empty]";
+            output = new PrivacyAccountManagerFuture<Bundle>(new Bundle());
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);   
+            else
+            	pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);   
+            	
+        } else {
+            output_label = "[real value]";
+            output = super.getAuthTokenByFeatures(accountType, authTokenType, features, activity, addAccountOptions,
+                    getAuthTokenOptions, callback, handler);
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+            else
+            	pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);  
+        }
+        
+        PrivacyDebugger.d(TAG, "getAuthTokenByFeatures - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);           
+        return output;
+    }
+    
+    /**
+     * Helper class. Used for returning custom values to AccountManager callers.
+     */
+    private class PrivacyAccountManagerFuture<V> implements AccountManagerFuture<V> {
+        
+        private V result;
+        
+        public PrivacyAccountManagerFuture(V result) {
+            this.result = result;
+        }
+
+        @Override
+        public boolean cancel(boolean mayInterruptIfRunning) {
+            return false;
+        }
+
+        @Override
+        public V getResult() throws OperationCanceledException, IOException, AuthenticatorException {
+            return result;
+        }
+
+        @Override
+        public V getResult(long timeout, TimeUnit unit) throws OperationCanceledException, IOException,
+                AuthenticatorException {
+            return result;
+        }
+
+        @Override
+        public boolean isCancelled() {
+            return false;
+        }
+
+        @Override
+        public boolean isDone() {
+            return true;
+        }
+        
+    }
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyActivityManagerService.java pang/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyActivityManagerService.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyActivityManagerService.java	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyActivityManagerService.java	2013-02-02 17:23:36.851912161 +0545
@@ -0,0 +1,402 @@
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.content.Intent;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+/**
+ * Provides privacy handling for {@link com.android.server.am.ActivityManagerService}
+ * @author Svyatoslav Hresyk; modified & improved by CollegeDev (Stefan T.)
+ * {@hide}
+ */
+public final class PrivacyActivityManagerService {
+    
+    private static final String TAG = "PrivacyActivityManagerService";
+    
+    private static PrivacySettingsManager pSetMan;
+    
+    private static Intent tmpIn;
+    private static long tmpInHash = 0;
+    private static int tmpInReceivers = 0;
+    
+    private static Intent tmpOut;
+    private static long tmpOutHash = 0;
+    private static int tmpOutReceivers = 0;
+    
+    private static Intent tmpSms;
+    private static long tmpSmsHash = 0;
+    private static int tmpSmsReceivers = 0;
+    
+    private static Intent tmpMms;
+    private static long tmpMmsHash = 0;
+    private static int tmpMmsReceivers = 0;
+    
+    private static long tmpPackageAddedHash = 0;
+    
+
+    
+    /**
+     * Intercepts broadcasts and replaces the broadcast contents according to 
+     * privacy permissions
+     * @param packageName may not be null
+     * @param context if you use JellyBean, just pass NULL because all is splittet up to BroadcastQueue.java!!
+     * @param uid must be >= 0
+     * @param intent intent.getAction() may not return null
+     */
+    public static void enforcePrivacyPermission(String packageName, int uid, Intent intent, Context context, int receivers) {
+        if (pSetMan == null && context != null) pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+	if (pSetMan == null && context == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy"))); //we can pass null here
+        PrivacySettings pSet;
+        String action = intent.getAction();
+        String output;
+        // outgoing call
+        if (action.equals(Intent.ACTION_NEW_OUTGOING_CALL)) {
+            pSet = pSetMan.getSettings(packageName);
+            output = intent.getStringExtra(Intent.EXTRA_PHONE_NUMBER);
+            
+            // store the original version to supply real values to trusted applications
+            // since Android sends the same intent to multiple receivers
+            if (tmpOutHash != hashCode(intent)) {
+                tmpOut = (Intent)intent.clone();
+                tmpOutHash = hashCode(intent);
+                tmpOutReceivers = receivers;
+            }
+            
+            try {
+                if (pSet != null && pSet.getOutgoingCallsSetting() != PrivacySettings.REAL) {
+                    output = "";
+                    intent.putExtra(Intent.EXTRA_PHONE_NUMBER, output);
+                    if(pSet.isDefaultDenyObject())
+                    	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_OUTGOING_CALL, null, pSet);
+                    else
+                    	pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_OUTGOING_CALL, null, pSet);
+                } else if (tmpOutHash == hashCode(intent)) {
+                    // if this intent was stored before, get the real value since it could have been modified
+                    output = tmpOut.getStringExtra(Intent.EXTRA_PHONE_NUMBER);
+                    intent.putExtra(Intent.EXTRA_PHONE_NUMBER, output);
+                    if(pSet != null && pSet.isDefaultDenyObject())
+                    	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_OUTGOING_CALL, null, pSet);
+                    else
+                    	pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_OUTGOING_CALL, null, pSet);
+                }
+            } catch (Exception e) {
+                PrivacyDebugger.e(TAG, "failed to enforce intent broadcast permission. StackTrace: ", e);
+            }
+            
+            if (tmpOutReceivers > 1) {
+                tmpOutReceivers--;
+            } else { // free memory after all receivers have been served
+                tmpOut = null;
+            }
+            
+//            PrivacyDebugger.d(TAG, "broadcasting intent " + action + " - " + packageName + " (" + uid + ") output: " + output);
+        // incoming call
+        } else if (action.equals(TelephonyManager.ACTION_PHONE_STATE_CHANGED)
+                // the EXTRA_INCOMING_NUMBER is NOT only present when state is EXTRA_STATE_RINGING
+                // Android documentation is WRONG; the EXTRA_INCOMING_NUMBER will also be there when hanging up (IDLE?)
+                /* && intent.getStringExtra(TelephonyManager.EXTRA_STATE).equals(TelephonyManager.EXTRA_STATE_RINGING)*/) {
+            output = intent.getStringExtra(TelephonyManager.EXTRA_INCOMING_NUMBER);
+            // don't do anything if no incoming phone number is broadcasted
+            if (output == null || output.isEmpty()) return;
+            
+            pSet = pSetMan.getSettings(packageName, uid);
+            
+            if (tmpInHash != hashCode(intent)) {
+                tmpIn = (Intent)intent.clone();
+                tmpInHash = hashCode(intent);
+                tmpInReceivers = receivers;
+            }
+            
+            try {
+                if (pSet != null && pSet.getIncomingCallsSetting() != PrivacySettings.REAL) {
+                    output = "";
+                    intent.putExtra(TelephonyManager.EXTRA_INCOMING_NUMBER, output);
+                    if(pSet.isDefaultDenyObject())
+                    	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_INCOMING_CALL, null, pSet);
+                    else
+                    	pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_INCOMING_CALL, null, pSet);
+                } else if (tmpInHash == hashCode(intent)) {
+                    output = tmpIn.getStringExtra(TelephonyManager.EXTRA_INCOMING_NUMBER);
+                    intent.putExtra(TelephonyManager.EXTRA_INCOMING_NUMBER, output);
+                    if(pSet != null && pSet.isDefaultDenyObject())
+                    	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_INCOMING_CALL, null, pSet);
+                    else
+                    	pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_INCOMING_CALL, null, pSet);
+                }
+            } catch (Exception e) {
+                PrivacyDebugger.e(TAG, "failed to enforce intent broadcast permission. StackTrace: " + Log.getStackTraceString(e));
+            }
+            
+            if (tmpInReceivers > 1) {
+                tmpInReceivers--;
+            } else { // free memory after all receivers have been served
+                tmpIn = null;
+            }
+            
+//            PrivacyDebugger.d(TAG, "broadcasting intent " + action + " - " + packageName + " (" + uid + ") output: " + output);
+        // incoming SMS
+        } else if (action.equals(Sms.Intents.SMS_RECEIVED_ACTION)) {
+            pSet = pSetMan.getSettings(packageName, uid);
+            output = "[real]";
+//            PrivacyDebugger.d(TAG, "package: " + packageName + " uid: " + uid);
+            
+            Object[] o = ((Object[])intent.getSerializableExtra("pdus"));
+            byte[] b = o != null ? (byte[])o[0] : null;
+            
+            if (tmpSmsHash != hashCode(intent)) {
+                tmpSms = (Intent)intent.clone();
+                tmpSmsHash = hashCode(intent);
+                tmpSmsReceivers = receivers;
+//                PrivacyDebugger.d(TAG, "new intent; saving copy: receivers: " + receivers + " hash: " + tmpSmsHash + " " + 
+//                        "pdu number: " + (o != null ? o.length : "null") + " " + 
+//                        "1st pdu length: " + (b != null ? b.length : "null"));
+            } else {
+//                PrivacyDebugger.d(TAG, "known intent; hash: " + hashCode(intent) + " remaining receivers: " + tmpSmsReceivers);
+            }
+            
+            try {
+                if (pSet != null && pSet.getSmsSetting() != PrivacySettings.REAL) {
+                    output = "[empty]";
+                    
+                    Object[] emptypdusObj = new Object[1];
+                    emptypdusObj[0] = (Object) new byte[] {0,32,1,-127,-16,0,0,17,-112,1,48,34,34,-128,1,32};
+                    intent.putExtra("pdus", emptypdusObj);
+                    
+//                    PrivacyDebugger.d(TAG, "permission denied, replaced pdu; pdu number: " + 
+//                            (o != null ? o.length : "null") + " " +
+//                        "1st pdu length:" + (b != null ? b.length : "null"));
+                    if(pSet.isDefaultDenyObject())
+                    	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_SMS, null, pSet);
+                    else
+                    	pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_SMS, null, pSet);
+                } else if (tmpSmsHash == hashCode(intent)) {
+                    intent.putExtra("pdus", tmpSms.getSerializableExtra("pdus"));
+                    
+                    o = ((Object[])intent.getSerializableExtra("pdus"));
+                    b = o != null ? (byte[])o[0] : null;
+//                    PrivacyDebugger.d(TAG, "permission granted, inserting saved pdus; pdu number: " + 
+//                            (o != null ? o.length : "null") + " " +
+//                            "1st pdu length:" + (b != null ? b.length : "null"));
+                    if(pSet != null && pSet.isDefaultDenyObject())
+                    	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_SMS, null, pSet);
+                    else
+                    	pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SMS, null, pSet);
+                }
+            } catch (Exception e) {
+                PrivacyDebugger.e(TAG, "failed to enforce intent broadcast permission. Stack Trace: " + Log.getStackTraceString(e));
+            }
+            
+            if (tmpSmsReceivers > 1) {
+                tmpSmsReceivers--;
+            } else { // free memory after all receivers have been served
+//                PrivacyDebugger.d(TAG, "removing intent with hash: " + tmpSmsHash);
+                tmpSms = null;
+            }            
+            
+//            PrivacyDebugger.d(TAG, "broadcasting intent " + action + " - " + packageName + " (" + uid + ") output: " + output);
+        // incoming MMS
+        } else if (action.equals(Sms.Intents.WAP_PUSH_RECEIVED_ACTION) ||
+                action.equals(Sms.Intents.DATA_SMS_RECEIVED_ACTION)) {
+            pSet = pSetMan.getSettings(packageName, uid);
+            output = "[real]";
+            
+            Object[] o = ((Object[])intent.getSerializableExtra("pdus"));
+            byte[] b = o != null ? (byte[])o[0] : null;
+            
+            // TODO: remove unnecessary receivers count
+            if (tmpMmsHash != hashCode(intent)) {
+                tmpMms = (Intent)intent.clone();
+                tmpMmsHash = hashCode(intent);
+                tmpMmsReceivers = receivers;
+//                PrivacyDebugger.d(TAG, "new intent; saving copy: receivers: " + receivers + " hash: " + tmpMmsHash + " " + 
+//                        "pdu number: " + (o != null ? o.length : "null") + " " + 
+//                        "1st pdu length: " + (b != null ? b.length : "null"));
+            } else {
+//                PrivacyDebugger.d(TAG, "known intent; hash: " + hashCode(intent) + " remaining receivers: " + tmpMmsReceivers);
+            }
+            
+            try {
+                if (pSet != null && pSet.getMmsSetting() != PrivacySettings.REAL) {
+                    output = "[empty]";
+                    
+                    Object[] emptypdusObj = new Object[1];
+                    emptypdusObj[0] = (Object) new byte[] {0,32,1,-127,-16,0,0,17,-112,1,48,34,34,-128,1,32};
+                    intent.putExtra("pdus", emptypdusObj);
+                    if(pSet.isDefaultDenyObject())
+                    	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_MMS, null, pSet);
+                    else
+                    	pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_MMS, null, pSet);
+                } else if (tmpMmsHash == hashCode(intent)) {
+                    intent.putExtra("pdus", tmpMms.getSerializableExtra("pdus"));
+                    
+                    o = ((Object[])intent.getSerializableExtra("pdus"));
+                    b = o != null ? (byte[])o[0] : null;
+//                    PrivacyDebugger.d(TAG, "permission granted, inserting saved pdus; pdu number: " + 
+//                            (o != null ? o.length : "null") + " " +
+//                            "1st pdu length:" + (b != null ? b.length : "null"));
+                    if(pSet != null && pSet.isDefaultDenyObject())
+                    	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_MMS, null, pSet);
+                    else
+                    	pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_MMS, null, pSet);
+                }
+            } catch (Exception e) {
+                PrivacyDebugger.e(TAG, "failed to enforce intent broadcast permission. StackTrace: " + Log.getStackTraceString(e));
+            }
+            
+            if (tmpMmsReceivers > 1) {
+                tmpMmsReceivers--;
+            } else { // free memory after all receivers have been served
+//                PrivacyDebugger.d(TAG, "removing intent with hash: " + tmpMmsHash);
+                tmpMms = null;
+            }
+            
+//            PrivacyDebugger.d(TAG, "broadcasting intent " + action + " - " + packageName + " (" + uid + ") output: " + output);
+        } else if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
+            pSetMan.setBootCompleted();
+            
+            pSet = pSetMan.getSettings(packageName);
+            
+            if (pSet != null && pSet.getIntentBootCompletedSetting() != PrivacySettings.REAL) {
+                //no notification since all applications will receive this -> spam
+                intent.setAction("catchBootComplete");
+		//PrivacyDebugger.i(TAG,"package: " + packageName + " blocked INTENT_BOOT_COMPLETE");
+                //intent.setPackage("com.android.privacy.pdroid.extension");
+                if(pSet.isDefaultDenyObject())
+                	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_INTENT_BOOT_COMPLETED, null, null);
+                else
+                	pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_INTENT_BOOT_COMPLETED, null, null);
+            } else {
+                intent.setAction(Intent.ACTION_BOOT_COMPLETED);
+		//PrivacyDebugger.i(TAG,"package: " + packageName + " allowed INTENT_BOOT_COMPLETE");
+                if(pSet != null && pSet.isDefaultDenyObject())
+                	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_INTENT_BOOT_COMPLETED, null, null);
+                else
+                	pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_INTENT_BOOT_COMPLETED, null, null);
+            }
+        } else if (action.equals(Intent.ACTION_PACKAGE_ADDED)) {
+//            PrivacyDebugger.d(TAG, "enforcePrivacyPermission - ACTION_PACKAGE_ADDED; receivers: " + receivers);
+            
+            // update privacy settings; only do this once for a single Intent
+            if (tmpPackageAddedHash != hashCode(intent)) {
+                tmpPackageAddedHash = hashCode(intent);
+                
+                String addedPackageName = intent.getData().getSchemeSpecificPart();
+                int addedUid = intent.getExtras().getInt(Intent.EXTRA_UID);
+//                PrivacyDebugger.d(TAG, "enforcePrivacyPermission - installed package " + addedPackageName + " " + addedUid);
+                pSet = pSetMan.getSettings(addedPackageName, addedUid);
+                // the settings in the privacy DB contain a different UID
+                if (pSet != null && pSet.getUid() != addedUid) { // update the UID
+//                    PrivacyDebugger.i(TAG, "installed package UID (" + addedUid + ") doesn't match privacy settings UID (" + pSet.getUid() + "); updating...");
+                    pSet.setUid(addedUid);
+                    /*boolean updateSuccess = */pSetMan.saveSettings(pSet);
+//                    if (!updateSuccess) PrivacyDebugger.w(TAG, "could not update privacy settings UID; purge needed");
+                }
+            }
+        }
+    }
+    
+    private static long hashCode(Intent intent) {
+        long privacyHash = intent.getLongExtra("privacy_hash", 0);
+        if (privacyHash == 0) {
+            privacyHash = intent.filterHashCode() + System.currentTimeMillis();
+            intent.putExtra("privacy_hash", privacyHash);
+        }
+        return privacyHash;
+    }
+    
+    /**
+     * Contains info about SMS related Intents that are broadcast.
+     * 
+     * @author CollegeDev (Stefan T.)
+     * @sidenote: Please note that this class is only temporary copied -> normally this constants does not update, but from version to version 
+     * we have to take a look at it!
+     */
+    private  final class Sms {
+    	 private final class Intents {
+    	        /**
+    	         * Broadcast Action: A new text based SMS message has been received
+    	         * by the device. The intent will have the following extra
+    	         * values:</p>
+    	         *
+    	         * <ul>
+    	         *   <li><em>pdus</em> - An Object[] od byte[]s containing the PDUs
+    	         *   that make up the message.</li>
+    	         * </ul>
+    	         *
+    	         * <p>The extra values can be extracted using
+    	         * {@link #getMessagesFromIntent(Intent)}.</p>
+    	         *
+    	         * <p>If a BroadcastReceiver encounters an error while processing
+    	         * this intent it should set the result code appropriately.</p>
+    	         */
+    	        private final static String SMS_RECEIVED_ACTION =
+    	                "android.provider.Telephony.SMS_RECEIVED";
+
+    	        /**
+    	         * Broadcast Action: A new data based SMS message has been received
+    	         * by the device. The intent will have the following extra
+    	         * values:</p>
+    	         *
+    	         * <ul>
+    	         *   <li><em>pdus</em> - An Object[] of byte[]s containing the PDUs
+    	         *   that make up the message.</li>
+    	         * </ul>
+    	         *
+    	         * <p>The extra values can be extracted using
+    	         * {@link #getMessagesFromIntent(Intent)}.</p>
+    	         *
+    	         * <p>If a BroadcastReceiver encounters an error while processing
+    	         * this intent it should set the result code appropriately.</p>
+    	         */
+    	        private final static String DATA_SMS_RECEIVED_ACTION =
+    	                "android.intent.action.DATA_SMS_RECEIVED";
+
+    	        /**
+    	         * Broadcast Action: A new WAP PUSH message has been received by the
+    	         * device. The intent will have the following extra
+    	         * values:</p>
+    	         *
+    	         * <ul>
+    	         *   <li><em>transactionId (Integer)</em> - The WAP transaction ID</li>
+    	         *   <li><em>pduType (Integer)</em> - The WAP PDU type</li>
+    	         *   <li><em>header (byte[])</em> - The header of the message</li>
+    	         *   <li><em>data (byte[])</em> - The data payload of the message</li>
+    	         *   <li><em>contentTypeParameters (HashMap&lt;String,String&gt;)</em>
+    	         *   - Any parameters associated with the content type
+    	         *   (decoded from the WSP Content-Type header)</li>
+    	         * </ul>
+    	         *
+    	         * <p>If a BroadcastReceiver encounters an error while processing
+    	         * this intent it should set the result code appropriately.</p>
+    	         *
+    	         * <p>The contentTypeParameters extra value is map of content parameters keyed by
+    	         * their names.</p>
+    	         *
+    	         * <p>If any unassigned well-known parameters are encountered, the key of the map will
+    	         * be 'unassigned/0x...', where '...' is the hex value of the unassigned parameter.  If
+    	         * a parameter has No-Value the value in the map will be null.</p>
+    	         */
+    	        private final static String WAP_PUSH_RECEIVED_ACTION =
+    	                "android.provider.Telephony.WAP_PUSH_RECEIVED";
+
+    	    }
+    }
+   
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyConnectivityManager.java pang/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyConnectivityManager.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyConnectivityManager.java	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyConnectivityManager.java	2013-02-03 20:35:47.991933977 +0545
@@ -0,0 +1,312 @@
+package android.privacy.surrogate;
+
+import java.net.InetAddress;
+
+import android.content.Context;
+import android.net.ConnectivityManager;
+import android.net.IConnectivityManager;
+import android.net.LinkProperties;
+import android.net.NetworkInfo;
+import android.os.Binder;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+import android.util.Log;
+
+/**
+ * Copyright (C) 2012-2013 Stefan Thiele (CollegeDev)
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev (Stefan T.)
+ * {@hide}
+ */
+public class PrivacyConnectivityManager extends ConnectivityManager{
+
+	private static final String P_TAG = "PrivacyConnectivityManager";
+	
+	private Context context;
+	
+	private PrivacySettingsManager pSetMan;
+	
+	public PrivacyConnectivityManager(IConnectivityManager service, Context context) {
+		super(service);
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		PrivacyDebugger.i(P_TAG,"now in constructor for package: " + context.getPackageName());
+	}
+	
+	@Override
+	public boolean getMobileDataEnabled() {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			return true;
+		}
+//		} else if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+//			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+//			return false;
+//		}
+		else {
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return super.getMobileDataEnabled();
+		}
+			
+	}
+	
+	@Override
+	public void setMobileDataEnabled(boolean enabled) {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getSwitchConnectivitySetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_SWITCH_CONNECTIVITY, null, null);
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_SWITCH_CONNECTIVITY, null, null);
+			//do nothing
+		} else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_SWITCH_CONNECTIVITY, null, null);
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_SWITCH_CONNECTIVITY, null, null);
+			super.setMobileDataEnabled(enabled);
+		}
+	}
+	
+	@Override
+	public NetworkInfo[] getAllNetworkInfo() {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		NetworkInfo output[] =  {new NetworkInfo(TYPE_MOBILE, 0, "MOBILE", "CONNECTED")};
+		boolean forceOnline = false;
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL){
+			output[0].setIsAvailable(true); 
+			output[0].setState(NetworkInfo.State.CONNECTED);
+			forceOnline = true;
+		}
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL) {
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return output;
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+			output = super.getAllNetworkInfo();
+			if(forceOnline)
+				for(int i = 0; i < output.length; i++) {
+					output[i].setIsAvailable(true);
+					output[i].setState(NetworkInfo.State.CONNECTED);
+				}
+			return output;
+			//return super.getAllNetworkInfo();
+		}
+			
+	}
+	
+	@Override
+	public NetworkInfo getNetworkInfo(int networkType) {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		NetworkInfo output =  new NetworkInfo(TYPE_MOBILE, 0, "MOBILE", "CONNECTED");
+		boolean forceOnline = false;
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL){
+			output.setIsAvailable(true);
+			output.setState(NetworkInfo.State.CONNECTED);
+			forceOnline = true;
+		}
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return output;
+		}
+		else {
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+			output = super.getNetworkInfo(networkType);
+			if(forceOnline) {
+				output.setIsAvailable(true);
+				output.setState(NetworkInfo.State.CONNECTED);
+			}
+			return output;
+		}
+	}
+	
+	/**
+	 * {@hide}
+	 */
+	@Override
+	public NetworkInfo getActiveNetworkInfoForUid(int uid) {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		NetworkInfo output =  new NetworkInfo(TYPE_MOBILE, 0, "MOBILE", "UNKNOWN");
+		boolean forceOnline = false;
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL){
+			output.setIsAvailable(true);
+			output.setState(NetworkInfo.State.CONNECTED);
+			forceOnline = true;
+		}
+		
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+			return output;
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+			output = super.getActiveNetworkInfoForUid(uid);
+			if(forceOnline) {
+				output.setIsAvailable(true);
+				output.setState(NetworkInfo.State.CONNECTED);
+			}
+			return output;
+		}
+			
+	}
+	
+	@Override
+	public NetworkInfo getActiveNetworkInfo() {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		NetworkInfo output =  new NetworkInfo(TYPE_MOBILE, 0, "MOBILE", "UNKNOWN");
+		boolean forceOnline = false;
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL) {
+			output.setIsAvailable(true);
+			output.setState(NetworkInfo.State.CONNECTED);
+		}
+		
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL) {
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return output;
+		}
+		else { 
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			output = super.getActiveNetworkInfo();
+			if(forceOnline) {
+				output.setIsAvailable(true);
+				output.setState(NetworkInfo.State.CONNECTED);
+			}	
+			return output;
+		}
+			
+	}
+	
+	@Override
+	public LinkProperties getLinkProperties(int networkType) { //method to prevent getting device IP
+		LinkProperties output = new LinkProperties();
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL) {
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			return output;
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			return super.getLinkProperties(networkType);
+		}
+	}
+	
+	public LinkProperties getActiveLinkProperties() { //also for prevent getting device IP
+		LinkProperties output = new LinkProperties();
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return output;
+		}
+		else {
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			return super.getActiveLinkProperties();
+		}
+	}
+	
+	@Override
+	public boolean requestRouteToHost(int networkType, int hostAddress){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL) {
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return true;
+		} else if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL) {
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			return false;
+		} else {
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			return super.requestRouteToHost(networkType, hostAddress);
+		}
+	}
+	
+	@Override
+	public boolean requestRouteToHostAddress(int networkType, InetAddress hostAddress){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+			return true;
+		} else if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return false;
+		} else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			return super.requestRouteToHostAddress(networkType, hostAddress);
+		}
+	}
+	
+
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyContentResolver.java pang/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyContentResolver.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyContentResolver.java	1970-01-01 05:30:00.000000000 +0530
<<<<<<< HEAD
+++ pang/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyContentResolver.java	2013-05-08 00:45:55.628971329 +0545
=======
+++ pang/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyContentResolver.java	2013-05-05 11:40:04.594983454 +0545
>>>>>>> d58798c4398364be568f6b7d85432204628d2969
@@ -0,0 +1,302 @@
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Binder;
+import android.os.RemoteException;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+import android.provider.Browser;
+import android.provider.CalendarContract;
+import android.provider.CallLog;
+import android.provider.ContactsContract;
+
+
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+/**
+ * Provides privacy handling for {@link android.content.ContentResolver}
+ * @author Svyatoslav Hresyk; modified & improved by CollegeDev (Stefan. T)
+ * {@hide}
+ */
+public final class PrivacyContentResolver {
+    
+    private static final String TAG = "PrivacyContentResolver";
+    
+    private static final Uri MMS_CONTENT_URI = Uri.parse("content://mms");
+    
+    private static final Uri MMS_SMS_CONTENT_URI = Uri.parse("content://mms-sms/");
+    
+    private static final Uri SMS_CONTENT_URI = Uri.parse("content://sms");
+    
+    
+    private static PrivacySettingsManager pSetMan;
+    
+    /**
+     * Returns a dummy database cursor if access is restricted by privacy settings
+     * @param uri
+     * @param context
+     * @param realCursor
+     */
+    public static Cursor enforcePrivacyPermission(Uri uri, String[] projection, Context context, Cursor realCursor) throws RemoteException {
+//    public static Cursor enforcePrivacyPermission(Uri uri, Context context, Cursor realCursor) {
+        if (uri != null) {
+            if (pSetMan == null) pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+            String packageName = context.getPackageName();
+            int uid = Binder.getCallingUid();
+            PrivacySettings pSet = pSetMan.getSettings(packageName);
+            String auth = uri.getAuthority();
+            String output_label = "[real]";
+            Cursor output = realCursor;
+            if (auth != null) {
+                if (auth.equals(android.provider.Contacts.AUTHORITY) || auth.equals(ContactsContract.AUTHORITY)) {
+
+                    if (pSet != null) {
+                        if (pSet.getContactsSetting() == PrivacySettings.EMPTY) {
+                            output_label = "[empty]";
+                            output = new PrivacyCursor();
+                            if(pSet.isDefaultDenyObject())
+                            	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_CONTACTS, null, pSet);
+                            else
+                            	pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_CONTACTS, null, pSet);
+                            
+                        } else if (pSet.getContactsSetting() == PrivacySettings.CUSTOM && 
+                                uri.toString().contains(ContactsContract.Contacts.CONTENT_URI.toString())) {
+                            PrivacyDebugger.d(TAG, "enforcePrivacyPermission - URI: " + uri.toString() + " " + uri.getAuthority() + " " + uri.getEncodedAuthority() + " " + uri.getEncodedFragment() + " " + uri.getEncodedPath() + " " + uri.getEncodedQuery() + " " + uri.getEncodedSchemeSpecificPart() + " " + uri.getEncodedUserInfo() + " " + uri.getFragment() + " " + uri.getPath());
+//                            PrivacyDebugger.d(TAG, "enforcePrivacyPermission - projection: " + arrayToString(projection) + " selection: " + selection + " selectionArgs: " + arrayToString(selectionArgs));
+                            PrivacyDebugger.d(TAG, "enforcePrivacyPermission - cursor entries: " + output.getCount());
+                            
+                            boolean idFound = false;
+                            if (projection != null) {
+                                for (String p : projection) {
+                                    if (p.equals(ContactsContract.Contacts._ID)) {
+                                        idFound = true;
+                                        break;
+                                    }
+                                }
+                                
+//                                if (!idFound) { // add ID to projection
+//                                    String[] newProjection = new String[projection.length + 1];
+//                                    System.arraycopy(projection, 0, newProjection, 0, projection.length);
+//                                    newProjection[projection.length] = ContactsContract.Contacts._ID;
+//                                    projection = newProjection;
+//                                }
+                            }
+                            
+                            if (!idFound) {
+                                output = new PrivacyCursor();
+                            } else {
+//                            PrivacyDebugger.d(TAG, "enforcePrivacyPermission - new projection: " + arrayToString(projection) + " selection: " + selection + " selectionArgs: " + arrayToString(selectionArgs));
+                            
+                            // re-query
+//                            output = provider.query(uri, projection, selection, selectionArgs, sortOrder);
+                            PrivacyDebugger.d(TAG, "enforcePrivacyPermission - new cursor entries: " + output.getCount());
+                                output = new PrivacyCursor(output, pSet.getAllowedContacts());
+                            }
+                            if(pSet.isDefaultDenyObject())
+                            	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_CONTACTS, null, pSet);
+                            else
+                            	pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_CONTACTS, null, pSet);
+                        } else { // REAL
+                        	if(pSet.isDefaultDenyObject())
+                        		pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_CONTACTS, null, pSet);
+                        	else
+                        		pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_CONTACTS, null, pSet);
+                        }
+                    } else {
+                    	PrivacyDebugger.w(TAG, "pSet is NULL -> user doesn't saved an entry to database. Allow it.");
+//                    	switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+//                    		case PrivacySettings.DEFAULT_DENY_EMPTY:
+//                    		case PrivacySettings.DEFAULT_DENY_RANDOM:
+//                    			output = new PrivacyCursor();
+//                    			PrivacyDebugger.w(TAG,"default mode is empty or random. Set cursor to privacyCursor");
+//                    			break;
+//                    		case PrivacySettings.DEFAULT_DENY_REAL:
+//                    			//nothing here
+//                    			PrivacyDebugger.w(TAG,"default deny mode is real -> return real cursor");
+//                    			break;
+//                    	}
+//                    	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_CONTACTS, null, pSet);
+                    }
+                    
+                } else if (auth.equals(CalendarContract.AUTHORITY)) {
+                    
+                    if (pSet != null && pSet.getCalendarSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        if(pSet.isDefaultDenyObject())
+                        	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_CALENDAR, null, pSet);
+                        else
+                        	pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_CALENDAR, null, pSet);
+                    } else {
+                    	if(pSet != null && pSet.isDefaultDenyObject())
+                    		pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_CALENDAR, null, pSet);
+                    	else
+                    		pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_CALENDAR, null, pSet);
+                    }
+                    
+                } else if (auth.equals(MMS_CONTENT_URI.getAuthority())) {
+                    
+                    if (pSet != null && pSet.getMmsSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        if(pSet.isDefaultDenyObject())
+                        	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_MMS, null, pSet);
+                        else
+                        	pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_MMS, null, pSet);
+                    } else {
+                    	if(pSet != null && pSet.isDefaultDenyObject())
+                    		pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_MMS, null, pSet);
+                    	else
+                    		pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_MMS, null, pSet);
+                    }
+                    
+                } else if (auth.equals(SMS_CONTENT_URI.getAuthority())) {
+                    
+                    if (pSet != null && pSet.getSmsSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        if(pSet.isDefaultDenyObject())
+                        	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_SMS, null, pSet);
+                        else
+                        	pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_SMS, null, pSet);
+                    } else {
+                    	if(pSet != null && pSet.isDefaultDenyObject())
+                    		pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_SMS, null, pSet);
+                    	else
+                    		pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SMS, null, pSet);
+                    }
+                // all messages, sms and mms
+                } else if (auth.equals(MMS_SMS_CONTENT_URI.getAuthority()) || 
+                        auth.equals("mms-sms-v2") /* htc specific, accessed by system messages application */) { 
+                    
+                    // deny access if access to either sms, mms or both is restricted by privacy settings
+                    if (pSet != null && (pSet.getMmsSetting() == PrivacySettings.EMPTY || 
+                            pSet.getSmsSetting() == PrivacySettings.EMPTY)) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        if(pSet.isDefaultDenyObject())
+                        	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_MMS_SMS, null, pSet);
+                        else
+                        	pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_MMS_SMS, null, pSet);
+                    } else {
+                    	if(pSet != null && pSet.isDefaultDenyObject())
+                    		pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_MMS_SMS, null, pSet);
+                    	else
+                    		pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_MMS_SMS, null, pSet);
+                    }
+
+                } else if (auth.equals(CallLog.AUTHORITY)) {
+                    
+                    if (pSet != null && pSet.getCallLogSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        if(pSet.isDefaultDenyObject())
+                        	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_CALL_LOG, null, pSet);
+                        else
+                        	pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_CALL_LOG, null, pSet);
+                    } else {
+                    	if(pSet != null && pSet.isDefaultDenyObject())
+                    		pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_CALL_LOG, null, pSet);
+                    	else
+                    		pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_CALL_LOG, null, pSet);
+                    }
+
+                } else if (auth.equals(Browser.BOOKMARKS_URI.getAuthority())) {
+                    
+                    if (pSet != null && pSet.getBookmarksSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        if(pSet.isDefaultDenyObject())
+                        	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_BOOKMARKS, null, pSet);
+                        else
+                        	pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_BOOKMARKS, null, pSet);
+                    } else {
+                    	if(pSet != null && pSet.isDefaultDenyObject())
+                    		pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_BOOKMARKS, null, pSet);
+                    	else
+                    		pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_BOOKMARKS, null, pSet);
+                    }
+                    
+                }
+            }
+            PrivacyDebugger.d(TAG, "query - " + packageName + " (" + uid + ") auth: " + auth + " output: " + output_label);
+            return output;
+        }
+        return realCursor;
+    }
+    
+    private static String arrayToString(String[] array) {
+        StringBuffer sb = new StringBuffer();
+        if (array != null) for (String bla : array) sb.append("[" + bla + "]");
+        else return "";
+        return sb.toString();
+    }
+    /**
+     * This method is especially for faking android_id if google wants to read it in their privacy database
+     * @deprecated
+     * @param uri
+     * @param projection
+     * @param context
+     * @param realCursor
+     */
+    public static Cursor enforcePrivacyPermission(Uri uri, String[] projection, Context context, Cursor realCursor, boolean google_access) throws RemoteException {
+		if (uri != null) {
+	            if (pSetMan == null) pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+	            String packageName = context.getPackageName();
+	            PrivacySettings pSet = pSetMan.getSettings(packageName);
+	            String auth = uri.getAuthority();
+	            String output_label = "[real]";
+	            Cursor output = realCursor;
+	            if (auth != null && auth.equals("com.google.android.gsf.gservices")) {
+			
+					if (pSet != null && pSet.getSimInfoSetting() != PrivacySettings.REAL){
+						int actual_pos = realCursor.getPosition();
+						int forbidden_position = -1;
+						try{
+							for(int i=0;i<realCursor.getCount();i++){
+								realCursor.moveToNext();
+								if(realCursor.getString(0).equals("android_id")){
+									forbidden_position = realCursor.getPosition();
+									break;
+								}
+							}
+						} catch (Exception e){
+							PrivacyDebugger.e(TAG,"something went wrong while getting blocked permission for android id");
+						} finally{
+							realCursor.moveToPosition(actual_pos);
+							if(forbidden_position == -1) {PrivacyDebugger.i(TAG,"now we return real cursor, because forbidden_pos is -1"); return output;} //give realcursor, because there is no android_id to block
+						}
+						PrivacyDebugger.i(TAG,"now blocking google access to android id and give fake cursor. forbidden_position: " + forbidden_position);
+						output_label = "[fake]";
+						output = new PrivacyCursor(realCursor,forbidden_position);	
+						if(pSet.isDefaultDenyObject())
+							pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_SIM, null, pSet);
+						else
+							pSetMan.notification(packageName, 0, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_SIM, null, pSet);
+					} else {
+						PrivacyDebugger.i(TAG,"google is allowed to get real cursor");
+						if(pSet != null && pSet.isDefaultDenyObject())
+							pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_SIM, null, pSet);
+						else
+							pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_SIM, null, pSet);
+					}
+			    }
+			    return output;
+		}
+		return realCursor;   
+    }
+
+
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyCursor.java pang/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyCursor.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyCursor.java	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyCursor.java	2013-01-22 01:30:33.787861207 +0545
@@ -0,0 +1,496 @@
+package android.privacy.surrogate;
+
+import android.content.ContentResolver;
+import android.database.CharArrayBuffer;
+import android.database.ContentObserver;
+import android.database.Cursor;
+import android.database.DataSetObserver;
+import android.net.Uri;
+import android.os.Bundle;
+import android.privacy.utilities.PrivacyDebugger;
+import android.provider.ContactsContract;
+import android.util.Log;
+
+import java.util.Random;
+
+import java.math.BigInteger;
+import java.util.Map;
+
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+/**
+ * Dummy database cursor. Used by {@link android.privacy.surrogate.PrivacyContentResolver} 
+ * when access should be blocked without crashing the calling application (for this purpose none 
+ * of the methods returns null) or for fine-granular control of access to individual database entries.
+ * The latter may produce inconsistencies from the applicatin point of view based on getPosition()
+ * and moveToPosition().
+ * {@hide}
+ */
+public class PrivacyCursor implements Cursor {
+    
+    private Cursor realCursor;
+    
+    private int[] allowedIds;
+
+    private int blockedColumnAndroidID; 
+
+    private static final String[] mask = {"0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"};
+
+    private boolean googleCursor;
+    
+    private int[] allowedIdMapping;
+    
+    private final static String TAG = "PrivacyCursor";
+    
+    public PrivacyCursor() {
+    }
+    
+    /**
+     * 
+     * @param realCursor may not be null
+     * @param allowedIds
+     */
+    public PrivacyCursor(Cursor realCursor, int[] allowedIds) {
+        this.realCursor = (allowedIds == null || allowedIds.length == 0) ? null : realCursor;
+        this.allowedIds = allowedIds;
+        if (this.realCursor != null) {
+            int currentPos = this.realCursor.getPosition();
+            this.allowedIdMapping = new int[allowedIds.length];
+            int i = 0;
+            while (this.realCursor.moveToNext()) {
+                if (isAllowed(this.realCursor)) {
+                    allowedIdMapping[i] = this.realCursor.getPosition();
+                    i++;
+                }
+            }
+            this.realCursor.moveToPosition(currentPos);
+        }
+    }
+    /*
+     * This constructor is only for android_id	 
+     * @param blockedColumnAndroidID pass -11 if should block all, or the columnIndex where android_id is!
+     */
+    public PrivacyCursor(Cursor realCursor, int blockedColumnAndroidID){
+	if(blockedColumnAndroidID == -11)
+		this.realCursor = null;
+	else
+		this.realCursor = realCursor;
+	this.blockedColumnAndroidID = blockedColumnAndroidID;
+	this.googleCursor = true;
+	PrivacyDebugger.i(TAG,"constructor is ready for google cursor! forbidden_position: " + blockedColumnAndroidID);
+    }
+     
+    /**
+     * just create fakeID
+     * @return fake ID or null if something went wrong
+     */
+    private String getFakeID(){
+	try{
+		Random rand = new Random();
+		String output = "";
+		for(int i=0; i < 16;i++){
+			output += mask[rand.nextInt(15)];
+		}
+		return output;
+	} catch (Exception e){
+		PrivacyDebugger.e(TAG,"something went wrong with creating fake ID");
+		return null;
+	}
+    }
+
+    @Override
+    public void close() {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.close();
+    }
+
+    @Override
+    public void copyStringToBuffer(int columnIndex, CharArrayBuffer buffer) {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.copyStringToBuffer(columnIndex, buffer);
+    }
+
+    @Override
+    public void deactivate() {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.deactivate();
+    }
+
+    @Override
+    public byte[] getBlob(int columnIndex) {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getBlob(columnIndex);
+        return new byte[0];
+    }
+
+    @Override
+    public int getColumnCount() {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getColumnCount();
+        return 0;
+    }
+
+    @Override
+    public int getColumnIndex(String columnName) {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getColumnIndex(columnName);
+        return -1;
+    }
+
+    @Override
+    public int getColumnIndexOrThrow(String columnName) throws IllegalArgumentException {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getColumnIndexOrThrow(columnName);
+        return -1;
+    }
+
+    @Override
+    public String getColumnName(int columnIndex) {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getColumnName(columnIndex);
+        return "";
+    }
+
+    @Override
+    public String[] getColumnNames() {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getColumnNames();
+        return new String[] { "" };
+    }
+
+    @Override
+    public int getCount() {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+            PrivacyDebugger.d(TAG, "getCount: " + allowedIdMapping.length);
+            return allowedIdMapping.length;
+        }
+	else if (realCursor != null)
+	    return realCursor.getCount();
+        return 0;
+    }
+
+    @Override
+    public double getDouble(int columnIndex) {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getDouble(columnIndex);
+        return 0;
+    }
+
+    @Override
+    public Bundle getExtras() {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getExtras();
+        return new Bundle();
+    }
+
+    @Override
+    public float getFloat(int columnIndex) {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getFloat(columnIndex);
+        return 0;
+    }
+
+    @Override
+    public int getInt(int columnIndex) {
+        if (realCursor != null) {
+            int result = realCursor.getInt(columnIndex);
+//            PrivacyDebugger.d(TAG, "getInt - columnIndex: " + columnIndex + " name: " + realCursor.getColumnName(columnIndex) + " result: " + result);
+            return result;
+        }
+        return 0;
+    }
+
+    @Override
+    public long getLong(int columnIndex) {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getLong(columnIndex);
+        return 0;
+    }
+
+    @Override
+    public int getPosition() {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+            int result = getMappedPos(realCursor.getPosition());
+            PrivacyDebugger.d(TAG, "getPosition - mapped position: " + result + " real position: " + realCursor.getPosition());
+            return result;
+        }
+	else if (realCursor != null)
+	    return realCursor.getPosition();
+        return -1;
+    }
+
+    @Override
+    public short getShort(int columnIndex) {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getShort(columnIndex);
+        return 0;
+    }
+
+    @Override
+    public String getString(int columnIndex) {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+	if(googleCursor && (columnIndex == 1) && (realCursor.getPosition() == blockedColumnAndroidID)){	
+		PrivacyDebugger.i(TAG,"google tries to get android_id with getString()");
+		String id = getFakeID();
+		if(id != null){
+			try{
+				BigInteger value = new BigInteger(id,16);
+				String fakeValue = String.valueOf(value);
+				PrivacyDebugger.i(TAG,"returned : " + fakeValue + "(String) as fake android id");
+				return fakeValue;
+			}
+			catch(Exception e){
+				e.printStackTrace();
+				PrivacyDebugger.i(TAG,"returned \"\" as android_id");
+				return "";
+			}
+		}
+		else{PrivacyDebugger.i(TAG,"returned \"\" as android_id"); return "";}
+	}
+        if (realCursor != null) return realCursor.getString(columnIndex);
+        return "";
+    }
+
+    @Override
+    public int getType(int columnIndex) {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getType(columnIndex);
+        return realCursor.FIELD_TYPE_NULL;
+    }
+
+    @Override
+    public boolean getWantsAllOnMoveCalls() {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getWantsAllOnMoveCalls();
+        return false;
+    }
+
+    @Override
+    public boolean isAfterLast() {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.isAfterLast();
+        return false;
+    }
+
+    @Override
+    public boolean isBeforeFirst() {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.isBeforeFirst();
+        return false;
+    }
+
+    @Override
+    public boolean isClosed() {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.isClosed();
+        return false;
+    }
+
+    @Override
+    public boolean isFirst() {
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+//            PrivacyDebugger.d(TAG, "isFirst");
+            if (realCursor.getPosition() == allowedIdMapping[0]) return true;
+        }
+	else if(realCursor != null)
+	    return realCursor.isFirst();
+        return false;
+    }
+
+    @Override
+    public boolean isLast() {
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+//            PrivacyDebugger.d(TAG, "isLast");
+            if (realCursor.getPosition() == allowedIdMapping[allowedIdMapping.length - 1]) return true;
+        }
+	else if (realCursor != null)
+	    return realCursor.isLast();
+        return false;
+    }
+
+    @Override
+    public boolean isNull(int columnIndex) {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.isNull(columnIndex);
+        return false;
+    }
+
+    @Override
+    public boolean move(int offset) {
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+            PrivacyDebugger.d(TAG, "move - offset: " + offset);
+            try {
+                int realPos = allowedIdMapping[getMappedPos(realCursor.getPosition()) + offset];
+                boolean result = realCursor.moveToPosition(realPos);
+//                PrivacyDebugger.d(TAG, "move - position: " + realCursor.getPosition() + " result: " + result);
+                return result;
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return false;
+            }
+        }
+	else if(realCursor != null) //here we go with our google cursor
+		realCursor.move(offset);
+        return false;
+    }
+
+    @Override
+    public boolean moveToFirst() {
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+            boolean result = realCursor.moveToPosition(allowedIdMapping[0]); 
+//            PrivacyDebugger.d(TAG, "moveToFirst - position: " + allowedIdMapping[0] + " result: " + result);
+            return result;
+        }
+	else if (realCursor != null)
+		return realCursor.moveToFirst();
+        return false;
+    }
+
+    @Override
+    public boolean moveToLast() {
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+            boolean result = realCursor.moveToPosition(allowedIdMapping[allowedIdMapping.length - 1]);
+//            PrivacyDebugger.d(TAG, "moveToLast - real position: " + realCursor.getPosition() + " result: " + result);
+            return result;
+        }
+	else if(realCursor != null)
+		return realCursor.moveToLast();
+        return false;
+    }
+
+    @Override
+    public boolean moveToNext() {
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+            if (!realCursor.moveToNext()) return false;
+            boolean result = true;
+            while (result == true && !isAllowed(realCursor)) result = realCursor.moveToNext();
+//            PrivacyDebugger.d(TAG, "moveToNext - real position: " + realCursor.getPosition() + " result: " + result);
+            return result;
+        }
+	else if(realCursor != null)
+		return realCursor.moveToNext();
+        return false;
+    }
+
+    @Override
+    public boolean moveToPosition(int position) {
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+            try {
+                boolean result = realCursor.moveToPosition(allowedIdMapping[position]);
+//                PrivacyDebugger.d(TAG, "moveToPosition - real position: " + realCursor.getPosition() + " result: " + result);
+                return result;
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return false;
+            }
+        }
+	else if(realCursor != null)
+		return realCursor.moveToPosition(position);
+        return false;
+    }
+
+    @Override
+    public boolean moveToPrevious() {
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+            if (!realCursor.moveToPrevious()) return false;
+            boolean result = true;
+            while (result == true && !isAllowed(realCursor)) result = realCursor.moveToPrevious();
+//            PrivacyDebugger.d(TAG, "moveToPrevious - real position: " + realCursor.getPosition() + " result: " + result);
+            return result;
+        }
+	else if(realCursor != null)
+		return realCursor.moveToPrevious();
+        return false;
+    }
+
+    @Override
+    public void registerContentObserver(ContentObserver observer) {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.registerContentObserver(observer);        
+    }
+
+    @Override
+    public void registerDataSetObserver(DataSetObserver observer) {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.registerDataSetObserver(observer);        
+    }
+
+    @Override
+    public boolean requery() {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.requery();
+        return false;
+    }
+
+    @Override
+    public Bundle respond(Bundle extras) {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.respond(extras);        
+        return new Bundle();
+    }
+
+    @Override
+    public void setNotificationUri(ContentResolver cr, Uri uri) {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.setNotificationUri(cr, uri);        
+    }
+
+    @Override
+    public void unregisterContentObserver(ContentObserver observer) {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.unregisterContentObserver(observer);        
+    }
+
+    @Override
+    public void unregisterDataSetObserver(DataSetObserver observer) {
+//        PrivacyDebugger.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.unregisterDataSetObserver(observer);
+    }
+
+    private int getContactId(Cursor c) {
+        int colIndex = c.getColumnIndex(ContactsContract.Contacts._ID);
+        int result = -1;
+        if (colIndex != -1) result = c.getInt(colIndex); 
+//        PrivacyDebugger.d(TAG, "getContactId - colIndex: " + colIndex + " id: " + result);
+        return result;
+    }
+    
+    private boolean isAllowed(int id) {
+        boolean result = false;
+        for (int i : allowedIds) {
+            if (id == i) {
+                result = true;
+                break;
+            }
+        }
+//        PrivacyDebugger.d(TAG, "isAllowed - id: " + id + " result: " + result);
+        return result;
+    }
+    
+    private boolean isAllowed(Cursor realCursor) {
+        return isAllowed(getContactId(realCursor));
+    }
+    
+    /**
+     * TODO: switch to HashMap etc to speed this up?
+     * @param realPos
+     * @return
+     */
+    private int getMappedPos(int realPos) {
+        for (int i = 0; i < allowedIdMapping.length; i++) {
+            if (allowedIdMapping[i] == realPos) return i;
+        }
+        return -1;
+    }
+	
+
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyLocationManager.java pang/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyLocationManager.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyLocationManager.java	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyLocationManager.java	2013-02-03 22:07:51.478494347 +0545
@@ -0,0 +1,607 @@
+package android.privacy.surrogate;
+
+import android.app.PendingIntent;
+import android.content.Context;
+import android.location.Criteria;
+import android.location.ILocationManager;
+import android.location.Location;
+import android.location.LocationListener;
+import android.location.LocationManager;
+import android.location.LocationProvider;
+import android.location.GpsStatus.NmeaListener;
+import android.os.Binder;
+import android.os.Looper;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+import android.util.Log;
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+/**
+ * Provides privacy handling for {@link android.location.LocationManager}
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public final class PrivacyLocationManager extends LocationManager {
+
+    private static final String TAG = "PrivacyLocationManager";
+    
+    private static final int CUSTOM_LOCATION_UPDATE_COUNT = 5;
+    
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+    
+    private Object lock = new Object();
+    
+    /** {@hide} */
+    public PrivacyLocationManager(ILocationManager service, Context context) {
+        super(context, service);
+        this.context = context;
+//        pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+        pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));        
+    }
+
+    @Override
+    public boolean addNmeaListener(NmeaListener listener) {
+        // only blocks if access is not allowed
+        // custom and random values not implemented due to Decimal Degrees->NMEA conversion complexity
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        
+        if (pSet != null && pSet.getLocationGpsSetting() != PrivacySettings.REAL) {
+        	if(pSet.isDefaultDenyObject())
+        		pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+        	else
+        		pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+            return false;
+        } else {
+        	if(pSet != null && pSet.isDefaultDenyObject())
+        		pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+        	else
+        		pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+        }
+        PrivacyDebugger.d(TAG, "addNmeaListener - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: [real value]");
+        return super.addNmeaListener(listener);
+    }
+
+    @Override
+    public Location getLastKnownLocation(String provider) {
+        if (provider == null) return super.getLastKnownLocation(provider);
+        
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        Location output = null;
+        
+        if (pSet != null) {
+            if (provider.equals(LocationManager.GPS_PROVIDER)) {
+                switch (pSet.getLocationGpsSetting()) {
+                    case PrivacySettings.REAL:
+                        output = super.getLastKnownLocation(provider);
+                        if(pSet.isDefaultDenyObject())
+	                        pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_GPS, 
+	                                (output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null), pSet);
+                        else
+                        	pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, 
+	                                (output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null), pSet);
+                        break;
+                    case PrivacySettings.EMPTY:
+                    	if(pSet.isDefaultDenyObject())
+                    		pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                    	else
+                    		pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                        break;
+                    case PrivacySettings.CUSTOM:
+                        output = new Location(provider);
+                        output.setLatitude(Double.parseDouble(pSet.getLocationGpsLat()));
+                        output.setLongitude(Double.parseDouble(pSet.getLocationGpsLon()));
+                        if(pSet.isDefaultDenyObject())
+	                        pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_GPS, 
+	                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        else
+                        	pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_LOCATION_GPS, 
+	                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        break;
+                    case PrivacySettings.RANDOM:
+                        output = new Location(provider);
+                        output.setLatitude(Double.parseDouble(pSet.getLocationGpsLat()));
+                        output.setLongitude(Double.parseDouble(pSet.getLocationGpsLon()));
+                        if(pSet.isDefaultDenyObject())
+	                        pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_GPS, 
+	                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        else
+                        	pSetMan.notification(packageName, uid, PrivacySettings.RANDOM, PrivacySettings.DATA_LOCATION_GPS, 
+	                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        break;
+                }
+            } else if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                switch (pSet.getLocationNetworkSetting()) {
+                    case PrivacySettings.REAL:
+                        output = super.getLastKnownLocation(provider);
+                        if(pSet.isDefaultDenyObject())
+	                        pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, 
+	                                output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+                        else
+                        	pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, 
+	                                output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+                        break;
+                    case PrivacySettings.EMPTY:
+                    	if(pSet.isDefaultDenyObject())
+                    		pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+                    	else
+                    		pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+                        break;
+                    case PrivacySettings.CUSTOM:
+                        output = new Location(provider);
+                        output.setLatitude(Double.parseDouble(pSet.getLocationNetworkLat()));
+                        output.setLongitude(Double.parseDouble(pSet.getLocationNetworkLon()));
+                        if(pSet.isDefaultDenyObject())
+	                        pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, 
+	                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        else
+                        	pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_LOCATION_NETWORK, 
+	                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        break;
+                    case PrivacySettings.RANDOM:
+                        output = new Location(provider);
+                        output.setLatitude(Double.parseDouble(pSet.getLocationNetworkLat()));
+                        output.setLongitude(Double.parseDouble(pSet.getLocationNetworkLon()));
+                        if(pSet.isDefaultDenyObject())
+	                        pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, 
+	                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        else
+                        	pSetMan.notification(packageName, uid, PrivacySettings.RANDOM, PrivacySettings.DATA_LOCATION_NETWORK, 
+	                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        break;
+                }
+            } else if (provider.equals(LocationManager.PASSIVE_PROVIDER) && 
+                    pSet.getLocationGpsSetting() == PrivacySettings.REAL && 
+                            pSet.getLocationNetworkSetting() == PrivacySettings.REAL) {
+                // only output real location if both gps and network are allowed
+                output = super.getLastKnownLocation(provider);
+                if(pSet.isDefaultDenyObject())
+	                pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_GPS, 
+	                        output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+                else
+                	pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, 
+	                        output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+            }
+        } else {
+            output = super.getLastKnownLocation(provider);
+            if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+            	//we needn't check if it is a default deny object or not!
+                pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, 
+                    output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+            } else { // including GPS and passive providers
+                pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, 
+                        output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+            }
+        }
+        
+        PrivacyDebugger.d(TAG, "getLastKnownLocation - " + context.getPackageName() + " (" + Binder.getCallingUid() + 
+                ") output: " + output);
+        return output;
+    }
+
+    @Override
+    public LocationProvider getProvider(String name) {
+        if (name == null) return super.getProvider(name);
+        
+        PrivacySettings pSet = pSetMan.getSettings(context.getPackageName());
+        LocationProvider output = null;
+        
+        if (pSet != null) {
+            if (name.equals(LocationManager.GPS_PROVIDER)) {
+                switch (pSet.getLocationGpsSetting()) {
+                    case PrivacySettings.REAL:
+                    case PrivacySettings.CUSTOM:
+                    case PrivacySettings.RANDOM:
+                        output = super.getProvider(name);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        break;
+                }
+            } else if (name.equals(LocationManager.NETWORK_PROVIDER)) {
+                switch (pSet.getLocationNetworkSetting()) {
+                    case PrivacySettings.REAL:
+                    case PrivacySettings.CUSTOM:
+                    case PrivacySettings.RANDOM:
+                        output = super.getProvider(name);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        break;
+                }
+            } else if (name.equals(LocationManager.PASSIVE_PROVIDER)) { // could get location from any of above
+                if (pSet.getLocationGpsSetting() == PrivacySettings.REAL || 
+                        pSet.getLocationNetworkSetting() == PrivacySettings.REAL) {
+                    output = super.getProvider(name);
+                }
+            }
+        } else {
+            output = super.getProvider(name);
+        }
+            
+//        PrivacyDebugger.d(TAG, "getProvider - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + 
+//                (output != null ? "[real value]" : "[null]"));
+        return output;
+    }
+
+    @Override
+    public boolean isProviderEnabled(String provider) {
+        if (provider == null) return super.isProviderEnabled(provider);
+        
+        PrivacySettings pSet = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+        boolean output = false;
+        
+        if (pSet != null) {
+            if (provider.equals(LocationManager.GPS_PROVIDER)) {
+                switch (pSet.getLocationGpsSetting()) {
+                    case PrivacySettings.REAL:
+                        output = super.isProviderEnabled(provider);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        break;
+                    case PrivacySettings.CUSTOM:
+                    case PrivacySettings.RANDOM:
+                        output = true;
+                        break;
+                }
+            } else if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                switch (pSet.getLocationNetworkSetting()) {
+                    case PrivacySettings.REAL:
+                        output = super.isProviderEnabled(provider);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        break;
+                    case PrivacySettings.CUSTOM:
+                    case PrivacySettings.RANDOM:
+                        output = true;
+                        break;
+                }
+            } else if (provider.equals(LocationManager.PASSIVE_PROVIDER)) { // could get location from any of above
+                if (pSet.getLocationGpsSetting() == PrivacySettings.REAL || 
+                        pSet.getLocationNetworkSetting() == PrivacySettings.REAL) {
+                    output = super.isProviderEnabled(provider);
+                } else {
+                    output = false;
+                }
+            }
+        } else { // if querying unknown provider
+            output = super.isProviderEnabled(provider);
+        }
+        
+//        PrivacyDebugger.d(TAG, "isProviderEnabled - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") provider: " 
+//                + provider + "output: " + output);
+        return output;
+    }
+
+    @Override
+    public void requestLocationUpdates(long minTime, float minDistance, Criteria criteria, LocationListener listener,
+            Looper looper) {
+        if (criteria == null || listener == null) {
+            super.requestLocationUpdates(minTime, minDistance, criteria, listener, looper);
+            return;
+        }
+        if (requestLocationUpdates(criteria, listener, null)) return;
+        super.requestLocationUpdates(minTime, minDistance, criteria, listener, looper);
+    }
+
+    @Override
+    public void requestLocationUpdates(long minTime, float minDistance, Criteria criteria, PendingIntent intent) {
+        if (criteria == null || intent == null) {
+            super.requestLocationUpdates(minTime, minDistance, criteria, intent);
+            return;
+        }
+        if (requestLocationUpdates(criteria, null, intent)) return;
+        super.requestLocationUpdates(minTime, minDistance, criteria, intent);
+    }
+
+    @Override
+    public void requestLocationUpdates(String provider, long minTime, float minDistance, LocationListener listener,
+            Looper looper) {
+        if (provider == null || listener == null) {
+            super.requestLocationUpdates(provider, minTime, minDistance, listener, looper);
+            return;
+        }
+        if (requestLocationUpdates(provider, listener, null)) return;
+        super.requestLocationUpdates(provider, minTime, minDistance, listener, looper);
+    }
+
+    @Override
+    public void requestLocationUpdates(String provider, long minTime, float minDistance, LocationListener listener) {
+        if (provider == null || listener == null) {
+            super.requestLocationUpdates(provider, minTime, minDistance, listener);
+            return;
+        }
+        if (requestLocationUpdates(provider, listener, null)) return;
+        super.requestLocationUpdates(provider, minTime, minDistance, listener);
+    }
+
+    @Override
+    public void requestLocationUpdates(String provider, long minTime, float minDistance, PendingIntent intent) {
+        if (provider == null || intent == null) {
+            super.requestLocationUpdates(provider, minTime, minDistance, intent);
+            return;
+        }
+        if (requestLocationUpdates(provider, null, intent)) return;
+        super.requestLocationUpdates(provider, minTime, minDistance, intent);
+    }
+
+    @Override
+    public void requestSingleUpdate(Criteria criteria, LocationListener listener, Looper looper) {
+        if (criteria == null || listener == null) {
+            super.requestSingleUpdate(criteria, listener, looper);
+            return;
+        }
+        if (requestLocationUpdates(criteria, listener, null)) return;
+        super.requestSingleUpdate(criteria, listener, looper);
+    }
+
+    @Override
+    public void requestSingleUpdate(Criteria criteria, PendingIntent intent) {
+        if (criteria == null || intent == null) {
+            super.requestSingleUpdate(criteria, intent);
+            return;
+        }
+        if (requestLocationUpdates(criteria, null, intent)) return;
+        super.requestSingleUpdate(criteria, intent);
+    }
+
+    @Override
+    public void requestSingleUpdate(String provider, LocationListener listener, Looper looper) {
+        if (provider == null || listener == null) {
+            super.requestSingleUpdate(provider, listener, looper);
+            return;
+        }
+        if (requestLocationUpdates(provider, listener, null)) return;
+        super.requestSingleUpdate(provider, listener, looper);
+    }
+
+    @Override
+    public void requestSingleUpdate(String provider, PendingIntent intent) {
+        if (provider == null || intent == null) {
+            super.requestSingleUpdate(provider, intent);
+            return;
+        }
+        if (requestLocationUpdates(provider, null, intent)) return;
+        super.requestSingleUpdate(provider, intent);
+    }
+    
+    /**
+     * Monitoring purposes only
+     */
+//    @Override
+//    public boolean sendExtraCommand(String provider, String command, Bundle extras) {
+//        PrivacyDebugger.d(TAG, "sendExtraCommand - " + context.getPackageName() + " (" + Binder.getCallingUid() + ")");
+//        return super.sendExtraCommand(provider, command, extras);
+//    }
+
+    /**
+     * Handles calls to requestLocationUpdates and requestSingleUpdate methods
+     * @return true, if action has been taken
+     *         false, if the processing needs to be passed to the default method
+     */
+    private boolean requestLocationUpdates(String provider, LocationListener listener, PendingIntent intent) {
+        synchronized (lock) { // custom listener should only return a value after this method has returned
+
+            String packageName = context.getPackageName();
+            int uid = Binder.getCallingUid();
+            PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+            boolean output = false;
+            
+            if (pSet != null) {
+                if (provider.equals(LocationManager.GPS_PROVIDER)) {
+                    switch (pSet.getLocationGpsSetting()) {
+                        case PrivacySettings.REAL:
+                        	if(pSet.isDefaultDenyObject())
+                        		pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_GPS, null, pSet);   
+                        	else
+                        		pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, null, pSet);   
+                            break;
+                        case PrivacySettings.EMPTY:
+                            if (intent != null) intent.cancel();
+                            output = true;
+                            if(pSet.isDefaultDenyObject())
+                            	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                            else
+                            	pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                            break;
+                        case PrivacySettings.CUSTOM:
+                            try {
+                                new PrivacyLocationUpdater(provider, listener, intent, 
+                                        Double.parseDouble(pSet.getLocationGpsLat()), 
+                                        Double.parseDouble(pSet.getLocationGpsLon())).start();
+                                output = true;
+                            } catch (NumberFormatException e) {
+                                PrivacyDebugger.e(TAG, "requestLocationUpdates: invalid coordinates");
+                                output = true;
+                            }
+                            if(pSet.isDefaultDenyObject())
+	                            pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_GPS, 
+	                                    "Lat: " + pSet.getLocationGpsLat() + " Lon: " + pSet.getLocationGpsLon(), pSet);
+                            else
+                            	pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_LOCATION_GPS, 
+	                                    "Lat: " + pSet.getLocationGpsLat() + " Lon: " + pSet.getLocationGpsLon(), pSet);
+                            break;
+                        case PrivacySettings.RANDOM:
+                            try {
+                                new PrivacyLocationUpdater(provider, listener, intent, 
+                                        Double.parseDouble(pSet.getLocationGpsLat()), 
+                                        Double.parseDouble(pSet.getLocationGpsLon())).start();
+                                output = true;
+                            } catch (NumberFormatException e) {
+                                PrivacyDebugger.e(TAG, "requestLocationUpdates: invalid coordinates");
+                                output = true;
+                            }
+                            if(pSet.isDefaultDenyObject())
+	                            pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_GPS, 
+	                                    "Lat: " + pSet.getLocationGpsLat() + " Lon: " + pSet.getLocationGpsLon(), pSet);
+                            else
+                            	pSetMan.notification(packageName, uid, PrivacySettings.RANDOM, PrivacySettings.DATA_LOCATION_GPS, 
+	                                    "Lat: " + pSet.getLocationGpsLat() + " Lon: " + pSet.getLocationGpsLon(), pSet);
+                            break;
+                    }
+                } else if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                    switch (pSet.getLocationNetworkSetting()) {
+                        case PrivacySettings.REAL:
+                        	if(pSet.isDefaultDenyObject())
+                        		pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet); 
+                        	else
+                        		pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet); 
+                            break;
+                        case PrivacySettings.EMPTY:
+                            if (intent != null) intent.cancel();
+                            output = true;
+                            if(pSet.isDefaultDenyObject())
+                            	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+                            else
+                            	pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+                            break;
+                        case PrivacySettings.CUSTOM:
+                            try {
+                                new PrivacyLocationUpdater(provider, listener, intent, 
+                                        Double.parseDouble(pSet.getLocationNetworkLat()), 
+                                        Double.parseDouble(pSet.getLocationNetworkLon())).start();
+                                output = true;
+                            } catch (NumberFormatException e) {
+                                PrivacyDebugger.e(TAG, "requestLocationUpdates: invalid coordinates");
+                                output = true;
+                            }
+                            if(pSet.isDefaultDenyObject())
+	                            pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, 
+	                                    "Lat: " + pSet.getLocationNetworkLat() + " Lon: " + pSet.getLocationNetworkLon(), pSet);
+                            else
+                            	pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_LOCATION_NETWORK, 
+	                                    "Lat: " + pSet.getLocationNetworkLat() + " Lon: " + pSet.getLocationNetworkLon(), pSet);
+                            break;
+                        case PrivacySettings.RANDOM:
+                            try {
+                                new PrivacyLocationUpdater(provider, listener, intent, 
+                                        Double.parseDouble(pSet.getLocationNetworkLat()), 
+                                        Double.parseDouble(pSet.getLocationNetworkLon())).start();
+                                output = true;
+                            } catch (NumberFormatException e) {
+                                PrivacyDebugger.e(TAG, "requestLocationUpdates: invalid coordinates");
+                                output = true;
+                            }
+                            if(pSet.isDefaultDenyObject())
+	                            pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, 
+	                                    "Lat: " + pSet.getLocationNetworkLat() + " Lon: " + pSet.getLocationNetworkLon(), pSet);
+                            else
+                            	pSetMan.notification(packageName, uid, PrivacySettings.RANDOM, PrivacySettings.DATA_LOCATION_NETWORK, 
+	                                    "Lat: " + pSet.getLocationNetworkLat() + " Lon: " + pSet.getLocationNetworkLon(), pSet);
+                            break;
+                    }
+                } else if (provider.equals(LocationManager.PASSIVE_PROVIDER)) { // could get location from any of above
+                    if (pSet.getLocationGpsSetting() == PrivacySettings.REAL && 
+                            pSet.getLocationNetworkSetting() == PrivacySettings.REAL) {
+                        output = false;
+                        if(pSet.isDefaultDenyObject())
+                        	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                        else
+                        	pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                    } else {
+                        output = true;
+                        if(pSet.isDefaultDenyObject())
+                        	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                        else
+                        	pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                    }
+                }
+            } else {
+                if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                	//no check for default deny object here
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+                } else { // including GPS and passive providers
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                }
+            }
+            
+//            PrivacyDebugger.d(TAG, "requestLocationUpdates - " + context.getPackageName() + " (" + Binder.getCallingUid() + 
+//                    ") output: " + (output == true ? "[custom location]" : "[real value]"));
+            return output;
+        }
+    }
+    
+    /**
+     * Helper method for categorizing the different requestLocationUpdates calls by
+     * provider accuracy and handing them off to 
+     * {@link android.privacy.surrogate.PrivacyLocationManager#requestLocationUpdates(String, LocationListener, PendingIntent)}
+     * @param criteria
+     * @param listener
+     * @param intent
+     * @return see {@link android.privacy.surrogate.PrivacyLocationManager#requestLocationUpdates(String, LocationListener, PendingIntent)}
+     */
+    private boolean requestLocationUpdates(Criteria criteria, LocationListener listener, PendingIntent intent) {
+        if (criteria == null) return false;
+            // treat providers with high accuracy as GPS providers
+        else if (criteria.getAccuracy() == Criteria.ACCURACY_FINE || 
+                criteria.getBearingAccuracy() == Criteria.ACCURACY_HIGH || 
+                criteria.getHorizontalAccuracy() == Criteria.ACCURACY_HIGH || 
+                criteria.getVerticalAccuracy() == Criteria.ACCURACY_HIGH || 
+                criteria.getSpeedAccuracy() == Criteria.ACCURACY_HIGH) {
+            return requestLocationUpdates(LocationManager.GPS_PROVIDER, listener, intent);
+        } else { // treat all others as network providers
+            return requestLocationUpdates(LocationManager.NETWORK_PROVIDER, listener, intent);
+        }
+    }
+    
+    private class PrivacyLocationUpdater extends Thread {
+        
+        private String provider;
+        
+        private LocationListener listener;
+        
+        private PendingIntent intent;
+        
+        private double latitude;
+        
+        private double longitude;
+
+        public PrivacyLocationUpdater(String provider, LocationListener listener, PendingIntent intent,
+                double latitude, double longitude) {
+            this.provider = provider;
+            this.listener = listener;
+            this.intent = intent;
+            this.latitude = latitude;
+            this.longitude = longitude;
+        }
+
+        @Override
+        public void run() {
+            if (provider != null) {
+                Location location = new Location(provider);
+                location.setLatitude(latitude);
+                location.setLongitude(longitude);
+                for (int i = 0; i < CUSTOM_LOCATION_UPDATE_COUNT; i++) {
+                    if (listener != null) {
+                        listener.onLocationChanged(location);
+                    } else if (intent != null) {
+                        // no custom or random location implemented due to complexity
+                        intent.cancel();
+                    }
+                    try {
+                        sleep((int)(Math.random() * 1000));
+                    } catch (InterruptedException e) {
+                        e.printStackTrace();
+                    }
+                }
+            }
+        }
+        
+    }
+
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyTelephonyManager.java pang/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyTelephonyManager.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyTelephonyManager.java	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyTelephonyManager.java	2013-02-04 23:06:35.593575518 +0545
@@ -0,0 +1,535 @@
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.os.Binder;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+import android.telephony.CellLocation;
+import android.telephony.NeighboringCellInfo;
+import android.telephony.PhoneStateListener;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+import android.os.Process;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Random;
+
+import android.telephony.CellInfo;
+
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+/**
+ * Provides privacy handling for {@link android.telephony.TelephonyManager}
+ * @author Svyatoslav Hresyk, modified & improved by CollegeDev (Stefan T.)
+ * {@hide}
+ */
+public final class PrivacyTelephonyManager extends TelephonyManager {
+
+    private static final String TAG = "PrivacyTelephonyManager";
+    
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+    
+    /** {@hide} */
+    public PrivacyTelephonyManager(Context context) {
+        super(context);
+        this.context = context;
+//        pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+        // don't call getSystemService to avoid getting java.lang.IllegalStateException: 
+        // System services not available to Activities before onCreate()
+        pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    }
+    
+    /**
+     * IMEI
+     */
+    @Override
+    public String getDeviceId() {
+        String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        PrivacyDebugger.d(TAG, "getDeviceId - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * Phone number
+     */
+    @Override
+    public String getLine1Number() {
+        String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getLine1Number();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        PrivacyDebugger.d(TAG, "getLine1Number - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * Will be handled like the Line1Number, since voice mailbox numbers often
+     * are similar to the phone number of the subscriber.
+     */
+    @Override
+    public String getVoiceMailNumber() {
+        String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        PrivacyDebugger.d(TAG, "getVoiceMailNumber - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * Intercept requests for mobile network cell information. This can be used for tracking network
+     * based location.
+     */
+    @Override
+    public List<NeighboringCellInfo> getNeighboringCellInfo() {
+        PrivacySettings pSet = pSetMan.getSettings(context.getPackageName());
+        List<NeighboringCellInfo> output = null;
+        String output_label = "[null]";
+        
+        if (pSet != null) {
+            if (pSet.getLocationNetworkSetting() == PrivacySettings.EMPTY) {
+                // output = null;
+            } else if (pSet.getLocationNetworkSetting() != PrivacySettings.REAL) {
+                output = new ArrayList<NeighboringCellInfo>();
+                output_label = "[empty list of cells]";
+            } else {
+                output = super.getNeighboringCellInfo();
+                String cells = "";
+                for (NeighboringCellInfo i : output) cells += "\t" + i + "\n";
+                output_label = "[real value]:\n" + cells;
+            }
+        }
+        
+        PrivacyDebugger.d(TAG, "getNeighboringCellInfo - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);
+        return output;
+    }
+    
+    @Override
+    public String getNetworkCountryIso() {
+        String output = getNetworkInfo();
+        if (output == null) output = super.getNetworkCountryIso();
+        PrivacyDebugger.d(TAG, "getNetworkCountryIso - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+
+    @Override
+    public String getNetworkOperator() {
+        String output = getNetworkInfo();
+        if (output == null) output = super.getNetworkOperator();
+        PrivacyDebugger.d(TAG, "getNetworkOperator - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+
+    @Override
+    public String getNetworkOperatorName() {
+        String output = getNetworkInfo();
+        if (output == null) output = super.getNetworkOperatorName();
+        PrivacyDebugger.d(TAG, "getNetworkOperatorName - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * Handles following Network Information requests: CountryIso, Operator Code, Operator Name
+     * @return value to return if applicable or null if real value should be returned
+     */
+    private String getNetworkInfo() {
+        String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        if (pSet != null && pSet.getNetworkInfoSetting() != PrivacySettings.REAL) {
+        	if(pSet.isDefaultDenyObject())
+        		pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, pSet);         
+        	else
+        		pSetMan.notification(packageName, 0, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, pSet);     
+            return ""; // can only be empty
+        } else {
+        	if(pSet != null && pSet.isDefaultDenyObject())
+        		pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, pSet);  
+        	else
+        		pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, pSet);  
+            return null;
+        }        
+    }
+    
+    @Override
+    public String getSimCountryIso() {
+        String output = getSimInfo();
+        if (output == null) output = super.getSimCountryIso();
+        PrivacyDebugger.d(TAG, "getSimCountryIso - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+
+    @Override
+    public String getSimOperator() {
+        String output = getSimInfo();
+        if (output == null) output = super.getSimOperator();
+        PrivacyDebugger.d(TAG, "getSimOperator - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+
+    @Override
+    public String getSimOperatorName() {
+        String output = getSimInfo();
+        if (output == null) output = super.getSimOperatorName();
+        PrivacyDebugger.d(TAG, "getSimOperatorName - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * Handles following SIM Card information requests: CountryIso, Operator Code, Operator Name
+     * @return value to return if applicable or null if real value should be returned
+     */    
+    private String getSimInfo() {
+        String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        if (pSet != null && pSet.getSimInfoSetting() != PrivacySettings.REAL) {
+        	if(pSet.isDefaultDenyObject())
+        		pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_SIM, null, pSet);   
+        	else
+        		pSetMan.notification(packageName, 0, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_SIM, null, pSet);   
+            return ""; // can only be empty
+        } else {
+        	if(pSet != null && pSet.isDefaultDenyObject())
+        		pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_SIM, null, pSet);
+        	else
+        		pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_SIM, null, pSet);
+            return null;
+        }                
+    }
+    
+    /**
+     * ICCID
+     */
+    @Override
+    public String getSimSerialNumber() {
+        String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getSimSerialNumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getSimSerialNumber(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SIM_SERIAL, output, pSet); 
+            else
+            	pSetMan.notification(packageName, 0, pSet.getSimSerialNumberSetting(), PrivacySettings.DATA_SIM_SERIAL, output, pSet); 
+        } else {
+            output = super.getSimSerialNumber();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SIM_SERIAL, output, pSet);        
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_SIM_SERIAL, output, pSet);     
+        }
+        PrivacyDebugger.d(TAG, "getSimSerialNumber - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    public String getSafeSubscriberId() {
+    	PrivacyDebugger.i(TAG, "getSafeSubscriberId()", context.getPackageName());
+    	return "1817209745362786";
+    }
+    
+    /**
+     * IMSI
+     */
+    @Override
+    public String getSubscriberId() {
+        String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getSubscriberId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);   
+            else
+            	pSetMan.notification(packageName, 0, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet); 
+        } else {
+        	output = super.getSubscriberId();
+        	if(pSet != null && pSet.isDefaultDenyObject())
+        		pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);  
+        	else
+        		pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);
+        }
+        PrivacyDebugger.d(TAG, "getSubscriberId - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+
+    /**
+     * For monitoring purposes only
+     */    
+    @Override
+    public void enableLocationUpdates() {
+        PrivacyDebugger.d(TAG, "enableLocationUpdates - " + context.getPackageName() + " (" + Binder.getCallingUid() + ")");
+        super.enableLocationUpdates();
+    }
+
+    @Override
+    public void listen(PhoneStateListener listener, int events) {
+        PrivacyDebugger.d(TAG, "listen - package:" + context.getPackageName() + " uid:" + Binder.getCallingUid() + " events: " + events);
+        if (((events & PhoneStateListener.LISTEN_CELL_LOCATION) != 0) || ((events & PhoneStateListener.LISTEN_CALL_STATE) != 0)) {
+		    String pkgForDebug = context != null ? context.getPackageName() : null;
+		    PrivacyDebugger.i(TAG,"initiate listening. Context: " + ((context != null) ? "available" : "NULL") + " listener: " + ((listener != null) ? "available" : "NULL"));
+		    if(pkgForDebug != null){
+				try{
+		            	listener.setPackageName(pkgForDebug);
+		            	listener.setContext(context);
+				} catch (NullPointerException e){
+					PrivacyDebugger.w(TAG, "catched nullPointerException - listen()", e);
+				}
+	        }
+	        super.listen(listener, events);
+	        PrivacyDebugger.d(TAG, "listen for cell location or call state - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: custom listener");
+        } else {
+            super.listen(listener, events);
+        }
+    }
+    //NEW PRIVACY------------------------------------------------------------------------------------------------------------------------------------------
+ 
+
+    @Override
+    public CellLocation getCellLocation() {
+    	String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        CellLocation output = null;
+        if (pSet != null && ((pSet.getLocationNetworkSetting() != PrivacySettings.REAL) || (pSet.getLocationGpsSetting() != PrivacySettings.REAL))) {
+        	if(pSet.isDefaultDenyObject())
+        		pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+        	else
+        		pSetMan.notification(packageName, 0, pSet.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+        } else {
+        	if(pSet != null && pSet.isDefaultDenyObject())
+        		pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+        	else
+        		pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+        	output = super.getCellLocation();
+        }
+        PrivacyDebugger.d(TAG, "getCellLocation - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + ((output != null) ? output : "null"));
+        return output;
+    }
+    
+   /**
+     * Returns the software version number for the device, for example,
+     * the IMEI/SV for GSM phones. Can control with deviceIdSetting
+     *
+     */
+    @Override
+    public String getDeviceSoftwareVersion() {
+	    String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+	    String output = "";
+	    if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+        	output = pSet.getDeviceId(); // can be empty, custom or random
+        	if(pSet.isDefaultDenyObject())
+        		pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        	else
+        		pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+       	} else {
+        	output = super.getDeviceSoftwareVersion();
+        	if(pSet != null && pSet.isDefaultDenyObject())
+        		pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        	else
+        		pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+	    PrivacyDebugger.d(TAG, "getDeviceSoftwareVersion - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + ((output != null) ? output : "null"));
+        return output;
+    }
+
+    /**
+     * 
+     * @hide
+     */
+    @Override
+    public String getCompleteVoiceMailNumber() {
+        String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+	    String output = "";
+	    if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+        	output = super.getCompleteVoiceMailNumber();
+        	if(pSet != null && pSet.isDefaultDenyObject())
+        		pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        	else
+        		pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+       	}
+	    PrivacyDebugger.d(TAG, "getCompleteVoiceMailNumber - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + ((output != null) ? output : "null"));
+        return output;
+    }
+   
+
+    private static final int PHONE_TYPES[] = {PHONE_TYPE_NONE, PHONE_TYPE_GSM, PHONE_TYPE_CDMA, PHONE_TYPE_SIP};
+    private static final int NETWORK_TYPES[] = {NETWORK_TYPE_UNKNOWN, NETWORK_TYPE_GPRS, NETWORK_TYPE_EDGE,
+												NETWORK_TYPE_UMTS, NETWORK_TYPE_CDMA, NETWORK_TYPE_EVDO_0,
+												NETWORK_TYPE_EVDO_A, NETWORK_TYPE_1xRTT, NETWORK_TYPE_HSDPA,
+												NETWORK_TYPE_HSUPA, NETWORK_TYPE_HSPA, NETWORK_TYPE_IDEN,
+												NETWORK_TYPE_EVDO_B, NETWORK_TYPE_LTE, NETWORK_TYPE_EHRPD,
+												NETWORK_TYPE_HSPAP};
+
+    /**
+     * @deprecated
+     */
+    @Override
+    public int getPhoneType() {
+		String output = getNetworkInfo();
+		int type = PHONE_TYPES[0];
+		if(output == null) type = super.getPhoneType();
+	        return type;
+    }
+
+    /**
+     * @deprecated
+     */
+    @Override
+    public int getNetworkType() {
+            String output = getNetworkInfo();
+            int type = NETWORK_TYPES[0];
+            if(output == null) type = super.getNetworkType();
+            return type;
+    }
+    
+    /**
+     * Will be handled like getLine1Number
+     */
+    @Override
+    public String getLine1AlphaTag(){
+    	return getLine1Number();
+    }
+    
+    /**
+     * 15 character long numbers -> handle same as imsi
+     */
+    public String getMsisdn() {
+    	PrivacyDebugger.d(TAG, "getMsisdn - " + context.getPackageName() + " (" + Binder.getCallingUid() + ")");
+    	return getSubscriberId();
+    }
+    
+    /**
+     * It doesn't matter if we give some shit to it, it will work
+     */
+    public String getVoiceMailAlphaTag() {
+    	PrivacyDebugger.d(TAG, "getVoiceMailAlphaTag - " + context.getPackageName() + " (" + Binder.getCallingUid() + ")");
+    	return getVoiceMailNumber();
+    }
+    
+    /**
+     * @hide
+     * handles like subscriber id
+     */
+    public String getIsimImpi() {
+    	PrivacyDebugger.d(TAG, "getIsimImpi - " + context.getPackageName() + " (" + Binder.getCallingUid() + ")");
+    	return getSubscriberId();
+    }
+    
+    /**
+     * @hide
+     * lets play with this function, handled like NetworkOperatorName
+     */
+    public String getIsimDomain() {
+    	PrivacyDebugger.d(TAG, "getIsimDomain - " + context.getPackageName() + " (" + Binder.getCallingUid() + ")");
+    	return getNetworkOperatorName();
+    }
+    
+    /**
+     * @hide
+     */
+    public String[] getIsimImpu() {
+    	String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output[] = new String[1];
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output[0] = pSet.getSubscriberId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output[0], pSet);    
+            else
+            	pSetMan.notification(packageName, 0, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output[0], pSet);    
+        } else {
+            output = super.getIsimImpu();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output[0], pSet); 
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output[0], pSet); 
+        }
+        PrivacyDebugger.d(TAG, "getIsimImpu - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + ((output != null) ? output : "null"));
+        return output;
+    }
+    /**
+     * @hide
+     * @return
+     */
+    public List<CellInfo> getAllCellInfo() {
+    	PrivacySettings pSet = pSetMan.getSettings(context.getPackageName());
+    	String packageName = context.getPackageName();
+        List<CellInfo> output = null;
+        if (pSet != null && ((pSet.getLocationNetworkSetting() != PrivacySettings.REAL) || (pSet.getNetworkInfoSetting() != PrivacySettings.REAL))) {
+        	if(pSet.isDefaultDenyObject())
+        		pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet); 
+        	else
+        		pSetMan.notification(packageName, 0, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet); 
+        	output = new ArrayList<CellInfo>(); 
+        } else {
+        	if(pSet != null && pSet.isDefaultDenyObject())
+        		pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet); 
+        	else
+        		pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet); 
+        	output = super.getAllCellInfo();
+        }
+        PrivacyDebugger.d(TAG, "getAllCellInfo - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + ((output != null) ? output : "null"));
+        return output;
+    }
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyWifiManager.java pang/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyWifiManager.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyWifiManager.java	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyWifiManager.java	2013-02-04 23:40:42.711839755 +0545
@@ -0,0 +1,318 @@
+package android.privacy.surrogate;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import android.content.Context;
+import android.net.DhcpInfo;
+import android.net.wifi.IWifiManager;
+import android.net.wifi.ScanResult;
+import android.net.wifi.WifiConfiguration;
+import android.net.wifi.WifiInfo;
+import android.net.wifi.WifiManager;
+import android.os.Binder;
+import android.os.Handler;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+import android.util.Log;
+
+/**
+ * Copyright (C) 2012-2013 Stefan Thiele (CollegeDev)
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+/**
+ * Provides privacy handling for WifiManager
+ * @author CollegeDev (Stefan T.)
+ * {@hide}
+ */
+public class PrivacyWifiManager extends WifiManager{
+
+	private Context context;
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private static final String TAG = "PrivacyWifiManager";
+	
+
+	public PrivacyWifiManager(IWifiManager service, Context context){
+		super(context,service);
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+	}
+	
+	@Override
+	public List<WifiConfiguration> getConfiguredNetworks() {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		List<WifiConfiguration> output = new ArrayList<WifiConfiguration>(); //create empty list!
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL) {
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_WIFI_INFO, null, null);   
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null); 
+		} else {
+			output = super.getConfiguredNetworks();
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null); 
+		}
+		PrivacyDebugger.d(TAG, "getConfiguredNetworks - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + ((output != null) ? output : "null"));
+		return output;
+	}
+	
+	@Override
+	public WifiInfo getConnectionInfo() {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		WifiInfo output = new WifiInfo(true);
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL) { 
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null); 
+		} else {
+			output = super.getConnectionInfo();
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_WIFI_INFO, null, null);
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null);
+		}
+		PrivacyDebugger.d(TAG, "getConnectionInfo - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + ((output != null) ? output : "null"));
+		return output;
+	}
+	
+	@Override
+	public List<ScanResult> getScanResults() {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		List<ScanResult> output = new ArrayList<ScanResult>(); //create empty list!
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL) {
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			
+		} else {
+			output = super.getScanResults();
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null); 
+		}
+		PrivacyDebugger.d(TAG, "getScanResults - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + ((output != null) ? output : "null"));
+		return output;
+	}
+	
+	@Override
+	public int getFrequencyBand() {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		int output = -1;
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL) {
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_WIFI_INFO, null, null);
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);
+		} else {
+			output = super.getFrequencyBand();
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null); 
+		}
+		PrivacyDebugger.d(TAG, "getFrequencyBand - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+		return output;
+	}
+	
+	@Override
+	public DhcpInfo getDhcpInfo(){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		DhcpInfo output = new DhcpInfo();
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL) {
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_WIFI_INFO, null, null);
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);
+			
+		} else {
+			output = super.getDhcpInfo();
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null); 
+		}
+		PrivacyDebugger.d(TAG, "getDhcpInfo - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + ((output != null) ? output : "null"));
+		return output;
+	}
+	
+	/**
+	 * @hide
+	 * @return
+	 */
+	@Override
+	public WifiConfiguration getWifiApConfiguration(){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		WifiConfiguration output = new WifiConfiguration();
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL) {
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_WIFI_INFO, null, null);
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);
+		} else {
+			output = super.getWifiApConfiguration();
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null);
+		}
+		PrivacyDebugger.d(TAG, "getWifiApConfiguration - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + ((output != null) ? output : "null"));
+		return output;
+	}
+	
+
+	@Override
+	public String getConfigFile() {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL) {
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_WIFI_INFO, null, null);
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);
+			
+		} else {
+			output = super.getConfigFile();
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null); 
+		}
+		PrivacyDebugger.d(TAG, "getConfigFile - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + ((output != null) ? output : "null"));
+		return output;
+	}
+
+	
+	@Override
+	public boolean startScan(){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		boolean output = false;
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL) {
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+		} else {
+			output = super.startScan();
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_WIFI_INFO, null, null);
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null);
+		}
+		PrivacyDebugger.d(TAG, "startScan - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " +  output);
+		return output;
+	}
+	
+	
+	@Override
+	public boolean startScanActive(){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		boolean output = false;
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL) {
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			
+		} else {
+			output = super.startScanActive();
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null); 
+		}
+		PrivacyDebugger.d(TAG, "startScanActive - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " +  output);
+		return output;
+	}
+	
+	@Override
+	public boolean setWifiEnabled(boolean enabled){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		boolean output = false;
+		if(pSetMan != null && settings != null && settings.getSwitchWifiStateSetting() != PrivacySettings.REAL) {
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_SWITCH_WIFI_STATE, null, null);  
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_SWITCH_WIFI_STATE, null, null);  
+		} else {
+			output = super.setWifiEnabled(enabled);
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_SWITCH_WIFI_STATE, null, null); 
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_SWITCH_WIFI_STATE, null, null); 
+		}
+		PrivacyDebugger.d(TAG, "setWifiEnabled - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " +  output);
+		return output;
+	}
+	
+	@Override
+	public int getWifiState() {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL) {
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			PrivacyDebugger.d(TAG, "getWifiState - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: WIFI_STATE_ENABLED");
+			return WIFI_STATE_ENABLED;
+		} else if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL) {
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			PrivacyDebugger.d(TAG, "getWifiState - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: WIFI_STATE_UNKNOWN");
+			return WIFI_STATE_UNKNOWN;
+		} else {
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null);
+			PrivacyDebugger.d(TAG, "getWifiState - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: REAL_VALUE");
+			return super.getWifiState();
+		}
+	}
+	
+	@Override
+	public boolean isWifiEnabled() {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL) {
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			PrivacyDebugger.d(TAG, "isWifiEnabled - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: true");
+			return true;
+		} else if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL) {
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			PrivacyDebugger.d(TAG, "isWifiEnabled - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: false");
+			return false;
+		} else {
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.ERROR, PrivacySettings.DATA_WIFI_INFO, null, null);
+			else
+				pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null);
+			PrivacyDebugger.d(TAG, "isWifiEnabled - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: REAL_VALUE");
+			return super.isWifiEnabled();
+		}
+	}
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/utilities/PrivacyConstants.java pang/frameworks/base/privacy/java/android/privacy/utilities/PrivacyConstants.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/utilities/PrivacyConstants.java	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/base/privacy/java/android/privacy/utilities/PrivacyConstants.java	2013-02-07 02:44:04.335619720 +0545
@@ -0,0 +1,409 @@
+package android.privacy.utilities;
+
+import java.util.Random;
+import android.telephony.ServiceState;
+
+/**
+ * Copyright (C) 2012-2013 Stefan Thiele (CollegeDev)
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+/**
+ * Provides Central API for all security related constants
+ * @author CollegeDev (Stefan Thiele)
+ *
+ */
+public final class PrivacyConstants {
+	
+	private static final String TAG = "PhoneHelper";
+	
+	private static final Random gen = new Random();
+	
+	
+	/**
+	 * Provides Central implementation of PrivacyPermissions. All this permissions normally signature protected!
+	 * @author CollegeDev (Stefan Thiele)
+	 * @TODO: use all this constants in framework and delete other declared variables
+	 *
+	 */
+	public static final class PrivacyPermissions {
+		
+		/**
+		 * Allows applications to write privacy Settings to Database.
+		 */
+	    public static final String WRITE_PRIVACY_SETTINGS = "android.privacy.WRITE_PRIVACY_SETTINGS";
+
+	    /**
+	     * Allows an application to read privacy Settings from Database.
+	     */
+	    public static final String READ_PRIVACY_SETTINGS = "android.privacy.READ_PRIVACY_SETTINGS";
+	    
+	    /**
+	     * Allows an application to kill Tasks
+	     */
+	    public static final String KILL_TASKS_AGGRESSIVE = "android.privacy.KILL_TASKS_AGGRESSIVE";
+	    
+	    /**
+	     * Allows an application to receive the kill task command. This is used by core applications. Do not declare 
+	     * it in your manager application.
+	     */
+	    public static final String RECEIVE_TASK_KILL_COMMAND = "android.privacy.RECEIVE_TASK_KILL_COMMAND";
+	    
+	    /**
+	     * Allows an application to receive privacy notification. 
+	     */
+	    public static final String GET_PRIVACY_NOTIFICATION = "android.privacy.GET_PRIVACY_NOTIFICATION";
+	    
+	    /**
+	     * Allows an application to receive the fail safe mode triggered
+	     */
+	    public static final String RECEIVE_FAIL_SAFE_TRIGGERED = "android.privacy.RECEIVE_FAIL_SAFE_TRIGGERED";
+	    
+	    /**
+	     * allows an application to set the fail save mode
+	     */
+	    public static final String SET_FAIL_SAFE_MODE = "android.privacy.SET_FAIL_SAFE_MODE";
+	    
+	    /**
+	     * Allows an application to read the fail save mode e.g. if system is in failSafeMode or not.
+	     */
+	    public static final String GET_FAIL_SAFE_STATE = "android.privacy.GET_FAIL_SAFE_STATE";
+	    
+	    /**
+	     * Allows an application to enable or disable other applications.
+	     */
+	    public static final String DISABLE_ENABLE_APPLICATIONS = "android.privacy.DISABLE_ENABLE_APPLICATIONS";
+	    
+	    /**
+	     * Allows an application to receive the disable/enable applications command. This is used by core applications. Do not declare 
+	     * it in your manager application.
+	     */
+	    public static final String RECEIVE_DISABLE_ENABLE_APPLICATIONS = "android.privacy.RECEIVE_DISABLE_ENABLE_APPLICATIONS";
+	}
+	
+	/**
+	 * Provides Central Intent data for privacy intents / broadcasts
+	 * @author CollegeDev (Stefan Thiele)
+	 * @TODO: use all this constants in framework and delete other declared variables
+	 *
+	 */
+	public static final class PrivacyIntent {
+		
+		/**
+		 * Action indicates the Privacy Notification
+		 */
+	    public static final String ACTION_PRIVACY_NOTIFICATION = "com.privacy.pdroid.PRIVACY_NOTIFICATION";
+	    
+	    /**
+	     * Action indicates the Kill tasks command. core feature.
+	     */
+	    public static final String ACTION_KILL_TASKS ="com.privacy.pdroid.KILL_TASKS";
+	    
+	    /**
+	     * Action indicates that fail safe mode triggered.
+	     */
+	    public static final String ACTION_FAIL_SAFE_MODE_TRIGGERED = "com.privacy.pdroid.FAIL_SAFE_MODE_TRIGGERED";
+	    
+	    /**
+	     * Action indicates that the fail safe backup failed
+	     */
+	    public static final String ACTION_FAIL_SAFE_BACKUP_FAILED = "com.privacy.pdroid.FAIL_SAFE_BACKUP_FAILED";
+	    
+	    /**
+	     * action indicates that the backup after fail safe mode was successful
+	     */
+	    public static final String ACTION_FAIL_SAFE_BACKUP_COMPLETE = "com.privacy.pdroid.FAIL_SAFE_BACKUP_COMPLETE";
+	    
+	    /**
+	     * Action to get 
+	     */
+	    public static final String ACTION_DISABLE_ENABLE_APPLICATION = "com.privacy.pdroid.DISABLE_ENABLE_APPLICATION";
+	}
+	
+	/**
+	 * Provides constants for several intent data (callerRegister)
+	 * @author CollegeDev
+	 *
+	 */
+	public static final class CallerRegistry {
+		
+		/**
+		 * key for intent which contains the unique data access id!
+		 */
+		public static final String EXTRA_UNIQUE_DATA_ACCESS_ID = "uniqueId";
+	}
+	
+	/**
+	 * provides central constants for AppDisabler
+	 * @author root
+	 *
+	 */
+	public static final class AppDisabler {
+		
+		/**
+		 * Extra key for getting the uid from intent
+		 */
+		public static final String EXTRA_UID = "uid-extra";
+		
+		/**
+		 * Extra key for getting the package names to kill from intent
+		 */
+		public static final String EXTRA_PACKAGE = "package";
+		
+		/**
+		 * Extra key for getting the state if app should be disabled or enabled
+		 * If the variable from intent is true, disable application otherwise enable it
+		 */
+		public static final String EXTRA_DISABLE_OR_ENABLE = "disorenable";
+		
+	}
+	
+	/**
+	 * All phone related constants and parameters
+	 * TODO: move cdma,gsm,lte to this class
+	 * @author CollegeDev (Stefan Thiele)
+	 *
+	 */
+	public static final class Phone {
+		
+	}
+	/**
+	 * Provides constants for CDMA devices
+	 * @author CollegeDev (Stefan Thiele)
+	 *
+	 */
+	public static final class CDMA {
+		/**
+		 * random generator for cdma cell locations / info
+		 * @return random latitude
+		 */
+		public static int getCdmaRandomLat() {
+			int output = gen.nextInt(1296000);
+	    	if(gen.nextBoolean())
+	    		output *= -1;
+	    	return output;
+	    }
+	    
+		/**
+		 * random generator for cdma cell locations / info
+		 * @return random longitude
+		 */
+		public static int getCdmaRandomLon() {
+	    	int output = gen.nextInt(2592000);
+	    	if(gen.nextBoolean())
+	    		output *= -1;
+	    	return output;
+	    }
+		/**
+		 * random generator for cdma base station ids
+		 * @return random base station id
+		 */
+		public static int getCdmaBaseStationId() {
+			return gen.nextInt(65535);
+		}
+		
+		/**
+		 * random generator for cdma system ids
+		 * @return random cdma system id
+		 */
+		public static int getCdmaSystemId() {
+			return gen.nextInt(32767);
+		}
+		
+		/**
+		 * random generator for cdma network ids
+		 * @return random cdma network id
+		 */
+		public static int getCdmaNetworkId() {
+			return gen.nextInt(65535);
+		}
+	}
+	
+	/**
+	 * Provides constants for GSM devices
+	 * @author CollegeDev (Stefan Thiele)
+	 *
+	 */
+	public static final class GSM {
+		
+		/**
+		 * random generator for mobile country code
+		 * @return random mobile country code
+		 */
+		public static int getMobileCountryCode() {
+			return gen.nextInt(999);
+		}
+		
+		/**
+		 * random generator for mobile network code
+		 * @return random mobile network code
+		 */
+		public static int getMobileNetworkCode() {
+			return gen.nextInt(999);
+		}
+		
+		/**
+		 * random generator for location area code
+		 * @return random location area code
+		 */
+		public static int getLocationAreaCode() {
+			return gen.nextInt(65535);
+		}
+		
+		/**
+		 * random generator for cell identity
+		 * @return random cell identity
+		 */
+		public static int getCellIdentity() {
+			return gen.nextInt(268435455);
+		}
+		
+		/**
+		 * random generator for scrambling code
+		 * @return random scrambling code
+		 * @deprecated
+		 */
+		public static int getPrimaryScramblingCode() {
+			return gen.nextInt(511);
+		}
+	}
+	
+	/**
+	 * Provides constants for LTE devices
+	 * @author CollegeDev (Stefan Thiele)
+	 *
+	 */
+	public static final class LTE {
+
+		/**
+		 * random generator for mobile country code
+		 * @return random mobile country code
+		 */
+		public static int getMobileCountryCode() {
+			return gen.nextInt(999);
+		}
+		
+		/**
+		 * random generator for mobile network code
+		 * @return random mobile network code
+		 */
+		public static int getMobileNetworkCode() {
+			return gen.nextInt(999);
+		}
+		
+		/**
+		 * random generator for cell identity
+		 * @return random cell identity
+		 */
+		public static int getCellIdentity() {
+			return gen.nextInt(268435455);
+		}
+		
+		/**
+		 * random generator for physical cell id
+		 * @return random physical cell id
+		 */
+		public static int getPhysicalCellId() {
+			return gen.nextInt(503);
+		}
+		
+		/**
+		 * random generator for tracking area code
+		 * @return random tracking area code
+		 */
+		public static int getTrackingAreaCode() {
+			return gen.nextInt(32768);
+		}
+		
+	}
+	
+	/**
+	 * Provides constants for ServiceState(s)
+	 * TODO: move this class to network!
+	 * @author CollegeDev (Stefan Thiele)
+	 *
+	 */
+	public static final class PrivacyServiceState {
+		
+		/**
+		 * Creates privacy service-state based on an existing one
+		 * @param state existing servicestate
+		 * @return privacy service state
+		 */
+		public static ServiceState getPrivacyServiceState(ServiceState state) {
+			ServiceState output = new ServiceState(state);
+			output.setOperatorAlphaLong("");
+			output.setOperatorName("", "", "");
+			return output;
+		}
+	}
+	
+	/**
+	 * Provides alll network related constants (mobile network and wifi network)
+	 * @author root
+	 *
+	 */
+	public static final class Network {
+		
+		/**
+		 * Provides constants for wifi networks
+		 * @author CollegeDev (Stefan Thiele)
+		 *
+		 */
+		public static final class WiFi {
+			
+			private static final String[] ID_PATTERN = { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"};
+			
+			private static final int MAC_LENGTH = 5;
+			
+			/**
+			 * Creates a random generated mac-adress 
+			 * @return MAC address in {@code XX:XX:XX:XX:XX:XX} form
+			 */
+			public static String getMacAddress() {
+				StringBuilder localBuilder = new StringBuilder();
+				for(int i = 0; i < MAC_LENGTH; i++) {
+					if(i != MAC_LENGTH - 1)
+						localBuilder.append(ID_PATTERN[gen.nextInt(ID_PATTERN.length-1)].toUpperCase()).append(":");
+					else
+						localBuilder.append(ID_PATTERN[gen.nextInt(ID_PATTERN.length-1)].toUpperCase());
+				}
+				return localBuilder.toString();	
+			}
+		}
+		
+		/**
+		 * Provides constants for mobile networks
+		 * @author CollegeDev (Stefan Thiele)
+		 *
+		 */
+		public static final class Mobile {
+			
+		}
+		
+		
+	}
+	
+	public static final class TaskKiller {
+		
+		/**
+		 * Extra key for getting the uid from intent
+		 */
+		public static final String EXTRA_UID = "uid-extra";
+		
+		/**
+		 * Extra key for getting the package names to kill from intent
+		 */
+		public static final String EXTRA_PACKAGES = "packages";
+	}
+	
+	
+
+	
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/utilities/PrivacyDebugger.java pang/frameworks/base/privacy/java/android/privacy/utilities/PrivacyDebugger.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/utilities/PrivacyDebugger.java	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/base/privacy/java/android/privacy/utilities/PrivacyDebugger.java	2013-01-22 01:31:23.979230218 +0545
@@ -0,0 +1,240 @@
+package android.privacy.utilities;
+
+import android.content.Context;
+import android.os.Binder;
+import android.util.Log;
+/**
+ * Copyright (C) 2012-2013 Stefan Thiele (CollegeDev)
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+/**
+ * Provides Central Privacy Debugging. Use every method with ALL parameters, do not pass null or something else
+ * @author CollegeDev (Stefan T.)
+ *
+ */
+public final class PrivacyDebugger {
+	
+	private static final String TAG = "PrivacyDebugger";
+	
+	private static final String TOGGLE_DEBUGGER_STATE = "android.privacy.TOGGLE_DEBUGGER_STATE";
+	
+	private static final int DEBUGGER_ENABLED = 1;
+	private static final int DEBUGGER_DISABLED = 2;
+	private static final int DEBUGGER_UNKNOWN = -1;
+	
+	private static final String IDENTIFIER = " | PDroid2.0_debug";
+	
+	private static int DEBUGGER_STATE = DEBUGGER_UNKNOWN;
+	
+	private static boolean enabled = true;
+	
+	/**
+	 * used for method overloading. Quick and dirty
+	 * TODO: better way if there is more spare time!
+	 */
+	private final static NoException helpParam = new NoException();
+	
+	public PrivacyDebugger () {
+		Log.i(TAG,"log enabled - constructor");
+		new Thread(new Runnable() {
+	        public void run() {
+	            try {
+					Thread.sleep(10000);
+				} catch (InterruptedException e) {
+					//nothing here
+				} finally {
+					if(DEBUGGER_STATE == DEBUGGER_UNKNOWN) {
+						enabled = false;
+						Log.i(TAG,"disabled log, because nothing changed");
+					} else {
+						Log.w(TAG,"let log enabled, because user wants it?");
+					}
+				}
+	        }
+	    }).start();
+	}
+	
+	/**
+	 * Used to enabled, disable the debugger. Requires permission: android.privacy.TOGGLE_DEBUGGER_STATE
+	 * @param state true - enabled , false - disabled
+	 * @param context
+	 */
+	public static void setDebuggerState(boolean state, Context context) { 
+		context.enforceCallingPermission(TOGGLE_DEBUGGER_STATE, "Requires TOGGLE_DEBUGGER_STATE");
+		if(state)
+			DEBUGGER_STATE = DEBUGGER_ENABLED;
+		else
+			DEBUGGER_STATE = DEBUGGER_DISABLED;
+		enabled = state;
+	}
+	
+	/**
+	 * Tries to get last calling packageName
+	 * @return packageName or null
+	 */
+	private static String getCallingPackage() {
+		String[] tmp = ResolveHelper.getCallingPackageName(Binder.getCallingUid());
+		if(tmp != null && tmp.length > 0)
+			return tmp[0];
+		else
+			return null;
+	}
+	
+	
+	public static void i(String TAG, String msg) {
+		i(TAG, msg, helpParam);
+	}
+	
+	public static void w(String TAG, String msg) {
+		w(TAG, msg, helpParam);
+	}
+	
+	public static void e(String TAG, String msg) {
+		e(TAG, msg, helpParam);
+	}
+	
+	public static void d(String TAG, String msg) {
+		d(TAG, msg, helpParam);
+	}
+	
+	public static void i(String TAG, String msg, Throwable exception) {
+		if (enabled && TAG != null && msg != null && exception != null) {
+			String tmpPackage = getCallingPackage();
+			if(tmpPackage != null) {
+				if(!exception.equals(helpParam))
+					Log.i(TAG,msg + " - called from package: " + tmpPackage + ". Exception: " + Log.getStackTraceString(exception) + IDENTIFIER);
+				else
+					Log.i(TAG,msg + " - called from package: " + tmpPackage + IDENTIFIER);
+			} else {
+				if(!exception.equals(helpParam))
+					Log.i(TAG,msg + " - called from package: UNKNOWN" + ". Exception: " + Log.getStackTraceString(exception) + IDENTIFIER);
+				else
+					Log.i(TAG,msg + " - called from package: UNKNOWN" + IDENTIFIER);
+			}
+		}
+	}
+	
+	public static void w(String TAG, String msg, Throwable exception) {
+		if (enabled && TAG != null && msg != null && exception != null) {
+			String tmpPackage = getCallingPackage();
+			if(tmpPackage != null) {
+				if(!exception.equals(helpParam))
+					Log.w(TAG,msg + " - called from package: " + tmpPackage + ". Exception: " + Log.getStackTraceString(exception) + IDENTIFIER);
+				else
+					Log.w(TAG,msg + " - called from package: " + tmpPackage + IDENTIFIER);
+			} else {
+				if(!exception.equals(helpParam))
+					Log.w(TAG,msg + " - called from package: UNKNOWN" + ". Exception: " + Log.getStackTraceString(exception) + IDENTIFIER);
+				else
+					Log.w(TAG,msg + " - called from package: UNKNOWN" + IDENTIFIER);
+			}
+		}
+	}
+	
+	public static void e(String TAG, String msg, Throwable exception) {
+		if (enabled && TAG != null && msg != null && exception != null) {
+			String tmpPackage = getCallingPackage();
+			if(tmpPackage != null) {
+				if(!exception.equals(helpParam))
+					Log.e(TAG,msg + " - called from package: " + tmpPackage + ". Exception: " + Log.getStackTraceString(exception) + IDENTIFIER);
+				else
+					Log.e(TAG,msg + " - called from package: " + tmpPackage + IDENTIFIER);
+			} else {
+				if(!exception.equals(helpParam))
+					Log.e(TAG,msg + " - called from package: UNKNOWN" + ". Exception: " + Log.getStackTraceString(exception) + IDENTIFIER);
+				else
+					Log.e(TAG,msg + " - called from package: UNKNOWN" + IDENTIFIER);
+			}
+		}
+	}
+	
+	public static void d(String TAG, String msg, Throwable exception) {
+		if (enabled && TAG != null && msg != null && exception != null) {
+			String tmpPackage = getCallingPackage();
+			if(tmpPackage != null) {
+				if(!exception.equals(helpParam))
+					Log.d(TAG,msg + " - called from package: " + tmpPackage + ". Exception: " + Log.getStackTraceString(exception) + IDENTIFIER);
+				else
+					Log.d(TAG,msg + " - called from package: " + tmpPackage + IDENTIFIER);
+			} else {
+				if(!exception.equals(helpParam))
+					Log.d(TAG,msg + " - called from package: UNKNOWN" + ". Exception: " + Log.getStackTraceString(exception) + IDENTIFIER);
+				else
+					Log.d(TAG,msg + " - called from package: UNKNOWN" + IDENTIFIER);
+			}
+		}
+	}
+	
+	public static void i(String TAG, String msg, String packageName) {
+		i(TAG, msg, packageName, helpParam);
+	}
+	
+	public static void w(String TAG, String msg, String packageName) {
+		w(TAG, msg, packageName, helpParam);
+	}
+	
+	public static void e(String TAG, String msg, String packageName) {
+		e(TAG, msg, packageName, helpParam);
+	}
+	
+	public static void d(String TAG, String msg, String packageName) {
+		d(TAG, msg, packageName, helpParam);
+	}
+	
+	public static void i(String TAG, String msg, String packageName, Throwable exception) {
+		if(enabled && TAG != null && msg != null && packageName != null && !exception.equals(helpParam)) 
+			Log.i(TAG,msg + " - from package: " + packageName + ". Exception: " + Log.getStackTraceString(exception) + IDENTIFIER);	
+		else if(enabled && TAG != null && msg != null && packageName != null && exception.equals(helpParam))
+			Log.i(TAG,msg + " - from package: " + packageName + IDENTIFIER);
+		else if(enabled && TAG != null && msg != null) {
+			//try to get calling package
+			i(TAG,msg);
+		}
+	}
+	
+	public static void w(String TAG, String msg, String packageName, Throwable exception) {
+		if(enabled && TAG != null && msg != null && packageName != null && !exception.equals(helpParam)) 
+			Log.w(TAG,msg + " - from package: " + packageName + ". Exception: " + Log.getStackTraceString(exception) + IDENTIFIER);
+		else if(enabled && TAG != null && msg != null && packageName != null && exception.equals(helpParam))
+			Log.w(TAG,msg + " - from package: " + packageName + IDENTIFIER);
+		else if(enabled && TAG != null && msg != null) {
+			//try to get calling package
+			w(TAG,msg);
+		}
+	}
+	
+	public static void e(String TAG, String msg, String packageName, Throwable exception) {
+		if(enabled && TAG != null && msg != null && packageName != null && !exception.equals(helpParam)) 
+			Log.e(TAG,msg + " - from package: " + packageName + ". Exception: " + Log.getStackTraceString(exception) + IDENTIFIER);
+		else if(enabled && TAG != null && msg != null && packageName != null && exception.equals(helpParam))
+			Log.e(TAG,msg + " - from package: " + packageName + IDENTIFIER);
+		else if(enabled && TAG != null && msg != null) {
+			//try to get calling package
+			e(TAG,msg);
+		}
+	}
+	
+	public static void d(String TAG, String msg, String packageName, Throwable exception) {
+		if(enabled && TAG != null && msg != null && packageName != null && !exception.equals(helpParam)) 
+			Log.d(TAG,msg + " - from package: " + packageName + ". Exception: " + Log.getStackTraceString(exception) + IDENTIFIER);
+		else if(enabled && TAG != null && msg != null && packageName != null && exception.equals(helpParam))
+			Log.d(TAG,msg + " - from package: " + packageName + IDENTIFIER);
+		else if(enabled && TAG != null && msg != null) {
+			//try to get calling package
+			d(TAG,msg);
+		}
+	}
+	
+	//for method overheading purpose only
+	private static final class NoException extends Throwable {
+		
+	}
+	
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/utilities/ResolveHelper.java pang/frameworks/base/privacy/java/android/privacy/utilities/ResolveHelper.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/privacy/java/android/privacy/utilities/ResolveHelper.java	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/base/privacy/java/android/privacy/utilities/ResolveHelper.java	2013-01-22 01:31:23.983230168 +0545
@@ -0,0 +1,70 @@
+package android.privacy.utilities;
+
+import android.content.pm.IPackageManager;
+import android.os.ServiceManager;
+import android.util.Log;
+/**
+ * Copyright (C) 2012-2013 Stefan Thiele (CollegeDev)
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+/**
+ * Provides Central helper methods for privacy checks
+ * @author CollegeDev (Stefan T.)
+ *
+ */
+public final class ResolveHelper {
+	
+	private static final String TAG = "ResolveHelper";
+	
+	public static String[] getCallingPackageName (int uid) {
+		IPackageManager mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+    	try{
+        	String[] package_names = mPm.getPackagesForUid(uid);
+        	return package_names;
+    	}
+    	catch(Exception e){
+    		Log.e(TAG,"not able to parse calling packageName for uid: " + uid);
+    		return null;
+    	}
+    }
+	
+	/**
+	 * 
+	 * @param packageNames calling packages
+	 * @param packageName parsed package
+	 * @return position in packageNames array or -1 if it does not exist
+	 */
+	public static int fitsToCallingPackage (String[] packageNames, String packageName) {
+		if(packageNames == null || packageName == null) return -1;
+		for(int i = 0; i < packageNames.length; i++) {
+			if(packageNames[i].equals(packageName))
+				return i;
+		}
+		return -1;
+	}
+	
+	/**
+	 * 
+	 * @param uid calling uid 
+	 * @param packageName parsed package
+	 * @return position in packageNames array or -1 if it does not exist! Please note that you need an temporary packageNames object by calling getCallingPackageName()!
+	 */
+	public static int fitsToCallingPackage (int uid, String packageName) {
+		String[] packageNames = getCallingPackageName(uid);
+		if(packageNames == null) return -1;
+		for(int i = 0; i < packageNames.length; i++) {
+			if(packageNames[i].equals(packageName))
+				return i;
+		}
+		return -1;
+	}
+	
+	
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/services/java/com/android/server/am/BroadcastQueue.java pang/frameworks/base/services/java/com/android/server/am/BroadcastQueue.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/services/java/com/android/server/am/BroadcastQueue.java	2013-04-02 21:48:05.837432913 +0545
+++ pang/frameworks/base/services/java/com/android/server/am/BroadcastQueue.java	2013-05-03 21:45:47.539989021 +0545
@@ -41,6 +41,8 @@ import android.util.EventLog;
 import android.util.Log;
 import android.util.Slog;
 
+import android.privacy.surrogate.PrivacyActivityManagerService;
+
 /**
  * BROADCASTS
  *
@@ -633,8 +635,31 @@ public class BroadcastQueue {
                         + mQueueName + "] for " + r + " at " + timeoutTime);
                 setBroadcastTimeoutLocked(timeoutTime);
             }
-
+            
             Object nextReceiver = r.receivers.get(recIdx);
+            // BEGIN privacy-added
+            enforcePrivacyPermission(nextReceiver, r);
+            boolean empty = false;
+            if(r != null && r.intent != null && r.intent.getAction() != null && r.intent.getAction().equals("catchBootComplete")){
+            	empty = true;
+//            	String packageName = null;
+//            	try { // try to get intent receiver information
+//                    if (nextReceiver instanceof BroadcastFilter) {
+//                        packageName = ((BroadcastFilter) nextReceiver).receiverList.app.info.packageName;
+//                    } else if (nextReceiver instanceof ResolveInfo) {
+//                        packageName = ((ResolveInfo) nextReceiver).activityInfo.applicationInfo.packageName;
+//                    }
+//                } catch (Exception e) {
+//                    // if above information is not available, exception will be thrown
+//                    // do nothing, this is not our intent
+//                    
+//                }
+//            	if(packageName != null)
+//            		Log.i("PrivacyBroadcast", "empty=true -> INTENT_BOOT_COMPLETE should be skipped! package: " + packageName);
+//            	else
+//            		Log.i("PrivacyBroadcast", "empty=true -> INTENT_BOOT_COMPLETE should be skipped! package: " + "UNKNOWN");
+            }
+            // END privacy-added
             if (nextReceiver instanceof BroadcastFilter) {
                 // Simple case: this is a registered receiver who gets
                 // a direct call.
@@ -643,7 +668,15 @@ public class BroadcastQueue {
                         "Delivering ordered ["
                         + mQueueName + "] to registered "
                         + filter + ": " + r);
-                deliverToRegisteredReceiverLocked(r, filter, r.ordered);
+                if(!empty){
+                	deliverToRegisteredReceiverLocked(r, filter, r.ordered);
+                } else{
+                	//Log.i("PrivacyBroadcast","set r.receiver to null");
+                	r.receiver = null;
+                    r.curFilter = null;
+                    //re-initalize
+                    r.intent.setAction(Intent.ACTION_BOOT_COMPLETED);
+                }
                 if (r.receiver == null || !r.ordered) {
                     // The receiver has already finished, so schedule to
                     // process the next one.
@@ -734,7 +767,12 @@ public class BroadcastQueue {
                         + ": process crashing");
                 skip = true;
             }
-
+            //PRIVACY BEGIN
+            if(empty){ 
+            	skip = true;
+            	r.intent.setAction(Intent.ACTION_BOOT_COMPLETED);
+            }
+            //PRIVACY END
             if (skip) {
                 if (DEBUG_BROADCAST)  Slog.v(TAG,
                         "Skipping delivery of ordered ["
@@ -830,6 +868,33 @@ public class BroadcastQueue {
         }
     }
 
+    // BEGIN privacy-added
+    private void enforcePrivacyPermission(Object nextReceiver, BroadcastRecord r) {
+        if (r != null && r.intent != null && r.intent.getAction() != null) {
+            
+            String packageName = null;
+            int uid = -1;
+            try { // try to get intent receiver information
+                if (nextReceiver instanceof BroadcastFilter) {
+                    packageName = ((BroadcastFilter) nextReceiver).receiverList.app.info.packageName;
+                    uid = ((BroadcastFilter) nextReceiver).receiverList.app.info.uid;
+                } else if (nextReceiver instanceof ResolveInfo) {
+                    packageName = ((ResolveInfo) nextReceiver).activityInfo.applicationInfo.packageName;
+                    uid = ((ResolveInfo) nextReceiver).activityInfo.applicationInfo.uid;
+                }
+            } catch (Exception e) {
+                // if above information is not available, exception will be thrown
+                // do nothing, this is not our intent
+                return;
+            }
+            
+            if (packageName != null && uid != -1) {
+                PrivacyActivityManagerService.enforcePrivacyPermission(packageName, uid, r.intent, null, r.receivers.size());
+            }
+        }
+    }
+    // END privacy-added
+
     final void setBroadcastTimeoutLocked(long timeoutTime) {
         if (! mPendingBroadcastTimeoutMessage) {
             Message msg = mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG, this);
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/services/java/com/android/server/net/NetworkPolicyManagerService.java pang/frameworks/base/services/java/com/android/server/net/NetworkPolicyManagerService.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/services/java/com/android/server/net/NetworkPolicyManagerService.java	2013-04-02 21:48:05.845432812 +0545
+++ pang/frameworks/base/services/java/com/android/server/net/NetworkPolicyManagerService.java	2013-05-03 21:46:39.513335299 +0545
@@ -695,7 +695,8 @@ public class NetworkPolicyManagerService
                 // mobile templates are relevant when SIM is ready and
                 // subscriberId matches.
                 if (tele.getSimState() == SIM_STATE_READY) {
-                    return Objects.equal(tele.getSubscriberId(), template.getSubscriberId());
+                    return Objects.equal(((android.privacy.surrogate.PrivacyTelephonyManager)tele).getSafeSubscriberId(), template.getSubscriberId());
+                	//return true;
                 } else {
                     return false;
                 }
@@ -953,7 +954,7 @@ public class NetworkPolicyManagerService
                 // TODO: offer more granular control over radio states once
                 // 4965893 is available.
                 if (tele.getSimState() == SIM_STATE_READY
-                        && Objects.equal(tele.getSubscriberId(), template.getSubscriberId())) {
+                        && Objects.equal(((android.privacy.surrogate.PrivacyTelephonyManager)tele).getSafeSubscriberId(), template.getSubscriberId())) {
                     setPolicyDataEnable(TYPE_MOBILE, enabled);
                     setPolicyDataEnable(TYPE_WIMAX, enabled);
                 }
@@ -1109,7 +1110,7 @@ public class NetworkPolicyManagerService
         // avoid creating policy when SIM isn't ready
         if (tele.getSimState() != SIM_STATE_READY) return;
 
-        final String subscriberId = tele.getSubscriberId();
+        final String subscriberId = ((android.privacy.surrogate.PrivacyTelephonyManager)tele).getSafeSubscriberId();
         final NetworkIdentity probeIdent = new NetworkIdentity(
                 TYPE_MOBILE, TelephonyManager.NETWORK_TYPE_UNKNOWN, subscriberId, null, false);
 
@@ -1157,6 +1158,11 @@ public class NetworkPolicyManagerService
 
             int type;
             int version = VERSION_INIT;
+            
+            //----------------------------------------------------
+            final TelephonyManager tele = TelephonyManager.from(mContext);
+            //----------------------------------------------------
+            
             while ((type = in.next()) != END_DOCUMENT) {
                 final String tag = in.getName();
                 if (type == START_TAG) {
@@ -1171,7 +1177,7 @@ public class NetworkPolicyManagerService
 
                     } else if (TAG_NETWORK_POLICY.equals(tag)) {
                         final int networkTemplate = readIntAttribute(in, ATTR_NETWORK_TEMPLATE);
-                        final String subscriberId = in.getAttributeValue(null, ATTR_SUBSCRIBER_ID);
+                        final String subscriberId = ((android.privacy.surrogate.PrivacyTelephonyManager)tele).getSafeSubscriberId();//in.getAttributeValue(null, ATTR_SUBSCRIBER_ID);
                         final String networkId;
                         if (version >= VERSION_ADDED_NETWORK_ID) {
                             networkId = in.getAttributeValue(null, ATTR_NETWORK_ID);
@@ -1458,7 +1464,6 @@ public class NetworkPolicyManagerService
 
     private void addNetworkPolicyLocked(NetworkPolicy policy) {
         mNetworkPolicy.put(policy.template, policy);
-
         updateNetworkEnabledLocked();
         updateNetworkRulesLocked();
         updateNotificationsLocked();
@@ -1507,7 +1512,6 @@ public class NetworkPolicyManagerService
                 default:
                     throw new IllegalArgumentException("unexpected type");
             }
-
             updateNetworkEnabledLocked();
             updateNetworkRulesLocked();
             updateNotificationsLocked();
@@ -1633,7 +1637,6 @@ public class NetworkPolicyManagerService
                 for (NetworkPolicy policy : mNetworkPolicy.values()) {
                     policy.clearSnooze();
                 }
-
                 updateNetworkEnabledLocked();
                 updateNetworkRulesLocked();
                 updateNotificationsLocked();
@@ -1914,7 +1917,6 @@ public class NetworkPolicyManagerService
                             } catch (RemoteException e) {
                                 // ignored; service lives in system_server
                             }
-
                             updateNetworkEnabledLocked();
                             updateNotificationsLocked();
                         }
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/services/java/com/android/server/PrivacyTelephonyRegistry.java pang/frameworks/base/services/java/com/android/server/PrivacyTelephonyRegistry.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/services/java/com/android/server/PrivacyTelephonyRegistry.java	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/base/services/java/com/android/server/PrivacyTelephonyRegistry.java	2013-01-22 01:43:10.082353300 +0545
@@ -0,0 +1,484 @@
+package com.android.server;
+
+import java.math.BigDecimal;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Random;
+
+import com.android.internal.telephony.IPhoneStateListener;
+import com.android.server.TelephonyRegistry.Record;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Bundle;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyConstants;
+import android.privacy.utilities.PrivacyDebugger;
+import android.telephony.CellInfo;
+import android.telephony.CellInfoGsm;
+import android.telephony.CellInfoLte;
+import android.telephony.CellInfoCdma;
+import android.telephony.CellIdentityGsm;
+import android.telephony.CellIdentityLte;
+import android.telephony.CellIdentityCdma;
+import android.telephony.PhoneStateListener;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
+import android.telephony.TelephonyManager;
+import android.telephony.cdma.CdmaCellLocation;
+import android.telephony.gsm.GsmCellLocation;
+
+/**
+ * Copyright (C) 2012-2013 Stefan Thiele (CollegeDev)
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+/**
+ * Provides Central Handling
+ * @author CollegeDev (Stefan Thiele)
+ */
+public class PrivacyTelephonyRegistry extends TelephonyRegistry {
+
+	private static final String P_TAG = "PrivacyTelephonyRegistry";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private static final int PERMISSION_CELL_LOCATION = 0;
+	
+	private static final int PERMISSION_CELL_INFO = 1;
+	
+	private static final int PERMISSION_SIGNAL_STRENGTH = 2;
+	
+	private static final int PERMISSION_CALL_STATE = 3;
+	
+	private static final int PERMISSION_SERVICE_STATE = 4;
+	
+	private static final int CELL_INFO_GSM = 1;
+	
+	private static final int CELL_INFO_CDMA = 2;
+	
+	private static final int CELL_INFO_LTE = 3;
+	
+	private boolean preventBroadcasting = false;
+	
+	private Context context;
+	
+	/**
+	 * do not needs to synchronize, because only gets call while inside synchronized(mRecords)
+	 */
+	private ArrayList<Record> mCacheAll = new ArrayList<Record>();
+	private ArrayList<Record> mCacheAllow = new ArrayList<Record>();
+	private ArrayList<Record> mCacheBlock = new ArrayList<Record>();
+	private ArrayList<IBinder> mIdlingCache = new ArrayList<IBinder>();
+	
+	public PrivacyTelephonyRegistry(Context context) {
+		super(context);
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		try{
+			registerPrivacy();
+		} catch(Exception e){
+			PrivacyDebugger.e(P_TAG,"failed to register privacy broadcastreceiver");
+		}
+		PrivacyDebugger.i(P_TAG,"constructor ready");
+	}
+	
+	/** This broadCastReceiver receives the privacy intent for blocking phonecalls and faking phonestate */
+	private final BroadcastReceiver privacyReceiver = new BroadcastReceiver()
+    {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if(intent.getAction().equals("android.privacy.BLOCKED_PHONE_CALL")){
+            	Bundle data = new Bundle();
+            	data = intent.getExtras();
+            	String packageName = data.getString("packageName");
+            	if(data.containsKey("packageName")){
+            		PrivacyDebugger.i(P_TAG, "got blocked phone call INTENT from package: " + data.getString("packageName"));
+            	} else{
+            		PrivacyDebugger.i(P_TAG, "got blocked phone call INTENT without package information");
+            	}
+            	if(packageName == null) return;
+            	if(data.containsKey("phoneState")){
+            		int state = data.getInt("phoneState");
+            		switch(state){
+            			case TelephonyManager.CALL_STATE_IDLE:
+            				notifyPrivacyCallState(TelephonyManager.CALL_STATE_IDLE, null, packageName);
+            				return;
+            			case TelephonyManager.CALL_STATE_OFFHOOK:
+            				notifyPrivacyCallState(TelephonyManager.CALL_STATE_OFFHOOK, null, packageName);
+            				return;
+            			case TelephonyManager.CALL_STATE_RINGING:
+            				notifyPrivacyCallState(TelephonyManager.CALL_STATE_RINGING, "12345", packageName);
+            				return;
+            			default:
+            				return;
+            		}
+            	}
+            	PrivacyDebugger.i(P_TAG,"we forgot to put phoneState in Intent?");
+            }
+        }
+    };
+    
+    /**
+     * This method allows us to fake a call state if application uses phoneStateListener. It will call the onCallStateChanged method with faked state and number
+     * @param state {@link TelephonyManager} TelephonyManager.CALL_STATE_IDLE <br> TelephonyManager.CALL_STATE_OFFHOOK <br> TelephonyManager.CALL_STATE_RINGING <br>
+     * @param incomingNumber pass null if you don't choose ringing!
+     * @param packageName the affected package to fake callstate!
+     * @author CollegeDev
+     */
+    private void notifyPrivacyCallState(int state, String incomingNumber, String packageName) {
+
+        synchronized (mRecords) {
+
+            for (Record r : mRecords) {
+                if ((r.events & PhoneStateListener.LISTEN_CALL_STATE) != 0) {
+                    try {
+                    	//only notify the affected application
+                    	if(r.pkgForDebug.equals(packageName)){
+                    		r.callback.onCallStateChanged(state, incomingNumber);
+                    	}
+                    } catch (RemoteException ex) {
+                        mRemoveList.add(r.binder);
+                    }
+                }
+            }
+            handleRemoveListLocked();
+        }
+
+    }
+    
+    private void registerPrivacy(){
+    	 IntentFilter intentFilter = new IntentFilter("android.privacy.BLOCKED_PHONE_CALL");
+    	 mContext.registerReceiver(privacyReceiver, intentFilter);
+    }
+	
+    @Override
+    public void listen(String pkgForDebug, IPhoneStateListener callback, int events, boolean notifyNow) {
+		try{
+			registerPrivacy();
+		} catch(Exception e){
+			PrivacyDebugger.e(P_TAG,"failed to register privacy receiver", e);
+		}
+    	
+    	if(!isPackageAllowed(PERMISSION_CELL_LOCATION, pkgForDebug) || !isPackageAllowed(PERMISSION_CELL_INFO, pkgForDebug)) {
+    		PrivacyDebugger.i(P_TAG, "package: " + pkgForDebug + " is now listening. notifyNow: false. isAllowed: false");
+    		super.listen(pkgForDebug, callback, events, false);
+    	} else {
+    		PrivacyDebugger.i(P_TAG, "package: " + pkgForDebug + " is now listening. notifyNow: " + notifyNow + ". isAllowed: true");
+    		super.listen(pkgForDebug, callback, events, notifyNow);
+    	}
+    }
+	
+	
+	private boolean isPackageAllowed(int PERMISSION, String packageName){
+		if(pSetMan == null) pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		PrivacySettings settings = pSetMan.getSettings(packageName);
+		if(settings == null) {
+			PrivacyDebugger.e(P_TAG,"we return true, because settings are not available"); 
+			return true; 
+		}
+		switch(PERMISSION){
+			case PERMISSION_CELL_LOCATION:
+				if(settings.getLocationNetworkSetting() != PrivacySettings.REAL)
+					return false;
+				else 
+					return true;
+			case PERMISSION_CELL_INFO:
+				if(settings.getNetworkInfoSetting() != PrivacySettings.REAL)
+					return false;
+				else
+					return true;
+			case PERMISSION_SIGNAL_STRENGTH:
+				if(settings.getNetworkInfoSetting() != PrivacySettings.REAL)
+					return false;
+				else
+					return true;
+			case PERMISSION_CALL_STATE:
+				if(settings.getNetworkInfoSetting() != PrivacySettings.REAL)
+					return false;
+				else
+					return true;
+			case PERMISSION_SERVICE_STATE:
+				if(settings.getNetworkInfoSetting() != PrivacySettings.REAL)
+					return false;
+				else
+					return true;
+			default:
+				return false;
+		}
+	}
+
+	@Override
+	public void notifyServiceState(ServiceState state) {
+        synchronized (mRecords) {
+        	initOperations();
+            for (Record r : mRecords) {
+                if ((r.events & PhoneStateListener.LISTEN_SERVICE_STATE) != 0) {
+                	if(isPackageAllowed(PERMISSION_SERVICE_STATE, r.pkgForDebug)) {
+                		mCacheAllow.add(r);
+                		PrivacyDebugger.i(P_TAG, "allow package: " + r.pkgForDebug +" for getting ServiceState");
+                	} else {
+                		mCacheBlock.add(r);
+                		PrivacyDebugger.i(P_TAG, "block package: " + r.pkgForDebug +" for getting ServiceState");
+                	}
+                }
+            }
+            preventBroadcasting = true;
+            onPrepareBlockedPackages();
+            PrivacyDebugger.i(P_TAG,"now inform blocked packages (ServiceState), count: " + mCacheBlock.size());
+            if(mCacheBlock.size() > 0)
+            	super.notifyServiceState(PrivacyConstants.PrivacyServiceState.getPrivacyServiceState(state));
+
+            
+            onPrepareAllowedPackages();
+            PrivacyDebugger.i(P_TAG,"now inform allowed packages (ServiceState), count: " + mCacheAllow.size());
+            if(mCacheAllow.size() > 0)
+            	super.notifyServiceState(state);
+
+            
+            onExit();
+        }
+    }
+
+	@Override
+	public void notifyCellInfo(List<CellInfo> cellInfo) {
+		synchronized (mRecords) {
+			initOperations();
+            for (Record r : mRecords) {
+                if ((r.events & PhoneStateListener.LISTEN_CELL_INFO) != 0) {
+                	if(isPackageAllowed(PERMISSION_CELL_INFO, r.pkgForDebug)) {
+                		mCacheAllow.add(r);
+                		PrivacyDebugger.i(P_TAG, "allow package: " + r.pkgForDebug +" for getting CellInfo");
+                	} else {
+                		mCacheBlock.add(r);
+                		PrivacyDebugger.i(P_TAG, "block package: " + r.pkgForDebug +" for getting CellInfo");
+                	}
+                }
+            }
+            onPrepareBlockedPackages();
+            PrivacyDebugger.i(P_TAG,"now inform blocked packages (cellInfo), count: " + mCacheBlock.size());
+            if(mCacheBlock.size() > 0)
+            	super.notifyCellInfo(getPrivacyCellInfo(cellInfo));
+
+            
+            onPrepareAllowedPackages();
+            PrivacyDebugger.i(P_TAG,"now inform allowed packages (cellInfo), count: " + mCacheAllow.size());
+            if(mCacheAllow.size() > 0)
+            	super.notifyCellInfo(cellInfo);
+
+            
+            onExit();
+		}
+    }
+	
+	@Override
+	public void notifyCellLocation(Bundle cellLocation) { //take care of it!
+		synchronized (mRecords) {
+			initOperations();
+            for (Record r : mRecords) {
+                if (validateEventsAndUserLocked(r, PhoneStateListener.LISTEN_CELL_LOCATION)) {
+                	if(isPackageAllowed(PERMISSION_CELL_LOCATION, r.pkgForDebug)) {
+                		mCacheAllow.add(r);
+                		PrivacyDebugger.i(P_TAG, "allow package: " + r.pkgForDebug +" for getting CellLocation");
+                	} else {
+                		mCacheBlock.add(r);
+                		PrivacyDebugger.i(P_TAG, "block package: " + r.pkgForDebug +" for getting CellLocation");
+                	}
+                }
+            }
+            onPrepareBlockedPackages();
+            PrivacyDebugger.i(P_TAG,"now inform blocked packages (cellLocation), count: " + mCacheBlock.size());
+            if(mCacheBlock.size() > 0)
+            	super.notifyCellLocation(getCellLocationBundle(cellLocation));
+
+            
+            onPrepareAllowedPackages();
+            PrivacyDebugger.i(P_TAG,"now inform allowed packages (cellLocation), count: " + mCacheAllow.size());
+            if(mCacheAllow.size() > 0)
+            	super.notifyCellLocation(cellLocation);
+
+            
+            onExit();
+        }
+    }
+	
+	@Override
+	protected void broadcastServiceStateChanged(ServiceState state) {
+		if(preventBroadcasting) {
+			preventBroadcasting = false;
+			PrivacyDebugger.i(P_TAG, "prevent from broadcasting the service state");
+			return;
+		} else {
+			PrivacyDebugger.i(P_TAG,"allowed to broadcast service state");
+			super.broadcastServiceStateChanged(PrivacyConstants.PrivacyServiceState.getPrivacyServiceState(state));
+		}
+			
+	}
+	
+	@Override
+	protected void handleRemoveListLocked() {
+		if (mRemoveList.size() > 0) {
+			mIdlingCache.addAll(mRemoveList);
+        }
+		super.handleRemoveListLocked();
+	}
+	
+	/**
+	 * only call it if you parsed and filled the other caching lists
+	 */
+	private void onPrepareBlockedPackages () {
+		mRecords.clear();
+		mRecords.addAll(mCacheBlock);
+	}
+	
+	/**
+	 * only call it if you parsed and filled the other caching lists
+	 */
+	private void onPrepareAllowedPackages () {
+		mRecords.clear();
+		mRecords.addAll(mCacheAllow);
+	}
+	
+	/**
+	 * call it at the end of the operation
+	 */
+	private void onExit () {
+		mRecords.clear();
+		mRecords.addAll(mCacheAll);
+		
+		cleanUp();
+		
+		PrivacyDebugger.i(P_TAG,"ready with operation. Size of records: " + mRecords.size());
+		clearCache();
+	}
+	
+	/**
+	 * This this method in the onExit to clean up variables! important!
+	 */
+	private void cleanUp () {
+		if(mIdlingCache.size() > 0) {
+			for(IBinder b : mIdlingCache)
+				remove(b);
+		}
+		mIdlingCache.clear();
+	}
+	
+	/**
+	 * clears current caches
+	 */
+	private void clearCache() {
+		mCacheAll.clear();
+		mCacheAllow.clear();
+		mCacheBlock.clear();
+		mIdlingCache.clear();
+	}
+	
+	/**
+	 * call it right after locking the mRecords list
+	 */
+	private void initOperations () {
+		clearCache();
+		mCacheAll.addAll(mRecords);
+		PrivacyDebugger.i(P_TAG,"begin operations. Size of records: " + mRecords.size());
+	}
+	
+	/**
+	 * Create ready privacy bundle for CellLocation
+	 * @param cellLocation current celllocation
+	 * @return privacy bundle (cellLocation)
+	 */
+	private Bundle getCellLocationBundle(Bundle cellLocation) {
+		Bundle output = new Bundle();
+		if(cellLocation.containsKey("lac")) {
+			//it is gsm cell location object, handle it!
+			GsmCellLocation location = new GsmCellLocation();
+			location.setStateInvalid();
+			PrivacyDebugger.i(P_TAG, "now creating fake gsm cellLocation");
+			location.fillInNotifierBundle(output);
+		} else {
+			CdmaCellLocation location = new CdmaCellLocation();
+			location.setStateInvalid();
+			PrivacyDebugger.i(P_TAG, "now creating fake cdma cellLocation");
+			location.fillInNotifierBundle(output);
+		}
+		return output;
+	}
+	
+    /**
+	 * Generates safety cellInfo
+	 * @return ready list with cellInfo(s)
+	 */
+	private List<CellInfo> getPrivacyCellInfo (List<CellInfo> info) {
+		List<CellInfo> output = new ArrayList<CellInfo>();
+		int mState = -1;
+		CellInfo mCache = null;
+		for(CellInfo data : info) {
+			if(data instanceof CellInfoGsm) {
+				mState = CELL_INFO_GSM;
+				mCache = data;
+				break;
+			} else if(data instanceof CellInfoCdma) {
+				mState = CELL_INFO_CDMA;
+				mCache = data;
+				break;
+			} else if(data instanceof CellInfoLte) {
+				mState = CELL_INFO_LTE;
+				mCache = data;
+				break;
+			}
+		}
+		if(mCache == null || mState == -1) {
+			PrivacyDebugger.e(P_TAG, "SECURITY WARNING! Can't parse fake CellInfo, give empty list as result!");
+			return output;
+		}
+		switch(mState) {
+			case CELL_INFO_GSM:
+				CellInfoGsm out = new CellInfoGsm((CellInfoGsm)mCache);
+				out.setCellIdentity(new CellIdentityGsm(PrivacyConstants.GSM.getMobileCountryCode(), 
+														PrivacyConstants.GSM.getMobileNetworkCode(),
+														PrivacyConstants.GSM.getLocationAreaCode(),
+														PrivacyConstants.GSM.getCellIdentity(),
+														PrivacyConstants.GSM.getPrimaryScramblingCode()));//TODO: check for scrambling code! why do java need this stuff? 
+				output.add(out);
+				PrivacyDebugger.i(P_TAG,"created fake gsm info");
+				break;
+			case CELL_INFO_CDMA:
+				CellInfoCdma out1 = new CellInfoCdma((CellInfoCdma)mCache);
+				out1.setCellIdentity(new CellIdentityCdma(	PrivacyConstants.CDMA.getCdmaNetworkId(),
+															PrivacyConstants.CDMA.getCdmaSystemId(),
+															PrivacyConstants.CDMA.getCdmaBaseStationId(),
+															PrivacyConstants.CDMA.getCdmaRandomLon(),
+															PrivacyConstants.CDMA.getCdmaRandomLat()));
+				output.add(out1);
+				PrivacyDebugger.i(P_TAG,"created fake cdma info");
+				break;
+			case CELL_INFO_LTE:
+				CellInfoLte out2 = new CellInfoLte((CellInfoLte)mCache);
+				out2.setCellIdentity(new CellIdentityLte(	PrivacyConstants.LTE.getMobileCountryCode(),
+															PrivacyConstants.LTE.getMobileNetworkCode(),
+															PrivacyConstants.LTE.getCellIdentity(),
+															PrivacyConstants.LTE.getPhysicalCellId(),
+															PrivacyConstants.LTE.getTrackingAreaCode()));
+				
+				output.add(out2);
+				PrivacyDebugger.i(P_TAG,"created fake lte info");
+				break;
+		}
+		
+		return output;
+	}
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/services/java/com/android/server/SystemServer.java pang/frameworks/base/services/java/com/android/server/SystemServer.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/services/java/com/android/server/SystemServer.java	2013-04-02 21:48:05.829433015 +0545
+++ pang/frameworks/base/services/java/com/android/server/SystemServer.java	2013-05-03 21:44:06.839631629 +0545
@@ -79,6 +79,11 @@ import java.util.TimerTask;
 import com.stericsson.hardware.fm.FmReceiverService;
 import com.stericsson.hardware.fm.FmTransmitterService;
 
+// BEGIN privacy-added
+import android.privacy.PrivacySettingsManagerService;
+//import android.privacy.surrogate.PrivacyTelephonyRegistry;
+// END privacy-added
+
 class ServerThread extends Thread {
     private static final String TAG = "SystemServer";
     private static final String ENCRYPTING_STATE = "trigger_restart_min_framework";
@@ -244,7 +249,8 @@ class ServerThread extends Thread {
             ServiceManager.addService(Context.DISPLAY_SERVICE, display, true);
 
             Slog.i(TAG, "Telephony Registry");
-            telephonyRegistry = new TelephonyRegistry(context);
+            //telephonyRegistry = new TelephonyRegistry(context);
+            telephonyRegistry = new PrivacyTelephonyRegistry(context);
             ServiceManager.addService("telephony.registry", telephonyRegistry);
 
             Slog.i(TAG, "Scheduling Policy");
@@ -299,6 +305,10 @@ class ServerThread extends Thread {
             Slog.i(TAG, "Content Manager");
             contentService = ContentService.main(context,
                     factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL);
+	    
+            // BEGIN privacy-added
+            addPrivacyService(context);
+            // END privacy-added
 
             Slog.i(TAG, "System Content Providers");
             ActivityManagerService.installSystemProviders();
@@ -1102,6 +1112,19 @@ class ServerThread extends Thread {
         //Slog.d(TAG, "Starting service: " + intent);
         context.startServiceAsUser(intent, UserHandle.OWNER);
     }
+
+    // BEGIN privacy-added
+    private void addPrivacyService(Context context) {
+        try {
+            Log.i(TAG, "Privacy Service");
+            ServiceManager.addService("privacy", new PrivacySettingsManagerService(context));
+        } catch (Throwable e) {
+            Log.e(TAG, "Failure starting Privacy Service", e);
+        }        
+    }
+    // END privacy-added
+
+
 }
 
 public class SystemServer {
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/services/java/com/android/server/TelephonyRegistry.java pang/frameworks/base/services/java/com/android/server/TelephonyRegistry.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/services/java/com/android/server/TelephonyRegistry.java	2013-04-02 21:48:05.829433015 +0545
+++ pang/frameworks/base/services/java/com/android/server/TelephonyRegistry.java	2013-05-03 21:44:56.670076862 +0545
@@ -54,6 +54,7 @@ import com.android.internal.telephony.Se
 import com.android.internal.telephony.TelephonyIntents;
 import com.android.server.am.BatteryStatsService;
 
+
 /**
  * Since phone process can be restarted, this class provides a centralized place
  * that applications can register and be called back from.
@@ -63,7 +64,7 @@ class TelephonyRegistry extends ITelepho
     private static final boolean DBG = false;
     private static final boolean DBG_LOC = false;
 
-    private static class Record {
+    public static class Record {
         String pkgForDebug;
 
         IBinder binder;
@@ -81,29 +82,29 @@ class TelephonyRegistry extends ITelepho
         }
     }
 
-    private final Context mContext;
+    protected final Context mContext;
 
     // access should be inside synchronized (mRecords) for these two fields
-    private final ArrayList<IBinder> mRemoveList = new ArrayList<IBinder>();
-    private final ArrayList<Record> mRecords = new ArrayList<Record>();
+    protected final ArrayList<IBinder> mRemoveList = new ArrayList<IBinder>();
+    protected final ArrayList<Record> mRecords = new ArrayList<Record>();
 
     private final IBatteryStats mBatteryStats;
 
-    private int mCallState = TelephonyManager.CALL_STATE_IDLE;
+    protected int mCallState = TelephonyManager.CALL_STATE_IDLE;
 
-    private String mCallIncomingNumber = "";
+    protected String mCallIncomingNumber = "";
 
-    private ServiceState mServiceState = new ServiceState();
+    protected ServiceState mServiceState = new ServiceState();
 
-    private SignalStrength mSignalStrength = new SignalStrength();
+    protected SignalStrength mSignalStrength = new SignalStrength();
 
-    private boolean mMessageWaiting = false;
+    protected boolean mMessageWaiting = false;
 
-    private boolean mCallForwarding = false;
+    protected boolean mCallForwarding = false;
 
-    private int mDataActivity = TelephonyManager.DATA_ACTIVITY_NONE;
+    protected int mDataActivity = TelephonyManager.DATA_ACTIVITY_NONE;
 
-    private int mDataConnectionState = TelephonyManager.DATA_UNKNOWN;
+    protected int mDataConnectionState = TelephonyManager.DATA_UNKNOWN;
 
     private boolean mDataConnectionPossible = false;
 
@@ -117,13 +118,13 @@ class TelephonyRegistry extends ITelepho
 
     private LinkCapabilities mDataConnectionLinkCapabilities;
 
-    private Bundle mCellLocation = new Bundle();
+    protected Bundle mCellLocation = new Bundle();
 
-    private int mDataConnectionNetworkType;
+    protected int mDataConnectionNetworkType;
 
-    private int mOtaspMode = ServiceStateTracker.OTASP_UNKNOWN;
+    protected int mOtaspMode = ServiceStateTracker.OTASP_UNKNOWN;
 
-    private List<CellInfo> mCellInfo = null;
+    protected List<CellInfo> mCellInfo = null;
 
     static final int PHONE_STATE_PERMISSION_MASK =
                 PhoneStateListener.LISTEN_CALL_FORWARDING_INDICATOR |
@@ -165,7 +166,7 @@ class TelephonyRegistry extends ITelepho
     // calls go through a oneway interface and local calls going through a
     // handler before they get to app code.
 
-    TelephonyRegistry(Context context) {
+    protected TelephonyRegistry(Context context) {
         CellLocation  location = CellLocation.getEmpty();
 
         // Note that location can be null for non-phone builds like
@@ -312,7 +313,7 @@ class TelephonyRegistry extends ITelepho
         }
     }
 
-    private void remove(IBinder binder) {
+    protected void remove(IBinder binder) {
         synchronized (mRecords) {
             final int recordCount = mRecords.size();
             for (int i = 0; i < recordCount; i++) {
@@ -334,6 +335,7 @@ class TelephonyRegistry extends ITelepho
             for (Record r : mRecords) {
                 if ((r.events & PhoneStateListener.LISTEN_CALL_STATE) != 0) {
                     try {
+                    	
                         r.callback.onCallStateChanged(state, incomingNumber);
                     } catch (RemoteException ex) {
                         mRemoveList.add(r.binder);
@@ -364,7 +366,7 @@ class TelephonyRegistry extends ITelepho
         }
         broadcastServiceStateChanged(state);
     }
-
+    
     public void notifySignalStrength(SignalStrength signalStrength) {
         if (!checkNotifyPermission("notifySignalStrength()")) {
             return;
@@ -639,7 +641,7 @@ class TelephonyRegistry extends ITelepho
     // the legacy intent broadcasting
     //
 
-    private void broadcastServiceStateChanged(ServiceState state) {
+    protected void broadcastServiceStateChanged(ServiceState state) {
         long ident = Binder.clearCallingIdentity();
         try {
             mBatteryStats.notePhoneState(state.getState());
@@ -738,7 +740,7 @@ class TelephonyRegistry extends ITelepho
         mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
     }
 
-    private boolean checkNotifyPermission(String method) {
+    protected boolean checkNotifyPermission(String method) {
         if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
                 == PackageManager.PERMISSION_GRANTED) {
             return true;
@@ -749,7 +751,7 @@ class TelephonyRegistry extends ITelepho
         return false;
     }
 
-    private void checkListenerPermission(int events) {
+    protected void checkListenerPermission(int events) {
         if ((events & PhoneStateListener.LISTEN_CELL_LOCATION) != 0) {
             mContext.enforceCallingOrSelfPermission(
                     android.Manifest.permission.ACCESS_COARSE_LOCATION, null);
@@ -768,7 +770,7 @@ class TelephonyRegistry extends ITelepho
         }
     }
 
-    private void handleRemoveListLocked() {
+    protected void handleRemoveListLocked() {
         if (mRemoveList.size() > 0) {
             for (IBinder b: mRemoveList) {
                 remove(b);
@@ -777,7 +779,7 @@ class TelephonyRegistry extends ITelepho
         }
     }
 
-    private boolean validateEventsAndUserLocked(Record r, int events) {
+    protected boolean validateEventsAndUserLocked(Record r, int events) {
         int foregroundUser;
         long callingIdentity = Binder.clearCallingIdentity();
         boolean valid = false;
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/services/java/com/android/server/ThrottleService.java pang/frameworks/base/services/java/com/android/server/ThrottleService.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/services/java/com/android/server/ThrottleService.java	2013-04-02 21:48:05.829433015 +0545
+++ pang/frameworks/base/services/java/com/android/server/ThrottleService.java	2013-01-16 01:18:39.992621111 +0545
@@ -76,7 +76,7 @@ public class ThrottleService extends ITh
 
     private static final String TAG = "ThrottleService";
     private static final boolean DBG = true;
-    private static final boolean VDBG = false;
+    private static final boolean VDBG = true;
     private Handler mHandler;
     private HandlerThread mThread;
 
@@ -936,6 +936,7 @@ public class ThrottleService extends ITh
             File throttleDir = new File(dataDir, "system/throttle");
             throttleDir.mkdirs();
             String mImsi = mTelephonyManager.getSubscriberId();
+	    Slog.v(TAG,"got subscriberId from telephony Manager: " + mImsi);
             File dataFile;
             if (mImsi == null) {
                 dataFile = useMRUFile(throttleDir);
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/telephony/java/android/telephony/PhoneStateListener.java pang/frameworks/base/telephony/java/android/telephony/PhoneStateListener.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/telephony/java/android/telephony/PhoneStateListener.java	2013-04-02 21:48:05.861432612 +0545
+++ pang/frameworks/base/telephony/java/android/telephony/PhoneStateListener.java	2013-02-05 00:44:31.067710804 +0545
@@ -16,15 +16,26 @@
 
 package android.telephony;
 
+import android.os.Binder;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.Message;
+import android.os.ServiceManager;
 import android.telephony.ServiceState;
 import android.telephony.SignalStrength;
 import android.telephony.CellLocation;
 import android.telephony.CellInfo;
 import android.util.Log;
 
+// BEGIN privacy-added
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+import android.content.Context;
+// END privacy-added
+
+
 import com.android.internal.telephony.IPhoneStateListener;
 
 import java.util.List;
@@ -158,6 +169,30 @@ public class PhoneStateListener {
      */
     public static final int LISTEN_OTASP_CHANGED                            = 0x00000200;
 
+    // BEGIN privacy-added
+    private Context context;
+    private String packageName;
+    private int uid;
+    private final static String TAG = "PhoneStateListener"; 
+    
+    /** {@hide} */
+    public void setContext(Context context) {
+        this.context = context;
+    }
+    
+
+    public void setPackageName(String packageName) {
+        this.packageName = packageName;
+    }
+    
+    /** {@hide} */
+    public void setUid(int uid) {
+        this.uid = uid;
+    }    
+    
+    // END privacy-added
+ 
+
     /**
      * Listen for changes to observed cell info.
      *
@@ -317,11 +352,73 @@ public class PhoneStateListener {
 
         public void onCellLocationChanged(Bundle bundle) {
             CellLocation location = CellLocation.newFromBundle(bundle);
-            Message.obtain(mHandler, LISTEN_CELL_LOCATION, 0, 0, location).sendToTarget();
+            // BEGIN privacy-modified
+            if (context != null) {
+                PrivacySettingsManager pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+                PrivacySettings pSet = pSetMan.getSettings(packageName);
+                String output;
+                if (pSet != null && pSet.getLocationNetworkSetting() != PrivacySettings.REAL) {
+                    // simply block the method call, since simulating cell location is not feasible
+                    output = "[no output]";
+                    if(pSet.isDefaultDenyObject())
+                    	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+                    else
+                    	pSetMan.notification(packageName, 0, pSet.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+                } else {
+                    output = location.toString();
+                    Message.obtain(mHandler, LISTEN_CELL_LOCATION, 0, 0, location).sendToTarget();
+                    if(pSet != null && pSet.isDefaultDenyObject())
+                    	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);         
+                    else
+                    	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);       
+                }
+                PrivacyDebugger.d(TAG, "onCellLocationChanged - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+            } else {
+            	PrivacyDebugger.w(TAG, "onCellLocationChanged - cannot handle privacy because context is null -> empty");
+            }
+            // END privacy-modified
         }
 
         public void onCallStateChanged(int state, String incomingNumber) {
-            Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, incomingNumber).sendToTarget();
+            // BEGIN privacy-modified
+            PrivacyDebugger.d(TAG, "onCallStateChanged - state:" + state + " incoming number:" + incomingNumber);
+            // only take action if an incoming phone number is actually transmitted
+            if (context != null && incomingNumber != null && !incomingNumber.isEmpty()) {
+                PrivacySettingsManager pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+                PrivacySettings pSet = pSetMan.getSettings(packageName);
+                String output;
+                if (pSet != null && pSet.getIncomingCallsSetting() != PrivacySettings.REAL) {
+                    output = "";
+                    Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, output).sendToTarget();
+                    PrivacyDebugger.d(TAG, "onCallStateChanged BLOCK - package:" + ((packageName != null) ? packageName : "unknown") + " state:" + state + " output: " + output);
+                    if(pSet.isDefaultDenyObject())
+                    	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_INCOMING_CALL, output, pSet);
+                    else
+                    	pSetMan.notification(packageName, 0, PrivacySettings.EMPTY, PrivacySettings.DATA_INCOMING_CALL, output, pSet);
+                } else {
+                    Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, incomingNumber).sendToTarget();
+                    PrivacyDebugger.d(TAG, "onCallStateChanged REAL - package:" + ((packageName != null) ? packageName : "unknown") + " state:" + state + " output: " + incomingNumber);
+                    if(pSet != null && pSet.isDefaultDenyObject())
+                    	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_INCOMING_CALL, incomingNumber, pSet);
+                    else
+                    	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_INCOMING_CALL, incomingNumber, pSet);
+                }
+            } else {
+                PrivacyDebugger.e(TAG, "can't handle privacySettings because context is null?!");
+                PrivacyDebugger.d(TAG, "onCallStateChanged default deny");
+                switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+                	case PrivacySettings.DEFAULT_DENY_EMPTY:
+                	case PrivacySettings.DEFAULT_DENY_RANDOM:
+                		PrivacyDebugger.w(TAG, "default deny is empty or random, now handle callStateChanged - package: " +  ((packageName != null) ? packageName : "unknown") + " Output:" + ((incomingNumber != null) ? "EMPTY" : "NULL"));
+                        Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, ((incomingNumber != null) ? "" : null)).sendToTarget();
+                        break;
+                	case PrivacySettings.DEFAULT_DENY_REAL:
+                		PrivacyDebugger.w(TAG, "default deny is real, now handle callStateChanged - package: " +  ((packageName != null) ? packageName : "unknown") + " Output: REAL_VALUE");
+                		Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, incomingNumber).sendToTarget();
+                		break;
+                }
+            }
+            // END privacy-modified
         }
 
         public void onDataConnectionStateChanged(int state, int networkType) {
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/telephony/java/android/telephony/ServiceState.java pang/frameworks/base/telephony/java/android/telephony/ServiceState.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/telephony/java/android/telephony/ServiceState.java	2013-04-02 21:48:05.861432612 +0545
+++ pang/frameworks/base/telephony/java/android/telephony/ServiceState.java	2013-05-03 21:47:21.447829849 +0545
@@ -487,7 +487,7 @@ public class ServiceState implements Par
                 + " EmergOnly=" + mIsEmergencyOnly);
     }
 
-    private void setNullState(int state) {
+    public void setNullState(int state) {
         mState = state;
         mRoaming = false;
         mOperatorAlphaLong = null;
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/base/wifi/java/android/net/wifi/WifiInfo.java pang/frameworks/base/wifi/java/android/net/wifi/WifiInfo.java
--- /media/ROM-Speicher/CM10.1/frameworks/base/wifi/java/android/net/wifi/WifiInfo.java	2013-04-02 21:48:06.229427985 +0545
+++ pang/frameworks/base/wifi/java/android/net/wifi/WifiInfo.java	2013-01-22 00:52:19.592703146 +0545
@@ -18,6 +18,7 @@ package android.net.wifi;
 
 import android.os.Parcelable;
 import android.os.Parcel;
+import android.privacy.utilities.PrivacyConstants;
 import android.net.NetworkInfo.DetailedState;
 import android.net.NetworkUtils;
 import android.text.TextUtils;
@@ -61,7 +62,7 @@ public class WifiInfo implements Parcela
     private String mBSSID;
     private WifiSsid mWifiSsid;
     private int mNetworkId;
-    private boolean mHiddenSSID;
+    private boolean mHiddenSSID;	
     /** Received Signal Strength Indicator */
     private int mRssi;
 
@@ -78,6 +79,26 @@ public class WifiInfo implements Parcela
      */
     private boolean mMeteredHint;
 
+
+    //---------------------------------------------------------------------------------------------------------------
+    /**
+     * Constructor for faking WifiInfo
+     * @hide
+     */
+    public WifiInfo(boolean fake){
+    	mWifiSsid = null; //nothing should happen -> better performance
+        mBSSID = "";
+        mNetworkId = -1;
+        mSupplicantState = SupplicantState.UNINITIALIZED;
+        mRssi = -9999;
+        mLinkSpeed = -1;
+        mHiddenSSID = false;
+        mMacAddress = PrivacyConstants.Network.WiFi.getMacAddress();
+        mMeteredHint = true;
+    }
+    //---------------------------------------------------------------------------------------------------------------
+
+
     WifiInfo() {
         mWifiSsid = null;
         mBSSID = null;
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/android/privacy/surrogate/PrivacyCDMALTEPhone.java pang/frameworks/opt/telephony/src/java/android/privacy/surrogate/PrivacyCDMALTEPhone.java
--- /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/android/privacy/surrogate/PrivacyCDMALTEPhone.java	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/opt/telephony/src/java/android/privacy/surrogate/PrivacyCDMALTEPhone.java	2013-02-04 22:22:00.775202539 +0545
@@ -0,0 +1,430 @@
+package android.privacy.surrogate;
+
+import android.content.Context;
+
+import android.os.Binder;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+import android.telephony.CellLocation;
+import android.telephony.ServiceState;
+import android.telephony.cdma.CdmaCellLocation;
+import android.util.Log;
+
+import com.android.internal.telephony.CallStateException;
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.PhoneNotifier;
+import com.android.internal.telephony.PhoneSubInfo;
+import com.android.internal.telephony.UUSInfo;
+import com.android.internal.telephony.cdma.CDMALTEPhone;
+/**
+ * Copyright (C) 2012-2013 Stefan Thiele (CollegeDev)
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev (Stefan T.)
+ * {@hide}
+ */
+public class PrivacyCDMALTEPhone extends CDMALTEPhone{
+
+	private static final String P_TAG = "PrivacyCDMALTEPhone";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private Context context;
+	
+	public PrivacyCDMALTEPhone(Context context, CommandsInterface cmdI, PhoneNotifier pN) {
+		super(context, cmdI, pN);
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		PrivacyDebugger.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	@Override
+	public String getMsisdn() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getMsisdn()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getMsisdn();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+//	public IsimRecords getIsimRecords() {
+//		return null;
+//	}
+	
+	@Override
+	public String getDeviceSvn() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceSvn()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceSvn();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getImei() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getImei");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getImei();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getSubscriberId() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getSubscriberId()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getSubscriberId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);
+        } else {
+            output = super.getSubscriberId();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet); 
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet); 
+        }
+        return output;
+	}
+	
+//	@Override
+//	public void notifyLocationChanged() {
+//		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for notifyLocationChanged()");
+//		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+//		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+//			//do nothing here
+//		}
+//		else
+//			mNotifier.notifyCellLocation(this);
+//	}
+	
+	@Override
+	public String getLine1AlphaTag() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1AlphaTag()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1AlphaTag();
+		}
+		return output;
+	}
+	
+	public ServiceState getSafeState() {
+		PrivacyDebugger.i(P_TAG, "getSafeState()");
+		ServiceState mState = super.getServiceState();
+		mState.setOperatorName("", "", "");;
+		return mState;
+	}
+	
+	@Override
+	public String getVoiceMailAlphaTag() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailAlphaTag()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailAlphaTag();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getVoiceMailNumber(){
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailNumber()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+
+	@Override
+	public String getDeviceId() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceId()");
+		String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, uid, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getMeid() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getMeid()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getMeid();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getEsn() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getEsn()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getEsn();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getLine1Number() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1Number()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1Number();
+		}
+		return output;
+	}
+	
+	@Override
+	public CellLocation getCellLocation() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getCellLocation()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return new CdmaCellLocation();
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getCellLocation();
+		}
+	}
+	
+	@Override
+	public PhoneSubInfo getPhoneSubInfo() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getPhoneSubInfo()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return null;
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getPhoneSubInfo();
+		}
+	}
+	
+	@Override
+	public ServiceState getServiceState() {
+		try{
+			PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getServiceState()");
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				if(settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				else
+					pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				ServiceState output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				output.setOperatorAlphaLong("");
+				return output;
+			}
+			else{
+				if(settings != null && settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				else
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				return super.getServiceState();
+			}
+		}
+		catch(Exception e){
+			PrivacyDebugger.e(P_TAG,"We got exception in getServiceState()-> give fake state", e);
+			ServiceState output = super.getServiceState();
+			output.setOperatorName("", "", "");
+			output.setOperatorAlphaLong("");
+			return output;
+		}
+	}
+	
+	@Override
+    public Connection dial(String dialNumber) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber);
+		}
+    }
+	
+	@Override
+    public Connection dial (String dialNumber, UUSInfo uusInfo) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber, uusInfo);
+		}
+	}
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/android/privacy/surrogate/PrivacyCDMAPhone.java pang/frameworks/opt/telephony/src/java/android/privacy/surrogate/PrivacyCDMAPhone.java
--- /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/android/privacy/surrogate/PrivacyCDMAPhone.java	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/opt/telephony/src/java/android/privacy/surrogate/PrivacyCDMAPhone.java	2013-02-04 22:22:15.907012305 +0545
@@ -0,0 +1,404 @@
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.os.Binder;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+import android.telephony.CellLocation;
+import android.telephony.ServiceState;
+import android.telephony.cdma.CdmaCellLocation;
+import android.util.Log;
+
+import com.android.internal.telephony.CallStateException;
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.PhoneNotifier;
+import com.android.internal.telephony.PhoneSubInfo;
+import com.android.internal.telephony.UUSInfo;
+import com.android.internal.telephony.cdma.CDMAPhone;
+
+/**
+ * Copyright (C) 2012-2013 Stefan Thiele (CollegeDev)
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev (Stefan T.)
+ * {@hide}
+ */
+public class PrivacyCDMAPhone extends CDMAPhone{
+
+	private static final String P_TAG = "PrivacyCDMAPhone";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private Context context;
+	
+	public PrivacyCDMAPhone(Context context, CommandsInterface cmdI, PhoneNotifier pN) {
+		super(context,cmdI,pN);
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		PrivacyDebugger.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	
+	@Override
+	public String getDeviceSvn() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceSvn()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceSvn();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getImei() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getImei");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getImei();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getSubscriberId() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getSubscriberId()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getSubscriberId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);  
+            else
+            	pSetMan.notification(packageName, 0, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);  
+        } else {
+            output = super.getSubscriberId();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);  
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);  
+        }
+        return output;
+	}
+	
+//	@Override
+//	public void notifyLocationChanged() {
+//		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for notifyLocationChanged()");
+//		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+//		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+//			//do nothing here
+//		}
+//		else
+//			mNotifier.notifyCellLocation(this);
+//	}
+	
+	@Override
+	public String getLine1AlphaTag() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1AlphaTag()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1AlphaTag();
+		}
+		return output;
+	}
+	
+	@Override
+	public String getVoiceMailAlphaTag() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailAlphaTag()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+        	output = super.getVoiceMailAlphaTag();
+        	if(pSet != null && pSet.isDefaultDenyObject())
+        		pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        	else
+        		pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getVoiceMailNumber(){
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailNumber()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+
+	@Override
+	public String getDeviceId() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceId()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getMeid() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getMeid()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getMeid();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	public ServiceState getSafeState() {
+		PrivacyDebugger.i(P_TAG, "getSafeState()");
+		ServiceState mState = super.getServiceState();
+		mState.setOperatorName("", "", "");;
+		return mState;
+	}
+	
+	@Override
+	public String getEsn() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getEsn()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getEsn();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getLine1Number() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1Number()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1Number();
+		}
+		return output;
+	}
+	
+	@Override
+	public CellLocation getCellLocation() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getCellLocation()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return new CdmaCellLocation();
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getCellLocation();
+		}
+	}
+	
+	@Override
+	public PhoneSubInfo getPhoneSubInfo() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getPhoneSubInfo()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return null;
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getPhoneSubInfo();
+		}
+	}
+	
+	@Override
+	public ServiceState getServiceState() {
+		try{
+			PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getServiceState()");
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				if(settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				else
+					pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				ServiceState output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				output.setOperatorAlphaLong("");
+				return output;
+			}
+			else{
+				if(settings != null && settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				else
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				return super.getServiceState();
+			}
+		}
+		catch(Exception e){
+			PrivacyDebugger.e(P_TAG,"We got exception in getServiceState()-> give fake state", e);
+			ServiceState output = super.getServiceState();
+			output.setOperatorName("", "", "");
+			output.setOperatorAlphaLong("");
+			return output;
+		}
+	}
+	
+	@Override
+    public Connection dial(String dialNumber) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else {
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber);
+		}
+    }
+	
+	@Override
+    public Connection dial (String dialNumber, UUSInfo uusInfo) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL) {
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else {
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber, uusInfo);
+		}
+	}
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/android/privacy/surrogate/PrivacyGSMPhone.java pang/frameworks/opt/telephony/src/java/android/privacy/surrogate/PrivacyGSMPhone.java
--- /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/android/privacy/surrogate/PrivacyGSMPhone.java	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/opt/telephony/src/java/android/privacy/surrogate/PrivacyGSMPhone.java	2013-02-04 22:22:29.510841284 +0545
@@ -0,0 +1,406 @@
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.os.Binder;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+import android.telephony.CellLocation;
+import android.telephony.ServiceState;
+import android.telephony.gsm.GsmCellLocation;
+import android.util.Log;
+
+import com.android.internal.telephony.CallStateException;
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.PhoneNotifier;
+import com.android.internal.telephony.PhoneSubInfo;
+import com.android.internal.telephony.UUSInfo;
+import com.android.internal.telephony.gsm.GSMPhone;
+
+/**
+ * Copyright (C) 2012-2013 Stefan Thiele (CollegeDev)
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev (Stefan T.)
+ * {@hide}
+ */
+public class PrivacyGSMPhone extends GSMPhone{
+
+	private static final String P_TAG = "PrivacyGSMPhone";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private Context context;
+	
+	public PrivacyGSMPhone(Context context, CommandsInterface cmdI, PhoneNotifier pN) {
+		super(context,cmdI,pN);
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		PrivacyDebugger.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	@Override
+	public String getDeviceSvn() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceSvn()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceSvn();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getImei() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getImei");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getImei();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getSubscriberId() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getSubscriberId()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getSubscriberId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);      
+            else
+            	pSetMan.notification(packageName, 0, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);   
+        } else {
+            output = super.getSubscriberId();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);   
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);   
+        }
+        return output;
+	}
+	
+	
+
+//	@Override
+//	public void notifyLocationChanged() {
+//		Log.i(P_TAG,"Package: " + context.getPackageName() + " asked for notifyLocationChanged()");
+//		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+//		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+//			//do nothing here
+//		}
+//		else
+//			mNotifier.notifyCellLocation(this);
+//	}
+	
+	@Override
+	public String getLine1AlphaTag() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1AlphaTag()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			output = super.getLine1AlphaTag();
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		return output;
+	}
+	
+	@Override
+	public String getVoiceMailAlphaTag() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailAlphaTag()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailAlphaTag();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getVoiceMailNumber(){
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailNumber()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+
+	@Override
+	public String getDeviceId() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceId()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getMeid() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getMeid()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getMeid();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getEsn() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getEsn()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getEsn();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getLine1Number() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1Number()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			output = super.getLine1Number();
+		}
+		return output;
+	}
+	
+	@Override
+	public CellLocation getCellLocation() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getCellLocation()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return new GsmCellLocation();
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getCellLocation();
+		}
+	}
+	
+	@Override
+	public PhoneSubInfo getPhoneSubInfo() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getPhoneSubInfo()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return null;
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getPhoneSubInfo();
+		}
+	}
+	
+	@Override
+	public ServiceState getServiceState() {
+		try{
+			PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getServiceState()");
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				if(settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				else
+					pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				ServiceState output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				output.setOperatorAlphaLong("");
+				return output;
+			}
+			else{
+				if(settings != null && settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				else
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				return super.getServiceState();
+			}
+		}
+		catch(Exception e){
+			PrivacyDebugger.e(P_TAG,"We got exception in getServiceState()-> give fake state", e);
+			ServiceState output = super.getServiceState();
+			output.setOperatorName("", "", "");
+			output.setOperatorAlphaLong("");
+			return output;
+		}
+	}
+	
+	public ServiceState getSafeState() {
+		PrivacyDebugger.i(P_TAG, "getSafeState()");
+		ServiceState mState = super.getServiceState();
+		mState.setOperatorName("", "", "");;
+		mState.setOperatorAlphaLong("");
+		return mState;
+	}
+
+	@Override
+    public Connection dial(String dialNumber) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber);
+		}
+    }
+	
+	@Override
+    public Connection dial (String dialNumber, UUSInfo uusInfo) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber, uusInfo);
+		}
+	}
+
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/android/privacy/surrogate/PrivacyPhoneProxy.java pang/frameworks/opt/telephony/src/java/android/privacy/surrogate/PrivacyPhoneProxy.java
--- /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/android/privacy/surrogate/PrivacyPhoneProxy.java	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/opt/telephony/src/java/android/privacy/surrogate/PrivacyPhoneProxy.java	2013-02-04 03:47:34.973297841 +0545
@@ -0,0 +1,867 @@
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.content.pm.IPackageManager;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+import android.telephony.CellLocation;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
+import android.telephony.cdma.CdmaCellLocation;
+import android.telephony.gsm.GsmCellLocation;
+import android.util.Log;
+import android.os.Process;
+
+import com.android.internal.telephony.CallStateException;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneProxy;
+import com.android.internal.telephony.PhoneSubInfo;
+import com.android.internal.telephony.UUSInfo;
+
+
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.PhoneBase;
+
+
+/**
+ * Copyright (C) 2012-2013 Stefan Thiele (CollegeDev)
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev (Stefan T.)
+ * {@hide}
+ */
+
+public class PrivacyPhoneProxy extends PhoneProxy{
+
+	private static final String P_TAG = "PrivacyPhoneProxy";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private Context context;
+	
+	private boolean context_available;
+	
+	/** This PackageManager is needed to get package name if context is not available*/
+	private IPackageManager mPm;
+	
+	public PrivacyPhoneProxy(PhoneBase mPhone, Context context) { //not sure if context is available, so test it!
+		super(mPhone);
+		if(context != null){
+			this.context = context;
+			context_available = true;
+		}
+		else{
+			context_available = false;
+		}
+		initiate(context_available);
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		PrivacyDebugger.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	/**
+	 * Method for initalize variables depends on context is availabe or not
+	 * @param ctx_av pass true, if context is available and false if not
+	 * {@hide}
+	 */
+	private void initiate(boolean ctx_av){
+		if(ctx_av){
+			PrivacyDebugger.i(P_TAG,"Context is available for package:" + context.getPackageName());
+		} else{
+			PrivacyDebugger.e(P_TAG,"Context is not available for package: " + context.getPackageName());
+			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+		}
+	}
+	
+	
+	/**
+     * {@hide}
+     * @return package names of current process which is using this object or null if something went wrong
+     */
+    private String[] getPackageName(){
+    	try{
+    		if(mPm != null){
+        		int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+        	}
+    		else{
+    			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+    			int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+    		}
+    	}
+    	catch(Exception e){
+    		PrivacyDebugger.e(P_TAG,"something went wrong with getting package name", e);
+    		return null;
+    	}
+    }
+    
+    @Override
+    public Connection dial(String dialNumber) throws CallStateException{
+    	if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+			if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL) {
+				if(settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+				else
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+				throw new CallStateException();
+			}
+			else{
+				if(settings != null && settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+				else
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+				return super.dial(dialNumber);
+			}
+		}
+    	else{
+    		String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			boolean default_deny = false;
+			if(package_names == null) {
+				switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+					case PrivacySettings.DEFAULT_DENY_REAL:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+						return super.dial(dialNumber); 
+					case PrivacySettings.DEFAULT_DENY_EMPTY:
+					case PrivacySettings.DEFAULT_DENY_RANDOM:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+						throw new CallStateException();
+				}
+				
+			}
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i]);
+				if(settings != null && settings.isDefaultDenyObject())
+					default_deny = true;
+				if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL) {
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed) {
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+				else
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+				return super.dial(dialNumber); 
+			}
+			else {
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+				else
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+				throw new CallStateException();
+			}
+    	}
+    }
+    
+    @Override
+    public Connection dial (String dialNumber, UUSInfo uusInfo) throws CallStateException{
+    	if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+			if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL) {
+				if(settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+				else
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+				throw new CallStateException();
+			}
+			else{
+				if(settings != null && settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+				else
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+				return super.dial(dialNumber, uusInfo);
+			}
+		}
+    	else{
+    		String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			boolean default_deny = false;
+			if(package_names == null) {
+				switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+					case PrivacySettings.DEFAULT_DENY_REAL:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+						return super.dial(dialNumber, uusInfo);
+					case PrivacySettings.DEFAULT_DENY_EMPTY:
+					case PrivacySettings.DEFAULT_DENY_RANDOM:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+						throw new CallStateException();
+				}
+			}
+				
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i]);
+				if(settings != null && settings.isDefaultDenyObject())
+					default_deny = true;
+				if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+				else
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+				return super.dial(dialNumber, uusInfo); 
+			}
+			else{
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+				else
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+				throw new CallStateException();
+			}
+    	}
+    }
+
+	@Override
+	public CellLocation getCellLocation() {
+		int phone_type = super.getPhoneType();
+		if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && (settings.getLocationNetworkSetting() != PrivacySettings.REAL || settings.getLocationGpsSetting() != PrivacySettings.REAL)){
+				if(settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, null);
+				else
+					pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, null);
+				PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getCellLocation()");
+				switch(phone_type){
+					case PhoneConstants.PHONE_TYPE_GSM:
+						return new GsmCellLocation();
+					case PhoneConstants.PHONE_TYPE_CDMA:
+						return new CdmaCellLocation();
+					case PhoneConstants.PHONE_TYPE_NONE:
+						return null;
+					case PhoneConstants.PHONE_TYPE_SIP:
+						return new CdmaCellLocation();
+					default: //just in case, but normally this doesn't get a call!
+						return new GsmCellLocation();
+				}
+			}
+			else{
+				if(settings != null && settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, null);
+				else
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, null);
+				PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getCellLocation(). Default deny: " + ((settings != null) ? settings.isDefaultDenyObject() : "unknown"));
+				return super.getCellLocation();
+			}
+		}
+		else{ //context is not available, go through uid!
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			boolean default_deny = false;
+			if(package_names == null) {
+				switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+					case PrivacySettings.DEFAULT_DENY_REAL:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, null);
+						return super.getCellLocation();
+					case PrivacySettings.DEFAULT_DENY_EMPTY:
+					case PrivacySettings.DEFAULT_DENY_RANDOM:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, null);
+						switch(phone_type){
+							case PhoneConstants.PHONE_TYPE_GSM:
+								return new GsmCellLocation();
+							case PhoneConstants.PHONE_TYPE_CDMA:
+								return new CdmaCellLocation();
+							case PhoneConstants.PHONE_TYPE_NONE:
+								return null;
+							case PhoneConstants.PHONE_TYPE_SIP:
+								return new CdmaCellLocation();
+							default: //just in case, but normally this doesn't get a call!
+								return new GsmCellLocation();
+						}
+				}
+			}
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i]);
+				if(settings != null && settings.isDefaultDenyObject())
+					default_deny = true;
+				if(pSetMan != null && settings != null && (settings.getLocationNetworkSetting() != PrivacySettings.REAL || settings.getLocationGpsSetting() != PrivacySettings.REAL)){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, null);
+				else
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, null);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getCellLocation()");
+				return super.getCellLocation();
+			}
+			else{
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, null);
+				else
+					pSetMan.notification(package_names[package_trace], 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, null);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getCellLocation()");
+				switch(phone_type){
+					case PhoneConstants.PHONE_TYPE_GSM:
+						return new GsmCellLocation();
+					case PhoneConstants.PHONE_TYPE_CDMA:
+						return new CdmaCellLocation();
+					case PhoneConstants.PHONE_TYPE_NONE:
+						return null;
+					case PhoneConstants.PHONE_TYPE_SIP:
+						return new CdmaCellLocation();
+					default: //just in case, but normally this doesn't get a call!
+						return new GsmCellLocation();
+				}
+			}
+		}
+	}
+	
+	@Override
+	public PhoneConstants.DataState getDataConnectionState() {
+		if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				if(settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				else
+					pSetMan.notification(context.getPackageName(), 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getDataConnection()");
+				return PhoneConstants.DataState.CONNECTING; //it's the best way to tell system that we are connecting
+			}
+			else{
+				if(settings != null && settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				else
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getDataConnection()");
+				return super.getDataConnectionState();
+			}
+		}
+		else{
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			boolean default_deny = false;
+			if(package_names == null) {
+				switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+					case PrivacySettings.DEFAULT_DENY_REAL:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+						return super.getDataConnectionState(); 
+					case PrivacySettings.DEFAULT_DENY_EMPTY:
+					case PrivacySettings.DEFAULT_DENY_RANDOM:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+						return PhoneConstants.DataState.CONNECTED;
+				}
+			}
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i]);
+				if(settings != null && settings.isDefaultDenyObject())
+					default_deny = true;
+				if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				else
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getDataConnection()");
+				return super.getDataConnectionState();
+			}
+			else{
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				else
+					pSetMan.notification(package_names[package_trace], 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getDataConnection()");
+				return PhoneConstants.DataState.CONNECTED;
+			}
+		}
+	}
+	
+//	@Override
+//	public State getState() {
+//		State.
+//		return null;
+//	}
+	
+//	@Override
+//	public String getPhoneName() {
+//		return null;
+//	}
+	
+//	@Override
+//	public int getPhoneType() {
+//		return 0;
+//	}
+	
+	@Override
+	public SignalStrength getSignalStrength() {
+		SignalStrength output = new SignalStrength();
+		if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				if(settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				else
+					pSetMan.notification(context.getPackageName(), 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getSignalStrength()");
+				return output;
+			}
+			else{
+				if(settings != null && settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				else
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getSignalStrength()");
+				return super.getSignalStrength();
+			}
+		}
+		else{
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			boolean default_deny = false;
+			if(package_names == null) {
+				switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+					case PrivacySettings.DEFAULT_DENY_REAL:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+						return super.getSignalStrength();
+					case PrivacySettings.DEFAULT_DENY_EMPTY:
+					case PrivacySettings.DEFAULT_DENY_RANDOM:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+						return output;
+				}
+			}
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i]);
+				if(settings != null && settings.isDefaultDenyObject())
+					default_deny = true;
+				if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				else
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getSignalStrength()");
+				return super.getSignalStrength();
+			}
+			else{
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				else
+					pSetMan.notification(package_names[package_trace], 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getSignalStrength()");
+				return output;
+			}
+		}
+	}
+	
+//	@Override
+//	public IccCard getIccCard() {
+//		return null;
+//	}
+
+	@Override
+	public String getLine1Number() {
+	   if(context_available){
+		   String packageName = context.getPackageName();
+	       PrivacySettings pSet = pSetMan.getSettings(packageName);
+	       String output;
+	       if (pSet != null && pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+	           output = pSet.getLine1Number(); // can be empty, custom or random
+	           if(pSet.isDefaultDenyObject())
+	        	   pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, null);
+	           else
+	        	   pSetMan.notification(packageName, 0, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, null);
+	           PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getLine1Number()");
+	       } else {
+	           output = super.getLine1Number();
+	           if(pSet != null && pSet.isDefaultDenyObject())
+	        	   pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, null);
+	           else
+	        	   pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, null);
+	           PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getLine1Number()");
+	       }
+	       return output;
+	   }
+	   else{
+		    String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			String output;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			boolean default_deny = false;
+			if(package_names == null){
+				switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+					case PrivacySettings.DEFAULT_DENY_REAL:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, null, null);
+						return super.getLine1Number();
+					case PrivacySettings.DEFAULT_DENY_EMPTY:
+					case PrivacySettings.DEFAULT_DENY_RANDOM:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, null, null);
+						return "";
+				}
+			}
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i]);
+				if(settings.isDefaultDenyObject())
+					default_deny = true;
+				if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				output = super.getLine1Number();
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+				else
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getLine1Number()");
+				return output;
+			}
+			else{
+				output = settings.getLine1Number();
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+				else
+					pSetMan.notification(package_names[package_trace], 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getLine1Number()");
+				return output;
+			}
+	   }
+	}
+	
+	/**
+	 * Will be handled like the Line1Number.
+	 */
+	@Override
+	public String getLine1AlphaTag() {
+		return getLine1Number();
+	}
+	
+	/**
+	 * Will be handled like the Line1Number, since voice mailbox numbers often
+	 * are similar to the phone number of the subscriber.
+	 */
+	@Override
+	public String getVoiceMailNumber() {
+		return getLine1Number();
+	}
+	
+	//will look at this later!
+//	@Override
+//	public void getNeighboringCids(Message response) {
+//		
+//	}
+	
+	@Override
+	public String getDeviceId() {
+		if(context_available){
+			String packageName = context.getPackageName();
+	        PrivacySettings pSet = pSetMan.getSettings(packageName);
+	        String output;
+	        if (pSet != null && pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+	            output = pSet.getDeviceId(); // can be empty, custom or random
+	            if(pSet.isDefaultDenyObject())
+	            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+	            else
+	            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+	            PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getDeviceId()");
+	        } else {
+	            output = super.getDeviceId();
+	            if(pSet != null && pSet.isDefaultDenyObject())
+	            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+	            else
+	            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+	            PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getDeviceId()");
+	        }
+	        return output;
+		}
+		else{
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			String output;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			boolean default_deny = false;
+			if(package_names == null) {
+				switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+					case PrivacySettings.DEFAULT_DENY_REAL:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, null, null);
+						return super.getDeviceId();
+					case PrivacySettings.DEFAULT_DENY_EMPTY:
+					case PrivacySettings.DEFAULT_DENY_RANDOM:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, null, null);
+						return "";
+				}
+			}
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i]);
+				if(settings != null && settings.isDefaultDenyObject())
+					default_deny = true;
+				if(pSetMan != null && settings != null && settings.getDeviceIdSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				output = super.getDeviceId();
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, settings);
+				else
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, settings);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getDeviceId()");
+				return output;
+			}
+			else{
+				output = settings.getDeviceId();
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, settings);
+				else
+					pSetMan.notification(package_names[package_trace], 0, settings.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, settings);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getDeviceId()");
+				return output;
+			}
+	   }
+	}
+	
+	/**
+	 * Will be handled like the DeviceID.
+	 */
+	@Override
+	public String getDeviceSvn() {
+		return getDeviceId();
+	}
+	
+	@Override
+	public String getSubscriberId() {
+		if(context_available){
+			String packageName = context.getPackageName();
+	        PrivacySettings pSet = pSetMan.getSettings(packageName);
+	        String output;
+	        if (pSet != null && pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+	            output = pSet.getSubscriberId(); // can be empty, custom or random
+	            if(pSet.isDefaultDenyObject())
+	            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);
+	            else
+	            	pSetMan.notification(packageName, 0, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);
+	            PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getSubscriberId()");
+	        } else {
+	            output = super.getSubscriberId();
+	            if(pSet != null && pSet.isDefaultDenyObject())
+	            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);   
+	            else
+	            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);   
+	            PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getSubscriberId()");
+	        }
+	        return output;
+		}
+		else{
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			String output;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			boolean default_deny = false;
+			if(package_names == null) {
+				switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+					case PrivacySettings.DEFAULT_DENY_REAL:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, null, null);
+						return super.getSubscriberId();
+					case PrivacySettings.DEFAULT_DENY_EMPTY:
+					case PrivacySettings.DEFAULT_DENY_RANDOM:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, null, null);
+						return "";
+				}
+			}
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i]);
+				if(settings != null && settings.isDefaultDenyObject())
+					default_deny = true;
+				if(pSetMan != null && settings != null && settings.getSubscriberIdSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				output = super.getSubscriberId();
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, settings);      
+				else
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, settings);      
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getSubscriberId()");
+				return output;
+			}
+			else{
+				output = settings.getSubscriberId();
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, settings);
+				else
+					pSetMan.notification(package_names[package_trace], 0, settings.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, settings);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getSubscriberId()");
+				return output;
+			}
+		}
+		
+	}
+	
+	/**
+	 * Will be handled like the SubscriberID.
+	 */
+	@Override
+	public String getIccSerialNumber() {
+		return getSubscriberId();
+	}
+	/**
+	 * Will be handled like the SubscriberID.
+	 */
+	@Override
+	public String getEsn() {
+		return getSubscriberId();
+	}
+	/**
+	 * Will be handled like the SubscriberID.
+	 */
+	@Override
+	public String getMeid() {
+		return getSubscriberId();
+	}
+	/**
+	 * Will be handled like the SubscriberID.
+	 */
+	@Override
+	public String getMsisdn() {
+		return getSubscriberId();
+	}
+	/**
+	 * Will be handled like the DeviceID.
+	 */
+	@Override
+	public String getImei() {
+		return getDeviceId();
+	}
+	
+	@Override
+	public PhoneSubInfo getPhoneSubInfo(){
+		PhoneSubInfo output = new PhoneSubInfo(this);
+		return output;
+	}
+	
+	@Override
+	public ServiceState getServiceState(){
+		ServiceState output;
+		if(context_available){
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				if(settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				else
+					pSetMan.notification(context.getPackageName(), 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " BLOCKED for getServiceState()");
+				output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				output.setOperatorAlphaLong("");
+				return output;
+			}
+			else{
+				if(settings != null && settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				else
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				PrivacyDebugger.i(P_TAG,"package: " + context.getPackageName() + " ALLOWED for getServiceState()");
+				return super.getServiceState();
+			}
+		}
+		else{
+			String package_names[] = getPackageName();
+			boolean allowed = true;
+			PrivacySettings settings = null;
+			int package_trace = 0; //initalize default with 0, prevents array index out of bounds exception
+			boolean default_deny = false;
+			if(package_names == null) {
+				switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+					case PrivacySettings.DEFAULT_DENY_REAL:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+						return super.getServiceState();
+					case PrivacySettings.DEFAULT_DENY_EMPTY:
+					case PrivacySettings.DEFAULT_DENY_RANDOM:
+						pSetMan.notification("UNKNOWN", 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);
+						output = super.getServiceState();
+						output.setOperatorName("", "", "");
+						output.setOperatorAlphaLong("");
+						return output;
+				}
+				
+			}
+			for(int i=0;i<package_names.length;i++){
+				settings = pSetMan.getSettings(package_names[i]);
+				if(settings != null && settings.isDefaultDenyObject())
+					default_deny = true;
+				if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+					allowed = false;
+					package_trace = i;
+					break;
+				}
+			}
+			if(allowed){
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				else
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " ALLOWED for getServiceState()");
+				return super.getServiceState();
+			}
+			else{
+				if(default_deny)
+					pSetMan.notification(package_names[package_trace], 0, PrivacySettings.ERROR, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				else
+					pSetMan.notification(package_names[package_trace], 0, settings.getNetworkInfoSetting(), PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, settings);
+				PrivacyDebugger.i(P_TAG,"package: " + package_names[package_trace] + " BLOCKED for getServiceState()");
+				output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				output.setOperatorAlphaLong("");
+				return output;
+			}
+		}
+	}
+	
+	
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/android/privacy/surrogate/PrivacySipPhone.java pang/frameworks/opt/telephony/src/java/android/privacy/surrogate/PrivacySipPhone.java
--- /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/android/privacy/surrogate/PrivacySipPhone.java	1970-01-01 05:30:00.000000000 +0530
+++ pang/frameworks/opt/telephony/src/java/android/privacy/surrogate/PrivacySipPhone.java	2013-02-04 22:25:01.504930458 +0545
@@ -0,0 +1,404 @@
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.net.sip.SipProfile;
+import android.os.Binder;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+import android.telephony.CellLocation;
+import android.telephony.ServiceState;
+import android.telephony.gsm.GsmCellLocation;
+import android.util.Log;
+
+import com.android.internal.telephony.CallStateException;
+import com.android.internal.telephony.Connection;
+import com.android.internal.telephony.PhoneNotifier;
+import com.android.internal.telephony.PhoneSubInfo;
+import com.android.internal.telephony.UUSInfo;
+import com.android.internal.telephony.sip.SipPhone;
+
+/**
+ * Copyright (C) 2012-2013 Stefan Thiele (CollegeDev)
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev (Stefan T.)
+ * {@hide}
+ */
+public class PrivacySipPhone extends SipPhone{
+
+	private static final String P_TAG = "PrivacyGSMPhone";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private Context context;
+	
+	public PrivacySipPhone(Context context, PhoneNotifier pN, SipProfile sP) {
+		super(context, pN, sP); //I've changed the constructor to public!
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		PrivacyDebugger.i(P_TAG,"Constructor ready for package: " + context.getPackageName());
+	}
+	
+	@Override
+	public String getDeviceSvn() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceSvn()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getImei() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getImei");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getImei();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getSubscriberId() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getSubscriberId()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getSubscriberId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);
+        } else {
+            output = super.getSubscriberId();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet); 
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet); 
+        }
+        return output;
+	}
+	
+
+//	void notifyLocationChanged() {
+//		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for notifyLocationChanged()");
+//		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Process.myUid());
+//		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+//			//do nothing here
+//		}
+//		else
+//			mNotifier.notifyCellLocation(this);
+//	}
+	
+	@Override
+	public String getLine1AlphaTag() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1AlphaTag()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			output = super.getLine1AlphaTag();
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		return output;
+	}
+	
+	@Override
+	public String getVoiceMailAlphaTag() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailAlphaTag()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailAlphaTag();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+	
+	public ServiceState getSafeState() {
+		PrivacyDebugger.i(P_TAG, "getSafeState()");
+		ServiceState mState = super.getServiceState();
+		mState.setOperatorName("", "", "");;
+		return mState;
+	}
+	
+	@Override
+	public String getVoiceMailNumber(){
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getVoiceMailNumber()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+        return output;
+	}
+
+	@Override
+	public String getDeviceId() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getDeviceId()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getMeid() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getMeid()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getMeid();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getEsn() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getEsn()");
+		String packageName = context.getPackageName();
+        PrivacySettings pSet = pSetMan.getSettings(packageName);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            if(pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getEsn();
+            if(pSet != null && pSet.isDefaultDenyObject())
+            	pSetMan.notification(packageName, 0, PrivacySettings.ERROR, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            else
+            	pSetMan.notification(packageName, 0, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+        return output;
+	}
+	
+	@Override
+	public String getLine1Number() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getLine1Number()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		String output = "";
+		if(pSetMan != null && settings != null && settings.getLine1NumberSetting() != PrivacySettings.REAL){
+			output = settings.getLine1Number();
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		else{
+			output = super.getLine1Number();
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, settings);
+		}
+		return output;
+	}
+	
+	@Override
+	public CellLocation getCellLocation() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getCellLocation()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return new GsmCellLocation();
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getCellLocation();
+		}
+	}
+	
+	@Override
+	public PhoneSubInfo getPhoneSubInfo() {
+		PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getPhoneSubInfo()");
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return null;
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+			return super.getPhoneSubInfo();
+		}
+	}
+	
+	@Override
+	public ServiceState getServiceState() {
+		try{
+			PrivacyDebugger.i(P_TAG,"Package: " + context.getPackageName() + " asked for getServiceState()");
+			PrivacySettings settings = pSetMan.getSettings(context.getPackageName());
+			if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+				if(settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				else
+					pSetMan.notification(context.getPackageName(), 0, settings.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				ServiceState output = super.getServiceState();
+				output.setOperatorName("", "", "");
+				output.setOperatorAlphaLong("");
+				return output;
+			}
+			else{
+				if(settings != null && settings.isDefaultDenyObject())
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				else
+					pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, settings);
+				return super.getServiceState();
+			}
+		}
+		catch(Exception e){
+			PrivacyDebugger.e(P_TAG,"We got exception in getServiceState()-> give fake state", e);
+			ServiceState output = super.getServiceState();
+			output.setOperatorName("", "", "");
+			output.setOperatorAlphaLong("");
+			return output;
+		}
+		
+	}
+	
+	@Override
+    public Connection dial(String dialNumber) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber);
+		}
+    }
+	
+	@Override
+    public Connection dial (String dialNumber, UUSInfo uusInfo) throws CallStateException{
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), -1);
+		if(pSetMan != null && settings != null && settings.getPhoneCallSetting() != PrivacySettings.REAL){
+			if(settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null, null);
+			throw new CallStateException();
+		}
+		else{
+			if(settings != null && settings.isDefaultDenyObject())
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.ERROR, PrivacySettings.DATA_PHONE_CALL, null, null);
+			else
+				pSetMan.notification(context.getPackageName(), 0, PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null, null);
+			return super.dial(dialNumber, uusInfo);
+		}
+	}
+
+}
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/CdmaDataConnectionTracker.java pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/CdmaDataConnectionTracker.java
--- /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/CdmaDataConnectionTracker.java	2013-04-02 21:48:06.689422202 +0545
+++ pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/CdmaDataConnectionTracker.java	2013-01-16 02:22:30.308303433 +0545
@@ -216,7 +216,7 @@ public final class CdmaDataConnectionTra
         }
 
         int psState = mCdmaPhone.mSST.getCurrentDataConnectionState();
-        boolean roaming = (mPhone.getServiceState().getRoaming() && !getDataOnRoamingEnabled());
+        boolean roaming = (((android.privacy.surrogate.PrivacyCDMAPhone)mPhone).getSafeState().getRoaming() && !getDataOnRoamingEnabled());
         boolean desiredPowerState = mCdmaPhone.mSST.getDesiredPowerState();
         boolean subscriptionFromNv = (mCdmaSSM.getCdmaSubscriptionSource()
                                        == CdmaSubscriptionSourceManager.SUBSCRIPTION_FROM_NV);
@@ -283,7 +283,7 @@ public final class CdmaDataConnectionTra
         }
 
         int psState = mCdmaPhone.mSST.getCurrentDataConnectionState();
-        boolean roaming = mPhone.getServiceState().getRoaming();
+        boolean roaming = ((android.privacy.surrogate.PrivacyCDMAPhone)mPhone).getSafeState().getRoaming();
         boolean desiredPowerState = mCdmaPhone.mSST.getDesiredPowerState();
 
         if ((mState == DctConstants.State.IDLE || mState == DctConstants.State.SCANNING) &&
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/CDMAPhone.java pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/CDMAPhone.java
--- /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/CDMAPhone.java	2013-04-02 21:48:06.689422202 +0545
+++ pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/CDMAPhone.java	2013-01-16 02:22:30.324295232 +0545
@@ -822,7 +822,7 @@ public class CDMAPhone extends PhoneBase
          super.notifyServiceStateChangedP(ss);
      }
 
-     void notifyLocationChanged() {
+     public void notifyLocationChanged() {
          mNotifier.notifyCellLocation(this);
      }
 
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
--- /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java	2013-04-02 21:48:06.689422202 +0545
+++ pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java	2013-01-19 00:36:54.065590386 +0545
@@ -68,6 +68,17 @@ import java.util.Date;
 import java.util.List;
 import java.util.TimeZone;
 
+/////////////////////////////////////////////////////////
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyConstants;
+
+import java.util.Random;
+/////////////////////////////////////////////////////////
+
+
 /**
  * {@hide}
  */
@@ -124,6 +135,11 @@ public class CdmaServiceStateTracker ext
     String mSavedTimeZone;
     long mSavedTime;
     long mSavedAtTime;
+    
+    //-------------------------------------------------------------------------------------------------------------------------------------------------
+    private Context mContext;
+    private PrivacySettingsManager pSetMan;
+    //-------------------------------------------------------------------------------------------------------------------------------------------------
 
     /** Wake lock used while setting time of day. */
     private PowerManager.WakeLock mWakeLock;
@@ -171,7 +187,14 @@ public class CdmaServiceStateTracker ext
 
     protected CdmaServiceStateTracker(CDMAPhone phone, CellInfo cellInfo) {
         super(phone, phone.mCM, cellInfo);
-
+        
+        
+        //-------------------------------------------------------------------------------------------------------------------------------------------------
+        this.mContext = phone.getContext();
+        pSetMan = new PrivacySettingsManager(mContext, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+        //-------------------------------------------------------------------------------------------------------------------------------------------------
+        
+        
         this.phone = phone;
         cr = phone.getContext().getContentResolver();
         cellLoc = new CdmaCellLocation();
@@ -206,6 +229,7 @@ public class CdmaServiceStateTracker ext
             Settings.System.getUriFor(Settings.System.AUTO_TIME_ZONE), true,
             mAutoTimeZoneObserver);
         setSignalStrengthDefaultValues();
+
     }
 
     @Override
@@ -374,10 +398,20 @@ public class CdmaServiceStateTracker ext
                         loge("error parsing cell location data: " + ex);
                     }
                 }
-
-                cellLoc.setCellLocationData(baseStationId, baseStationLatitude,
-                        baseStationLongitude, systemId, networkId);
+                //----------------------------------------------------------------------------------------------------------------------------------------------------------
+                PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName(), 0);
+                if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() != PrivacySettings.REAL){
+                	cellLoc.setCellLocationData(PrivacyConstants.CDMA.getCdmaBaseStationId(), 
+					                			PrivacyConstants.CDMA.getCdmaRandomLat(), 
+					                			PrivacyConstants.CDMA.getCdmaRandomLon(),
+					                			PrivacyConstants.CDMA.getCdmaSystemId(),
+					                			PrivacyConstants.CDMA.getCdmaNetworkId());
+                }
+                else{
+                	cellLoc.setCellLocationData(baseStationId, baseStationLatitude, baseStationLongitude, systemId, networkId);
+                }
                 phone.notifyLocationChanged();
+                //----------------------------------------------------------------------------------------------------------------------------------------------------------
             }
 
             // Release any temporary cell lock, which could have been
@@ -572,6 +606,7 @@ public class CdmaServiceStateTracker ext
     protected void handlePollStateResultMessage(int what, AsyncResult ar){
         int ints[];
         String states[];
+  	PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName(), 0);
         switch (what) {
         case EVENT_POLL_STATE_REGISTRATION_CDMA: // Handle RIL_REQUEST_REGISTRATION_STATE.
             states = (String[])ar.result;
@@ -659,10 +694,17 @@ public class CdmaServiceStateTracker ext
             mIsInPrl = (systemIsInPrl == 0) ? false : true;
             mDefaultRoamingIndicator = defaultRoamingIndicator;
 
-
-            // Values are -1 if not available.
-            newCellLoc.setCellLocationData(baseStationId, baseStationLatitude,
-                    baseStationLongitude, systemId, networkId);
+            //-------------------------------------------------------------------------------------------------------------------------------------------------------------
+            if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() != PrivacySettings.REAL){
+            	newCellLoc.setCellLocationData(	PrivacyConstants.CDMA.getCdmaBaseStationId(), 
+						            			PrivacyConstants.CDMA.getCdmaRandomLat(), 
+						            			PrivacyConstants.CDMA.getCdmaRandomLon(),
+						            			PrivacyConstants.CDMA.getCdmaSystemId(),
+						            			PrivacyConstants.CDMA.getCdmaNetworkId());
+            }else {
+            	newCellLoc.setCellLocationData(baseStationId, baseStationLatitude, baseStationLongitude, systemId, networkId);
+            }
+            //-------------------------------------------------------------------------------------------------------------------------------------------------------------
 
             if (reasonForDenial == 0) {
                 mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_GEN;
@@ -693,14 +735,25 @@ public class CdmaServiceStateTracker ext
                                 "'= " + opNames[2]);
                     }
                 }
-
+                //-----------------------------------------------------------------------------------------------------------------------------------------------------
                 if (!isSubscriptionFromRuim) {
                     // In CDMA in case on NV, the ss.mOperatorAlphaLong is set later with the
                     // ERI text, so here it is ignored what is coming from the modem.
-                    newSS.setOperatorName(null, opNames[1], opNames[2]);
+                	if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+                		newSS.setOperatorName(null, "", "");
+                	}
+                	else{
+                		newSS.setOperatorName(null, opNames[1], opNames[2]);
+                	}
                 } else {
-                    newSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
+                	if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+                		newSS.setOperatorName("", "", "");
+                	}
+                	else{
+                		newSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
+                	}
                 }
+                //-----------------------------------------------------------------------------------------------------------------------------------------------------
             } else {
                 if (DBG) log("EVENT_POLL_STATE_OPERATOR_CDMA: error parsing opNames");
             }
@@ -1001,15 +1054,30 @@ public class CdmaServiceStateTracker ext
             if ((cm.getRadioState().isOn()) && (!isSubscriptionFromRuim)) {
                 String eriText;
                 // Now the CDMAPhone sees the new ServiceState so it can get the new ERI text
-                if (ss.getState() == ServiceState.STATE_IN_SERVICE) {
-                    eriText = phone.getCdmaEriText();
-                } else {
-                    // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
-                    // mRegistrationState 0,2,3 and 4
-                    eriText = phone.getContext().getText(
-                            com.android.internal.R.string.roamingTextSearching).toString();
+                //---------------------------------------------------------------------------------------------------------------------------------------------------------
+                PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName(), 0);
+                if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+                	if (ss.getState() == ServiceState.STATE_IN_SERVICE) {
+                        eriText = "Protected by PDroid2.0";
+                    } else {
+                        // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
+                        // mRegistrationState 0,2,3 and 4
+                        eriText = phone.getContext().getText(
+                                com.android.internal.R.string.roamingTextSearching).toString();
+                    }
+                } else{
+                	//original code
+                	if (ss.getState() == ServiceState.STATE_IN_SERVICE) {
+                        eriText = phone.getCdmaEriText();
+                    } else {
+                        // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
+                        // mRegistrationState 0,2,3 and 4
+                        eriText = phone.getContext().getText(
+                                com.android.internal.R.string.roamingTextSearching).toString();
+                    }
                 }
                 ss.setOperatorAlphaLong(eriText);
+                //---------------------------------------------------------------------------------------------------------------------------------------------------------
             }
 
             String operatorNumeric;
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/RuimSmsInterfaceManager.java pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/RuimSmsInterfaceManager.java
--- /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/RuimSmsInterfaceManager.java	2013-04-02 21:48:06.693422152 +0545
+++ pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/RuimSmsInterfaceManager.java	2013-02-05 01:03:51.213125801 +0545
@@ -22,18 +22,28 @@ import android.os.AsyncResult;
 import android.os.Handler;
 import android.os.Message;
 import android.util.Log;
-
 import com.android.internal.telephony.IccConstants;
 import com.android.internal.telephony.IccSmsInterfaceManager;
 import com.android.internal.telephony.IccUtils;
 import com.android.internal.telephony.PhoneProxy;
 import com.android.internal.telephony.SMSDispatcher;
 import com.android.internal.telephony.SmsRawData;
-
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
+
+/////////////////////////////////////////////////////////////
+import android.content.pm.PackageManager;
+import android.os.Binder;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+/////////////////////////////////////////////////////////////
+
+
 import static android.telephony.SmsManager.STATUS_ON_ICC_FREE;
 
 /**
@@ -51,6 +61,172 @@ public class RuimSmsInterfaceManager ext
     private static final int EVENT_LOAD_DONE = 1;
     private static final int EVENT_UPDATE_DONE = 2;
 
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+    protected PrivacySettingsManager pSetMan;
+    
+    protected static final String P_TAG = "PrivacySMSInterfaceManager";
+    
+    protected static final int ACCESS_TYPE_SMS_MMS = 0;
+	protected static final int ACCESS_TYPE_ICC = 1;
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+	//-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    /**
+     * Gives the actual package names which are trying to send sms
+     * {@hide}
+     * @return package name array or null
+     */
+	protected String[] getPackageName(){
+		 PackageManager pm = mContext.getPackageManager();
+	     String[] packageNames = pm.getPackagesForUid(Binder.getCallingUid());
+	     return packageNames;
+	}
+    
+	/**
+     * This method also includes notifications!
+     * @param packageNames 
+     * @param accessType use constants ACCESS_TYPE_SMS_MMS and ACCESS_TYPE_ICC
+     * @return true if package is allowed or exception was thrown or packages are empty, false if package is not allowed 
+     * {@hide}
+     */
+    protected boolean isAllowed(String[] packageNames, int accessType){
+    	try{
+    		switch(accessType){
+    			case ACCESS_TYPE_SMS_MMS:
+    				PrivacySettings settings = null;
+    	        	if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i]);
+    	            		if(pSetMan != null && settings != null && settings.getSmsSendSetting() != PrivacySettings.REAL){
+    	            			if(settings.isDefaultDenyObject())
+    	            				notify(accessType, packageNames[i], PrivacySettings.ERROR);
+    	            			else
+    	            				notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0], PrivacySettings.REAL);
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		PrivacyDebugger.e(P_TAG,"isAllowed - can't parse permissions because packages or pSetMan is null -> handle default deny mode!");
+    	        		switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+    	        			case PrivacySettings.DEFAULT_DENY_EMPTY:
+    	        			case PrivacySettings.DEFAULT_DENY_RANDOM:
+    	        				PrivacyDebugger.w(P_TAG, "isAllowed - default deny mode is random or empty, handle it! output: false");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return false;
+    	        			case PrivacySettings.DEFAULT_DENY_REAL:
+    	        				PrivacyDebugger.w(P_TAG, "isAllowed - default deny mode is real, handle it! output: true");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return true;
+    	        			default://this normally not happens
+    	        				PrivacyDebugger.e(P_TAG, "isAllowed - wrong parameters set for default deny mode, implementation failure?!");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return true;
+    	        		}
+    	        	}
+    			case ACCESS_TYPE_ICC:
+    				if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i]);
+    	            		if(pSetMan != null && settings != null && settings.getIccAccessSetting() != PrivacySettings.REAL){
+    	            			if(settings.isDefaultDenyObject())
+    	            				notify(accessType, packageNames[i],PrivacySettings.ERROR);
+    	            			else
+    	            				notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		PrivacyDebugger.e(P_TAG,"isAllowed - can't parse permissions because packages or pSetMan is null -> handle default deny mode!");
+    	        		switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+    	        			case PrivacySettings.DEFAULT_DENY_EMPTY:
+    	        			case PrivacySettings.DEFAULT_DENY_RANDOM:
+    	        				PrivacyDebugger.w(P_TAG, "isAllowed - default deny mode is random or empty, handle it! output: false");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return false;
+    	        			case PrivacySettings.DEFAULT_DENY_REAL:
+    	        				PrivacyDebugger.w(P_TAG, "isAllowed - default deny mode is real, handle it! output: true");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return true;
+    	        			default://this normally not happens
+    	        				PrivacyDebugger.e(P_TAG, "isAllowed - wrong parameters set for default deny mode, implementation failure?!");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return true;
+    	        		}
+    	        	}
+    	        default:
+    	        	PrivacyDebugger.e(P_TAG, "isAllowed - passed wrong parameter, implementation failure?!");
+    	        	notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        	return true;
+    		}
+    	}
+    	catch(Exception e){
+    		PrivacyDebugger.e(P_TAG,"isAllowed - Got exception while checking for sms or ICC acess permission", e);
+    		PrivacyDebugger.e(P_TAG, "isAllowed - now handle default deny mode!");
+    		switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+				case PrivacySettings.DEFAULT_DENY_EMPTY:
+				case PrivacySettings.DEFAULT_DENY_RANDOM:
+					PrivacyDebugger.w(P_TAG, "isAllowed - default deny mode is random or empty, handle it! output: false");
+					notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+					return false;
+				case PrivacySettings.DEFAULT_DENY_REAL:
+					PrivacyDebugger.w(P_TAG, "isAllowed - default deny mode is real, handle it! output: true");
+					notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+					return true;
+				default: //this normally not happens
+					PrivacyDebugger.e(P_TAG, "isAllowed - wrong parameters set for default deny mode, implementation failure?!");
+					notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+					return true;
+    		}
+    		
+    	}
+    }
+    
+    /**
+     * {@hide}
+     * Helper method for method isAllowed() to show dataAccess toasts
+     * @param accessType use ACCESS_TYPE_SMS_MMS or ACCESS_TYPE_ICC
+     * @param packageName the package name
+     * @param accessMode PrivacySettings.REAL || PrivacySettings.CUSTOM || PrivacySettings.RANDOM || PrivacySettings.EMPTY
+     */
+    protected void notify(int accessType,String packageName, byte accessMode){
+    	switch(accessType){
+    		case ACCESS_TYPE_SMS_MMS:
+    			//Log.i("PrivacySmsManager","now send notify information outgoing sms");
+    			if (accessMode != PrivacySettings.REAL) {
+    				PrivacyDebugger.i(P_TAG,"ALLOWED package sending sms");
+    			} else if(accessMode == PrivacySettings.ERROR){
+    				PrivacyDebugger.i(P_TAG,"ERROR package sending sms (default deny mode)");
+    			} else
+    				PrivacyDebugger.i(P_TAG,"BLOCKED package sending sms");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_SMS_SEND, null, null);
+    			break;
+    		case ACCESS_TYPE_ICC:
+    			//Log.i("PrivacySmsManager","now send notify information ICC ACCESS");
+    			if (accessMode != PrivacySettings.REAL) {
+    				PrivacyDebugger.i(P_TAG,"ALLOWED package access to ICC");
+    			} else if(accessMode == PrivacySettings.ERROR) {
+    				PrivacyDebugger.i(P_TAG,"ERROR package access to ICC (default deny mode)");
+    			} else
+    				PrivacyDebugger.i(P_TAG,"BLOCKED package access to ICC");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_ICC_ACCESS, null, null);
+    			break;
+    	}
+    }
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
     Handler mHandler = new Handler() {
         @Override
         public void handleMessage(Message msg) {
@@ -114,6 +290,13 @@ public class RuimSmsInterfaceManager ext
         if (DBG) log("updateMessageOnIccEf: index=" + index +
                 " status=" + status + " ==> " +
                 "("+ pdu + ")");
+        
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return false;
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
         enforceReceiveAndSend("Updating message on RUIM");
         synchronized(mLock) {
             mSuccess = false;
@@ -150,6 +333,13 @@ public class RuimSmsInterfaceManager ext
         //NOTE smsc not used in RUIM
         if (DBG) log("copyMessageToIccEf: status=" + status + " ==> " +
                 "pdu=("+ Arrays.toString(pdu) + ")");
+        
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return false;
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
         enforceReceiveAndSend("Copying message to RUIM");
         synchronized(mLock) {
             mSuccess = false;
@@ -173,6 +363,12 @@ public class RuimSmsInterfaceManager ext
     public List<SmsRawData> getAllMessagesFromIccEf() {
         if (DBG) log("getAllMessagesFromEF");
 
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return new ArrayList<SmsRawData>();
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
         Context context = mPhone.getContext();
 
         context.enforceCallingPermission(
@@ -218,5 +414,6 @@ public class RuimSmsInterfaceManager ext
     protected void log(String msg) {
         Log.d(LOG_TAG, "[RuimSmsInterfaceManager] " + msg);
     }
+    
 }
 
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/gsm/GsmDataConnectionTracker.java pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/gsm/GsmDataConnectionTracker.java
--- /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/gsm/GsmDataConnectionTracker.java	2013-04-02 21:48:06.693422152 +0545
+++ pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/gsm/GsmDataConnectionTracker.java	2013-05-03 21:48:36.509335725 +0545
@@ -638,7 +638,7 @@ public final class GsmDataConnectionTrac
                     (mPhone.getState() == PhoneConstants.State.IDLE ||
                      mPhone.getServiceStateTracker().isConcurrentVoiceAndDataAllowed()) &&
                     internalDataEnabled &&
-                    (!mPhone.getServiceState().getRoaming() || getDataOnRoamingEnabled()) &&
+                    (!((android.privacy.surrogate.PrivacyGSMPhone)mPhone).getSafeState().getRoaming() || getDataOnRoamingEnabled()) &&
                     !mIsPsRestricted &&
                     desiredPowerState;
         if (!allowed && DBG) {
@@ -653,7 +653,7 @@ public final class GsmDataConnectionTrac
                 reason += " - Concurrent voice and data not allowed";
             }
             if (!internalDataEnabled) reason += " - mInternalDataEnabled= false";
-            if (mPhone.getServiceState().getRoaming() && !getDataOnRoamingEnabled()) {
+            if (((android.privacy.surrogate.PrivacyGSMPhone)mPhone).getSafeState().getRoaming() && !getDataOnRoamingEnabled()) {
                 reason += " - Roaming and data roaming not enabled";
             }
             if (mIsPsRestricted) reason += " - mIsPsRestricted= true";
@@ -2182,7 +2182,8 @@ public final class GsmDataConnectionTrac
 
         IccRecords r = mIccRecords.get();
         String operator = (r != null) ? r.getOperatorNumeric() : "";
-        int radioTech = mPhone.getServiceState().getRilRadioTechnology();
+        //int radioTech = mPhone.getServiceState().getRilRadioTechnology();
+        int radioTech = ((android.privacy.surrogate.PrivacyGSMPhone)mPhone).getSafeState().getRilRadioTechnology();
 
         // This is a workaround for a bug (7305641) where we don't failover to other
         // suitable APNs if our preferred APN fails.  On prepaid ATT sims we need to
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/gsm/GSMPhone.java pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/gsm/GSMPhone.java
--- /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/gsm/GSMPhone.java	2013-04-02 21:48:06.693422152 +0545
+++ pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/gsm/GSMPhone.java	2013-01-16 02:22:30.348282931 +0545
@@ -355,7 +355,7 @@ public class GSMPhone extends PhoneBase
     /**
      * Notify any interested party of a Phone state change {@link PhoneConstants.State}
      */
-    /*package*/ void notifyPhoneStateChanged() {
+    /*package*/ public void notifyPhoneStateChanged() {
         mNotifier.notifyPhoneState(this);
     }
 
@@ -393,7 +393,7 @@ public class GSMPhone extends PhoneBase
     }
 
     /*package*/
-    void notifyLocationChanged() {
+    public void notifyLocationChanged() {
         mNotifier.notifyCellLocation(this);
     }
 
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
--- /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java	2013-04-02 21:48:06.693422152 +0545
+++ pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java	2013-01-19 22:44:37.188731382 +0545
@@ -53,6 +53,7 @@ import android.os.Message;
 import android.os.PowerManager;
 import android.os.Registrant;
 import android.os.RegistrantList;
+
 import android.os.SystemClock;
 import android.os.SystemProperties;
 import android.os.UserHandle;
@@ -67,7 +68,6 @@ import android.text.TextUtils;
 import android.util.EventLog;
 import android.util.Log;
 import android.util.TimeUtils;
-
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.util.ArrayList;
@@ -78,6 +78,16 @@ import java.util.Date;
 import java.util.HashSet;
 import java.util.TimeZone;
 
+//////////////////////////////////////////////////////////
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyConstants;
+
+import java.util.Random;
+//////////////////////////////////////////////////////////
+
 /**
  * {@hide}
  */
@@ -89,7 +99,12 @@ final class GsmServiceStateTracker exten
     GsmCellLocation cellLoc;
     GsmCellLocation newCellLoc;
     int mPreferredNetworkType;
-
+    
+    //--------------------------------------------------------------------------
+    private Context mContext;
+    private PrivacySettingsManager pSetMan;
+    //--------------------------------------------------------------------------
+    
     private int gprsState = ServiceState.STATE_OUT_OF_SERVICE;
     private int newGPRSState = ServiceState.STATE_OUT_OF_SERVICE;
     private int mMaxDataCalls = 1;
@@ -234,7 +249,13 @@ final class GsmServiceStateTracker exten
         IntentFilter filter = new IntentFilter();
         filter.addAction(Intent.ACTION_LOCALE_CHANGED);
         phone.getContext().registerReceiver(mIntentReceiver, filter);
-
+        
+        //--------------------------------------------------------------------------
+        this.mContext = phone.getContext();
+        pSetMan = new PrivacySettingsManager(mContext, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+        //--------------------------------------------------------------------------
+        
+        
         // Gsm doesn't support OTASP so its not needed
         phone.notifyOtaspChanged(OTASP_NOT_NEEDED);
     }
@@ -342,8 +363,17 @@ final class GsmServiceStateTracker exten
                             Log.w(LOG_TAG, "error parsing location: " + ex);
                         }
                     }
-                    cellLoc.setLacAndCid(lac, cid);
+                    //---------------------------------------------------------------------------------------------------------------------
+                    PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName(), 0);
+                    if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() != PrivacySettings.REAL){
+                    	cellLoc.setLacAndCid(PrivacyConstants.GSM.getLocationAreaCode(), PrivacyConstants.GSM.getCellIdentity());
+                    	cellLoc.setPsc(PrivacyConstants.GSM.getPrimaryScramblingCode());
+                    } else {
+                    	cellLoc.setLacAndCid(lac, cid);
+                    }
                     phone.notifyLocationChanged();
+                    //---------------------------------------------------------------------------------------------------------------------
+                    
                 }
 
                 // Release any temporary cell lock, which could have been
@@ -526,7 +556,7 @@ final class GsmServiceStateTracker exten
                     "of service, set plmn='" + plmn + "'");
         } else if (ss.getState() == ServiceState.STATE_IN_SERVICE) {
             // In either home or roaming service
-            plmn = ss.getOperatorAlphaLong();
+            plmn = ss.getOperatorAlphaLong(); //we can allow this, because we catched it before
             showPlmn = !TextUtils.isEmpty(plmn) &&
                     ((rule & SIMRecords.SPN_RULE_SHOW_PLMN)
                             == SIMRecords.SPN_RULE_SHOW_PLMN);
@@ -539,10 +569,25 @@ final class GsmServiceStateTracker exten
         // The value of spn/showSpn are same in different scenarios.
         //    EXTRA_SHOW_SPN = depending on IccRecords rule
         //    EXTRA_SPN = spn
-        String spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
+        //String spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
+       
+        String spn;
+    	PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName());
+        //--------------------------------------------------------------------------------------------------------------------------------
+        //this part is needed because we do not changed the IccRecord class
+        if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+        	spn = "Protected by PDroid2.0";
+        }
+        else{
+        	spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
+        }
+        //--------------------------------------------------------------------------------------------------------------------------------
+        
+        
         boolean showSpn = !TextUtils.isEmpty(spn)
                 && ((rule & SIMRecords.SPN_RULE_SHOW_SPN)
                         == SIMRecords.SPN_RULE_SHOW_SPN);
+        
 
         // Update SPN_STRINGS_UPDATED_ACTION IFF any value changes
         if (showPlmn != curShowPlmn
@@ -604,6 +649,7 @@ final class GsmServiceStateTracker exten
                         ar.exception);
             }
         } else try {
+        	PrivacySettings settings = pSetMan.getSettings(mContext.getPackageName());
             switch (what) {
                 case EVENT_POLL_STATE_REGISTRATION:
                     states = (String[])ar.result;
@@ -642,9 +688,18 @@ final class GsmServiceStateTracker exten
                         mEmergencyOnly = false;
                     }
 
-                    // LAC and CID are -1 if not avail
-                    newCellLoc.setLacAndCid(lac, cid);
-                    newCellLoc.setPsc(psc);
+
+                    //--------------------------------------------------------------------------------------------------------------------------------
+                    if(pSetMan != null && settings != null && settings.getLocationNetworkSetting() != PrivacySettings.REAL){
+                    	newCellLoc.setLacAndCid(PrivacyConstants.GSM.getLocationAreaCode(), PrivacyConstants.GSM.getCellIdentity());
+                    	newCellLoc.setPsc(PrivacyConstants.GSM.getPrimaryScramblingCode());
+                    	
+                    } else{
+                    	newCellLoc.setLacAndCid(lac, cid);
+                        newCellLoc.setPsc(psc);
+                    }
+                    //--------------------------------------------------------------------------------------------------------------------------------
+                    
                 break;
 
                 case EVENT_POLL_STATE_GPRS:
@@ -682,7 +737,14 @@ final class GsmServiceStateTracker exten
                     String opNames[] = (String[])ar.result;
 
                     if (opNames != null && opNames.length >= 3) {
-                         newSS.setOperatorName (opNames[0], opNames[1], opNames[2]);
+                    	//--------------------------------------------------------------------------------------------------------------------------------
+                        if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+                        	newSS.setOperatorName ("", "", "");
+                        }
+                        else{
+                        	newSS.setOperatorName (opNames[0], opNames[1], opNames[2]);
+                        }
+                        //--------------------------------------------------------------------------------------------------------------------------------
                     }
                 break;
 
@@ -1041,7 +1103,7 @@ final class GsmServiceStateTracker exten
         }
 
         if (hasLocationChanged) {
-            phone.notifyLocationChanged();
+            phone.notifyLocationChanged(); //we can notify, because all sensitive data has changed before @author CollegeDev
         }
 
         if (! isGprsConsistent(gprsState, ss.getState())) {
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/gsm/SimSmsInterfaceManager.java pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/gsm/SimSmsInterfaceManager.java
--- /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/gsm/SimSmsInterfaceManager.java	2013-04-02 21:48:06.697422102 +0545
+++ pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/gsm/SimSmsInterfaceManager.java	2013-02-05 01:04:36.652554550 +0545
@@ -38,6 +38,14 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
+//////////////////////////////////////////////////////////////
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+/////////////////////////////////////////////////////////////
+
 import static android.telephony.SmsManager.STATUS_ON_ICC_FREE;
 
 /**
@@ -63,6 +71,172 @@ public class SimSmsInterfaceManager exte
     private static final int EVENT_SET_BROADCAST_CONFIG_DONE = 4;
     private static final int SMS_CB_CODE_SCHEME_MIN = 0;
     private static final int SMS_CB_CODE_SCHEME_MAX = 255;
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+    protected PrivacySettingsManager pSetMan;
+    
+    protected static final String P_TAG = "PrivacySMSInterfaceManager";
+    
+    protected static final int ACCESS_TYPE_SMS_MMS = 0;
+	protected static final int ACCESS_TYPE_ICC = 1;
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    /**
+     * Gives the actual package names which are trying to send sms
+     * {@hide}
+     * @return package name array or null
+     */
+	protected String[] getPackageName(){
+		 PackageManager pm = mContext.getPackageManager();
+	     String[] packageNames = pm.getPackagesForUid(Binder.getCallingUid());
+	     return packageNames;
+	}
+    
+	/**
+     * This method also includes notifications!
+     * @param packageNames 
+     * @param accessType use constants ACCESS_TYPE_SMS_MMS and ACCESS_TYPE_ICC
+     * @return true if package is allowed or exception was thrown or packages are empty, false if package is not allowed 
+     * {@hide}
+     */
+    protected boolean isAllowed(String[] packageNames, int accessType){
+    	try{
+    		switch(accessType){
+    			case ACCESS_TYPE_SMS_MMS:
+    				PrivacySettings settings = null;
+    	        	if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i]);
+    	            		if(pSetMan != null && settings != null && settings.getSmsSendSetting() != PrivacySettings.REAL){
+    	            			if(settings.isDefaultDenyObject())
+    	            				notify(accessType, packageNames[i], PrivacySettings.ERROR);
+    	            			else
+    	            				notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0], PrivacySettings.REAL);
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		PrivacyDebugger.e(P_TAG,"isAllowed - can't parse permissions because packages or pSetMan is null -> handle default deny mode!");
+    	        		switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+    	        			case PrivacySettings.DEFAULT_DENY_EMPTY:
+    	        			case PrivacySettings.DEFAULT_DENY_RANDOM:
+    	        				PrivacyDebugger.w(P_TAG, "isAllowed - default deny mode is random or empty, handle it! output: false");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return false;
+    	        			case PrivacySettings.DEFAULT_DENY_REAL:
+    	        				PrivacyDebugger.w(P_TAG, "isAllowed - default deny mode is real, handle it! output: true");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return true;
+    	        			default://this normally not happens
+    	        				PrivacyDebugger.e(P_TAG, "isAllowed - wrong parameters set for default deny mode, implementation failure?!");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return true;
+    	        		}
+    	        	}
+    			case ACCESS_TYPE_ICC:
+    				if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i]);
+    	            		if(pSetMan != null && settings != null && settings.getIccAccessSetting() != PrivacySettings.REAL){
+    	            			if(settings.isDefaultDenyObject())
+    	            				notify(accessType, packageNames[i],PrivacySettings.ERROR);
+    	            			else
+    	            				notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		PrivacyDebugger.e(P_TAG,"isAllowed - can't parse permissions because packages or pSetMan is null -> handle default deny mode!");
+    	        		switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+    	        			case PrivacySettings.DEFAULT_DENY_EMPTY:
+    	        			case PrivacySettings.DEFAULT_DENY_RANDOM:
+    	        				PrivacyDebugger.w(P_TAG, "isAllowed - default deny mode is random or empty, handle it! output: false");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return false;
+    	        			case PrivacySettings.DEFAULT_DENY_REAL:
+    	        				PrivacyDebugger.w(P_TAG, "isAllowed - default deny mode is real, handle it! output: true");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return true;
+    	        			default://this normally not happens
+    	        				PrivacyDebugger.e(P_TAG, "isAllowed - wrong parameters set for default deny mode, implementation failure?!");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return true;
+    	        		}
+    	        	}
+    	        default:
+    	        	PrivacyDebugger.e(P_TAG, "isAllowed - passed wrong parameter, implementation failure?!");
+    	        	notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        	return true;
+    		}
+    	}
+    	catch(Exception e){
+    		PrivacyDebugger.e(P_TAG,"isAllowed - Got exception while checking for sms or ICC acess permission", e);
+    		PrivacyDebugger.e(P_TAG, "isAllowed - now handle default deny mode!");
+    		switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+				case PrivacySettings.DEFAULT_DENY_EMPTY:
+				case PrivacySettings.DEFAULT_DENY_RANDOM:
+					PrivacyDebugger.w(P_TAG, "isAllowed - default deny mode is random or empty, handle it! output: false");
+					notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+					return false;
+				case PrivacySettings.DEFAULT_DENY_REAL:
+					PrivacyDebugger.w(P_TAG, "isAllowed - default deny mode is real, handle it! output: true");
+					notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+					return true;
+				default: //this normally not happens
+					PrivacyDebugger.e(P_TAG, "isAllowed - wrong parameters set for default deny mode, implementation failure?!");
+					notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+					return true;
+    		}
+    		
+    	}
+    }
+    
+    /**
+     * {@hide}
+     * Helper method for method isAllowed() to show dataAccess toasts
+     * @param accessType use ACCESS_TYPE_SMS_MMS or ACCESS_TYPE_ICC
+     * @param packageName the package name
+     * @param accessMode PrivacySettings.REAL || PrivacySettings.CUSTOM || PrivacySettings.RANDOM || PrivacySettings.EMPTY
+     */
+    protected void notify(int accessType,String packageName, byte accessMode){
+    	switch(accessType){
+    		case ACCESS_TYPE_SMS_MMS:
+    			//Log.i("PrivacySmsManager","now send notify information outgoing sms");
+    			if (accessMode != PrivacySettings.REAL) {
+    				PrivacyDebugger.i(P_TAG,"ALLOWED package sending sms");
+    			} else if(accessMode == PrivacySettings.ERROR){
+    				PrivacyDebugger.i(P_TAG,"ERROR package sending sms (default deny mode)");
+    			} else
+    				PrivacyDebugger.i(P_TAG,"BLOCKED package sending sms");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_SMS_SEND, null, null);
+    			break;
+    		case ACCESS_TYPE_ICC:
+    			//Log.i("PrivacySmsManager","now send notify information ICC ACCESS");
+    			if (accessMode != PrivacySettings.REAL) {
+    				PrivacyDebugger.i(P_TAG,"ALLOWED package access to ICC");
+    			} else if(accessMode == PrivacySettings.ERROR) {
+    				PrivacyDebugger.i(P_TAG,"ERROR package access to ICC (default deny mode)");
+    			} else
+    				PrivacyDebugger.i(P_TAG,"BLOCKED package access to ICC");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_ICC_ACCESS, null, null);
+    			break;
+    	}
+    }
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
 
     Handler mHandler = new Handler() {
         @Override
@@ -136,6 +310,11 @@ public class SimSmsInterfaceManager exte
         if (DBG) log("updateMessageOnIccEf: index=" + index +
                 " status=" + status + " ==> " +
                 "("+ Arrays.toString(pdu) + ")");
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return false;
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
         enforceReceiveAndSend("Updating message on SIM");
         synchronized(mLock) {
             mSuccess = false;
@@ -173,6 +352,13 @@ public class SimSmsInterfaceManager exte
         if (DBG) log("copyMessageToIccEf: status=" + status + " ==> " +
                 "pdu=("+ Arrays.toString(pdu) +
                 "), smsm=(" + Arrays.toString(smsc) +")");
+        
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return false;
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
         enforceReceiveAndSend("Copying message to SIM");
         synchronized(mLock) {
             mSuccess = false;
@@ -198,6 +384,12 @@ public class SimSmsInterfaceManager exte
     public List<SmsRawData> getAllMessagesFromIccEf() {
         if (DBG) log("getAllMessagesFromEF");
 
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(),ACCESS_TYPE_ICC)){
+        	return new ArrayList<SmsRawData>();
+        }
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
         Context context = mPhone.getContext();
 
         context.enforceCallingPermission(
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java
--- /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java	2013-04-02 21:48:06.681422302 +0545
+++ pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java	2013-01-16 02:22:30.348282931 +0545
@@ -31,6 +31,7 @@ import android.os.Message;
 import android.os.RegistrantList;
 import android.os.SystemProperties;
 import android.preference.PreferenceManager;
+import android.privacy.utilities.PrivacyDebugger;
 import android.provider.Settings;
 import android.telephony.CellInfo;
 import android.telephony.ServiceState;
@@ -288,7 +289,7 @@ public abstract class PhoneBase extends
         mDataConnectionTracker = null;
         mUiccController = null;
     }
-
+    
     /**
      * When overridden the derived class needs to call
      * super.handleMessage(msg) so this method has a
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneFactory.java pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneFactory.java
--- /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneFactory.java	2013-04-02 21:48:06.681422302 +0545
+++ pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneFactory.java	2013-01-17 00:47:33.624399396 +0545
@@ -24,16 +24,25 @@ import android.telephony.TelephonyManage
 import android.util.Log;
 import android.os.SystemProperties;
 
-import com.android.internal.telephony.cdma.CDMAPhone;
-import com.android.internal.telephony.cdma.CDMALTEPhone;
+//import com.android.internal.telephony.cdma.CDMAPhone;
+//mport com.android.internal.telephony.cdma.CDMALTEPhone;
 import com.android.internal.telephony.cdma.CdmaSubscriptionSourceManager;
-import com.android.internal.telephony.gsm.GSMPhone;
+//import com.android.internal.telephony.gsm.GSMPhone;
 import com.android.internal.telephony.sip.SipPhone;
 import com.android.internal.telephony.sip.SipPhoneFactory;
 import com.android.internal.telephony.uicc.UiccController;
 
 import java.lang.reflect.Constructor;
 
+//--------------------------------------------------------
+import android.privacy.surrogate.PrivacyCDMAPhone;
+import android.privacy.surrogate.PrivacyCDMALTEPhone;
+import android.privacy.surrogate.PrivacyGSMPhone;
+import android.privacy.surrogate.PrivacySipPhone;
+import android.privacy.surrogate.PrivacyPhoneProxy;
+import android.privacy.utilities.PrivacyDebugger;
+//--------------------------------------------------------
+
 /**
  * {@hide}
  */
@@ -144,20 +153,27 @@ public class PhoneFactory {
                 int phoneType = TelephonyManager.getPhoneType(networkMode);
                 if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
                     Log.i(LOG_TAG, "Creating GSMPhone");
-                    sProxyPhone = new PhoneProxy(new GSMPhone(context,
-                            sCommandsInterface, sPhoneNotifier));
+//                    sProxyPhone = new PhoneProxy(new GSMPhone(context,
+//                            sCommandsInterface, sPhoneNotifier));
+                    sProxyPhone = new PrivacyPhoneProxy(new PrivacyGSMPhone(context, sCommandsInterface, sPhoneNotifier),context);
+                    PrivacyDebugger.i("PhoneFactory", "user is now using privacy GSM Phone");
                 } else if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
                     switch (TelephonyManager.getLteOnCdmaModeStatic()) {
                         case PhoneConstants.LTE_ON_CDMA_TRUE:
                             Log.i(LOG_TAG, "Creating CDMALTEPhone");
-                            sProxyPhone = new PhoneProxy(new CDMALTEPhone(context,
-                                sCommandsInterface, sPhoneNotifier));
+//                            sProxyPhone = new PhoneProxy(new CDMALTEPhone(context,
+//                                sCommandsInterface, sPhoneNotifier));
+                            sProxyPhone = new PrivacyPhoneProxy(new PrivacyCDMALTEPhone(context, sCommandsInterface, sPhoneNotifier), context);
+                            PrivacyDebugger.i("PhoneFactory", "user is now using privacy CDMALTE Phone");
+                            
                             break;
                         case PhoneConstants.LTE_ON_CDMA_FALSE:
                         default:
                             Log.i(LOG_TAG, "Creating CDMAPhone");
-                            sProxyPhone = new PhoneProxy(new CDMAPhone(context,
-                                    sCommandsInterface, sPhoneNotifier));
+//                            sProxyPhone = new PhoneProxy(new CDMAPhone(context,
+//                                    sCommandsInterface, sPhoneNotifier));
+                            sProxyPhone = new PrivacyPhoneProxy(new PrivacyCDMAPhone(context, sCommandsInterface, sPhoneNotifier), context);
+                            PrivacyDebugger.i("PhoneFactory", "user is now using privacy CDMA Phone");
                             break;
                     }
                 }
@@ -184,13 +200,17 @@ public class PhoneFactory {
         synchronized(PhoneProxy.lockForRadioTechnologyChange) {
             switch (TelephonyManager.getLteOnCdmaModeStatic()) {
                 case PhoneConstants.LTE_ON_CDMA_TRUE: {
-                    phone = new CDMALTEPhone(sContext, sCommandsInterface, sPhoneNotifier);
+//                    phone = new CDMALTEPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    phone = new PrivacyCDMALTEPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    PrivacyDebugger.i("PhoneFactory", "getCdmaPhone - returning privacy CDMALTE phone");
                     break;
                 }
                 case PhoneConstants.LTE_ON_CDMA_FALSE:
                 case PhoneConstants.LTE_ON_CDMA_UNKNOWN:
                 default: {
-                    phone = new CDMAPhone(sContext, sCommandsInterface, sPhoneNotifier);
+//                    phone = new CDMAPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    phone = new PrivacyCDMAPhone(sContext, sCommandsInterface, sPhoneNotifier);
+                    PrivacyDebugger.i("PhoneFactory", "getCdmaPhone - returning privacy cdma phone");
                     break;
                 }
             }
@@ -200,7 +220,8 @@ public class PhoneFactory {
 
     public static Phone getGsmPhone() {
         synchronized(PhoneProxy.lockForRadioTechnologyChange) {
-            Phone phone = new GSMPhone(sContext, sCommandsInterface, sPhoneNotifier);
+            Phone phone = new PrivacyGSMPhone(sContext, sCommandsInterface, sPhoneNotifier);
+            PrivacyDebugger.i("PhoneFactory", "getGsmPhone - returning privacy GSM phone");
             return phone;
         }
     }
@@ -211,6 +232,7 @@ public class PhoneFactory {
      * @return the {@code SipPhone} object or null if the SIP URI is not valid
      */
     public static SipPhone makeSipPhone(String sipUri) {
+    	PrivacyDebugger.i("PhoneFactory", "makeSipPhone() - returning privacy sip phone");
         return SipPhoneFactory.makePhone(sipUri, sContext, sPhoneNotifier);
     }
 }
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/sip/SipPhoneFactory.java pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/sip/SipPhoneFactory.java
--- /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/sip/SipPhoneFactory.java	2013-04-02 21:48:06.697422102 +0545
+++ pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/sip/SipPhoneFactory.java	2013-01-16 02:22:30.348282931 +0545
@@ -21,6 +21,7 @@ import com.android.internal.telephony.Ph
 import android.content.Context;
 import android.net.sip.SipProfile;
 import android.util.Log;
+import android.privacy.surrogate.PrivacySipPhone;
 
 import java.text.ParseException;
 
@@ -40,7 +41,7 @@ public class SipPhoneFactory {
             PhoneNotifier phoneNotifier) {
         try {
             SipProfile profile = new SipProfile.Builder(sipUri).build();
-            return new SipPhone(context, phoneNotifier, profile);
+            return new PrivacySipPhone(context, phoneNotifier, profile);
         } catch (ParseException e) {
             Log.w("SipPhoneFactory", "makePhone", e);
             return null;
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/sip/SipPhone.java pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/sip/SipPhone.java
--- /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/sip/SipPhone.java	2013-04-02 21:48:06.697422102 +0545
+++ pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/sip/SipPhone.java	2013-01-16 02:22:30.348282931 +0545
@@ -61,7 +61,7 @@ public class SipPhone extends SipPhoneBa
     private SipManager mSipManager;
     private SipProfile mProfile;
 
-    SipPhone (Context context, PhoneNotifier notifier, SipProfile profile) {
+    public SipPhone (Context context, PhoneNotifier notifier, SipProfile profile) {
         super(context, notifier);
 
         if (DEBUG) Log.d(LOG_TAG, "new SipPhone: " + profile.getUriString());
diff -rupN '--exclude=.svn' '--exclude=.git*' '--exclude=*.java~' '--exclude=*.mk~' '--exclude=*.orig~' '--exclude=*.txt' '--exclude=*.orig' '--exclude=*.rej' '--exclude=*.latest' '--exclude=*.txt~' '--exclude=*.xml~' '--exclude=*xml.orig~' '--exclude=*.xml.orig' '--exclude=*.patch~' '--exclude=*.patch' '--exclude=*.diff~' '--exclude=*.diff~' '--exclude=*.aidl~' '--exclude=*.xml~' '--exclude=*.latest' '--exclude=*.latest~' '--exclude=*~' /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/SMSDispatcher.java pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/SMSDispatcher.java
--- /media/ROM-Speicher/CM10.1/frameworks/opt/telephony/src/java/com/android/internal/telephony/SMSDispatcher.java	2013-04-02 21:48:06.681422302 +0545
+++ pang/frameworks/opt/telephony/src/java/com/android/internal/telephony/SMSDispatcher.java	2013-02-08 19:40:48.523471197 +0545
@@ -74,6 +74,14 @@ import java.util.concurrent.atomic.Atomi
 import java.util.HashMap;
 import java.util.Random;
 
+// BEGIN PRIVACY ADDED
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.utilities.PrivacyDebugger;
+// END PRIVACY ADDED
+
 import static android.telephony.SmsManager.RESULT_ERROR_FDN_CHECK_FAILURE;
 import static android.telephony.SmsManager.RESULT_ERROR_GENERIC_FAILURE;
 import static android.telephony.SmsManager.RESULT_ERROR_LIMIT_EXCEEDED;
@@ -197,6 +205,174 @@ public abstract class SMSDispatcher exte
         sConcatenatedRef += 1;
         return sConcatenatedRef;
     }
+    
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+    protected PrivacySettingsManager pSetMan;
+    
+    protected static final String P_TAG = "PrivacySMSDispatcher";
+    
+    protected static final int ACCESS_TYPE_SMS_MMS = 0;
+	protected static final int ACCESS_TYPE_ICC = 1;
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    /**
+     * Gives the actual package names which are trying to send sms
+     * {@hide}
+     * @return package name array or null
+     */
+	protected String[] getPackageName(){
+		 PackageManager pm = mContext.getPackageManager();
+	     String[] packageNames = pm.getPackagesForUid(Binder.getCallingUid());
+	     return packageNames;
+	}
+    
+    /**
+     * This method also includes notifications!
+     * @param packageNames 
+     * @param accessType use constants ACCESS_TYPE_SMS_MMS and ACCESS_TYPE_ICC
+     * @return true if package is allowed or exception was thrown or packages are empty, false if package is not allowed 
+     * {@hide}
+     */
+    protected boolean isAllowed(String[] packageNames, int accessType){
+    	try{
+    		switch(accessType){
+    			case ACCESS_TYPE_SMS_MMS:
+    				PrivacySettings settings = null;
+    	        	if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i]);
+    	            		if(pSetMan != null && settings != null && settings.getSmsSendSetting() != PrivacySettings.REAL){
+    	            			if(settings.isDefaultDenyObject())
+    	            				notify(accessType, packageNames[i], PrivacySettings.ERROR);
+    	            			else
+    	            				notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0], PrivacySettings.REAL);
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		PrivacyDebugger.e(TAG,"isAllowed - can't parse permissions because packages or pSetMan is null -> handle default deny mode!");
+    	        		switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+    	        			case PrivacySettings.DEFAULT_DENY_EMPTY:
+    	        			case PrivacySettings.DEFAULT_DENY_RANDOM:
+    	        				PrivacyDebugger.w(TAG, "isAllowed - default deny mode is random or empty, handle it! output: false");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return false;
+    	        			case PrivacySettings.DEFAULT_DENY_REAL:
+    	        				PrivacyDebugger.w(TAG, "isAllowed - default deny mode is real, handle it! output: true");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return true;
+    	        			default://this normally not happens
+    	        				PrivacyDebugger.e(TAG, "isAllowed - wrong parameters set for default deny mode, implementation failure?!");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return true;
+    	        		}
+    	        	}
+    			case ACCESS_TYPE_ICC:
+    				if(pSetMan == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    	        	if(pSetMan != null && packageNames != null){
+    	        		for(int i=0; i < packageNames.length; i++){
+    	            		settings = pSetMan.getSettings(packageNames[i]);
+    	            		if(pSetMan != null && settings != null && settings.getIccAccessSetting() != PrivacySettings.REAL){
+    	            			if(settings.isDefaultDenyObject())
+    	            				notify(accessType, packageNames[i],PrivacySettings.ERROR);
+    	            			else
+    	            				notify(accessType, packageNames[i],PrivacySettings.EMPTY);
+    	            			return false;
+    	            		}
+    	            		settings = null;
+    	            	}
+    	        		notify(accessType, packageNames[0],PrivacySettings.REAL);
+    	        		return true;
+    	        	}
+    	        	else{
+    	        		PrivacyDebugger.e(TAG,"isAllowed - can't parse permissions because packages or pSetMan is null -> handle default deny mode!");
+    	        		switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+    	        			case PrivacySettings.DEFAULT_DENY_EMPTY:
+    	        			case PrivacySettings.DEFAULT_DENY_RANDOM:
+    	        				PrivacyDebugger.w(TAG, "isAllowed - default deny mode is random or empty, handle it! output: false");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return false;
+    	        			case PrivacySettings.DEFAULT_DENY_REAL:
+    	        				PrivacyDebugger.w(TAG, "isAllowed - default deny mode is real, handle it! output: true");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return true;
+    	        			default://this normally not happens
+    	        				PrivacyDebugger.e(TAG, "isAllowed - wrong parameters set for default deny mode, implementation failure?!");
+    	        				notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        				return true;
+    	        		}
+    	        	}
+    	        default:
+    	        	PrivacyDebugger.e(TAG, "isAllowed - passed wrong parameter, implementation failure?!");
+    	        	notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+    	        	return true;
+    		}
+    	}
+    	catch(Exception e){
+    		PrivacyDebugger.e(P_TAG,"isAllowed - Got exception while checking for sms or ICC acess permission", e);
+    		PrivacyDebugger.e(TAG, "isAllowed - now handle default deny mode!");
+    		switch(PrivacySettings.CURRENT_DEFAULT_DENY_MODE) {
+				case PrivacySettings.DEFAULT_DENY_EMPTY:
+				case PrivacySettings.DEFAULT_DENY_RANDOM:
+					PrivacyDebugger.w(TAG, "isAllowed - default deny mode is random or empty, handle it! output: false");
+					notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+					return false;
+				case PrivacySettings.DEFAULT_DENY_REAL:
+					PrivacyDebugger.w(TAG, "isAllowed - default deny mode is real, handle it! output: true");
+					notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+					return true;
+				default: //this normally not happens
+					PrivacyDebugger.e(TAG, "isAllowed - wrong parameters set for default deny mode, implementation failure?!");
+					notify(accessType, "UNKNOWN", PrivacySettings.ERROR);
+					return true;
+    		}
+    		
+    	}
+    }
+    
+    /**
+     * {@hide}
+     * Helper method for method isAllowed() to show dataAccess toasts
+     * @param accessType use ACCESS_TYPE_SMS_MMS or ACCESS_TYPE_ICC
+     * @param packageName the package name
+     * @param accessMode PrivacySettings.REAL || PrivacySettings.CUSTOM || PrivacySettings.RANDOM || PrivacySettings.EMPTY
+     */
+    protected void notify(int accessType,String packageName, byte accessMode){
+    	switch(accessType){
+    		case ACCESS_TYPE_SMS_MMS:
+    			//Log.i("PrivacySmsManager","now send notify information outgoing sms");
+    			if (accessMode != PrivacySettings.REAL) {
+    				PrivacyDebugger.i(P_TAG,"BLOCKED package sending sms");
+    			} else if(accessMode == PrivacySettings.ERROR){
+    				PrivacyDebugger.i(P_TAG,"ERROR package sending sms (default deny mode)");
+    			} else
+    				PrivacyDebugger.i(P_TAG,"ALLOWED package sending sms");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_SMS_SEND, null, null);
+    			break;
+    		case ACCESS_TYPE_ICC:
+    			//Log.i("PrivacySmsManager","now send notify information ICC ACCESS");
+    			if (accessMode != PrivacySettings.REAL) {
+    				PrivacyDebugger.i(P_TAG,"BLOCKED package access to ICC");
+    			} else if(accessMode == PrivacySettings.ERROR) {
+    				PrivacyDebugger.i(P_TAG,"ERROR package access to ICC (default deny mode)");
+    			} else
+    				PrivacyDebugger.i(P_TAG,"ALLOWED package access to ICC");
+    			pSetMan.notification(packageName, 0, accessMode, PrivacySettings.DATA_ICC_ACCESS, null, null);
+    			break;
+    	}
+    }
+    
+    //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+    
 
     /**
      * Create a new SMS dispatcher.
@@ -219,7 +395,13 @@ public abstract class SMSDispatcher exte
                 Settings.Global.SMS_SHORT_CODE_RULE), false, mSettingsObserver);
 
         createWakelock();
-
+        
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
+        if(pSetMan == null) new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+        
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        
         mSmsCapable = mContext.getResources().getBoolean(
                 com.android.internal.R.bool.config_sms_capable);
         mSmsReceiveDisabled = !SystemProperties.getBoolean(
@@ -872,7 +1054,7 @@ public abstract class SMSDispatcher exte
             encodingForParts[i] = details;
         }
 
-        for (int i = 0; i < msgCount; i++) {
+        for (int i = 0; i < msgCount; i++) { 
             SmsHeader.ConcatRef concatRef = new SmsHeader.ConcatRef();
             concatRef.refNumber = refNumber;
             concatRef.seqNumber = i + 1;  // 1-based sequence
@@ -1007,7 +1189,20 @@ public abstract class SMSDispatcher exte
             }
             return;
         }
-
+        PrivacyDebugger.i(P_TAG, "sendRawPdu - now check if package is allowed to send sms");
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
+        if(!isAllowed(getPackageName(), ACCESS_TYPE_SMS_MMS)){
+        	if (sentIntent != null) {
+                try {
+                    sentIntent.send(RESULT_ERROR_GENERIC_FAILURE);
+                    PrivacyDebugger.i(P_TAG, "blocked sending sms");
+                } catch (CanceledException e) {}
+            }
+        	PrivacyDebugger.i(P_TAG, "returning; aborted sms sending");
+        	return;
+        }
+        PrivacyDebugger.i(P_TAG, "going to allow sending sms");
+        //-------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------------------------------------------------
         HashMap<String, Object> map = new HashMap<String, Object>();
         map.put("smsc", smsc);
         map.put("pdu", pdu);
